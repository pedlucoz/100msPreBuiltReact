{
  "version": 3,
  "sources": ["../src/index.ts", "../src/utils/support.ts", "../src/utils/local-storage.ts", "../src/utils/local-storage-polyfill.ts", "../src/utils/logger.ts", "../src/sdk/models/HMSMessage.ts", "../src/sdk/models/HMSRoom.ts", "../src/sdk/models/peer/HMSPeer.ts", "../src/utils/id-factory.ts", "../src/sdk/models/peer/HMSLocalPeer.ts", "../src/sdk/models/peer/HMSRemotePeer.ts", "../src/sdk/LocalTrackManager.ts", "../src/analytics/AnalyticsEvent.ts", "../src/analytics/AnalyticsEventDomains.ts", "../src/analytics/domain-analytics.ts", "../src/utils/user-agent.ts", "../src/analytics/AnalyticsEventLevel.ts", "../src/error/HMSException.ts", "../src/analytics/AnalyticsEventFactory.ts", "../src/analytics/AnalyticsTimer.ts", "../src/error/ErrorCodes.ts", "../src/error/ErrorFactory.ts", "../src/error/utils.ts", "../src/interfaces/update-listener.ts", "../src/interfaces/simulcast-layers.ts", "../src/interfaces/track-settings.ts", "../src/interfaces/devices.ts", "../src/interfaces/playlist.ts", "../src/media/settings/HMSAudioTrackSettings.ts", "../src/media/settings/HMSVideoTrackSettings.ts", "../src/media/settings/HMSTrackSettings.ts", "../src/media/streams/HMSMediaStream.ts", "../src/utils/json.ts", "../src/media/tracks/HMSTrack.ts", "../src/media/tracks/HMSTrackType.ts", "../src/media/streams/HMSRemoteStream.ts", "../src/media/tracks/HMSAudioTrack.ts", "../src/device-manager/DeviceStorage.ts", "../src/plugins/audio/HMSAudioPlugin.ts", "../src/analytics/MediaPluginsAnalyticsFactory.ts", "../src/plugins/audio/AudioPluginsAnalytics.ts", "../src/plugins/audio/HMSAudioPluginsManager.ts", "../src/utils/track.ts", "../src/utils/media.ts", "../src/utils/queue.ts", "../src/utils/timer-utils.ts", "../src/utils/track-audio-level-monitor.ts", "../src/media/tracks/HMSLocalAudioTrack.ts", "../src/media/tracks/HMSRemoteAudioTrack.ts", "../src/media/tracks/HMSVideoTrack.ts", "../src/plugins/video/HMSVideoPlugin.ts", "../src/utils/math.ts", "../src/plugins/video/VideoPluginsAnalytics.ts", "../src/plugins/video/HMSVideoPluginsManager.ts", "../src/media/tracks/HMSLocalVideoTrack.ts", "../src/utils/constants.ts", "../src/media/tracks/HMSRemoteVideoTrack.ts", "../src/media/streams/HMSLocalStream.ts", "../src/sdk/NetworkTestManager.ts", "../src/sdk/RoleChangeManager.ts", "../src/analytics/HTTPAnalyticsTransport.ts", "../src/sdk/store/Store.ts", "../src/analytics/AnalyticsEventsService.ts", "../src/audio-sink-manager/AudioSinkManager.ts", "../src/device-manager/DeviceManager.ts", "../src/device-manager/AudioOutputManager.ts", "../src/events/EventBus.ts", "../src/events/HMSInternalEvent.ts", "../src/notification-manager/managers/ActiveSpeakerManager.ts", "../src/notification-manager/HMSNotificationMethod.ts", "../src/notification-manager/managers/BroadcastManager.ts", "../src/notification-manager/managers/ConnectionQualityManager.ts", "../src/notification-manager/managers/PeerListManager.ts", "../src/utils/date.ts", "../src/notification-manager/managers/PeerManager.ts", "../src/notification-manager/managers/PolicyChangeManager.ts", "../src/notification-manager/managers/RequestManager.ts", "../src/notification-manager/managers/RoomUpdateManager.ts", "../src/notification-manager/managers/TrackManager.ts", "../src/notification-manager/NotificationManager.ts", "../src/notification-manager/HMSNotifications.ts", "../src/playlist-manager/AudioContextManager.ts", "../src/utils/typed-event-emitter.ts", "../src/playlist-manager/PlaylistAudioManager.ts", "../src/playlist-manager/PlaylistVideoManager.ts", "../src/playlist-manager/PlaylistManager.ts", "../src/transport/models/JoinParameters.ts", "../src/transport/models/TransportFailureCategory.ts", "../src/transport/models/TransportState.ts", "../src/utils/promise.ts", "../src/transport/RetryScheduler.ts", "../src/analytics/signal-transport/LocalStoageEvents.ts", "../src/analytics/AnalyticsTransport.ts", "../src/analytics/signal-transport/SignalAnalyticsTransport.ts", "../src/connection/model.ts", "../src/utils/session-description.ts", "../src/utils/validations.ts", "../src/connection/HMSConnection.ts", "../src/connection/publish/publishConnection.ts", "../src/connection/subscribe/subscribeConnection.ts", "../src/connection/HMSDataChannel.ts", "../src/rtc-stats/utils.ts", "../src/rtc-stats/HMSWebrtcStats.ts", "../src/rtc-stats/HMSWebrtcInternals.ts", "../src/signal/init/index.ts", "../src/signal/init/models.ts", "../src/signal/jsonrpc/index.ts", "../src/signal/jsonrpc/models.ts", "../src/utils/network-info.ts", "../src/transport/index.ts", "../src/utils/jwt.ts", "../src/sdk/index.ts", "../src/utils/device-error.ts"],
  "sourcesContent": ["import adapter from 'webrtc-adapter';\nimport './utils/local-storage-polyfill';\nimport HMSLogger from './utils/logger';\n\nHMSLogger.i('adapter', `${adapter.browserDetails.browser} v${adapter.browserDetails.version}`);\n\nexport * from './sdk';\nexport * from './media/tracks';\nexport * from './utils/media';\nexport * from './utils/device-error';\nexport * from './utils/support';\nexport * from './error/HMSException';\nexport * from './interfaces';\nexport * from './rtc-stats';\nexport * from './plugins';\nexport * from './utils/logger';\n", "import { UAParser } from 'ua-parser-js';\nimport { v4 as uuid } from 'uuid';\nimport { LocalStorage } from './local-storage';\n\nexport const parsedUserAgent = new UAParser();\n\nexport const isNode =\n  typeof window === 'undefined' && !parsedUserAgent.getBrowser().name?.toLowerCase().includes('electron');\n\nexport const isBrowser = typeof window !== 'undefined';\n\nexport enum ENV {\n  PROD = 'prod',\n  QA = 'qa',\n  DEV = 'dev',\n}\n\nconst checkIsSupported = () => {\n  if (isNode) {\n    return false;\n  }\n  // @TODO: Get this from preview/init API from server\n  return true;\n};\n\nexport const isSupported = checkIsSupported();\n\nexport const isMobile = () => parsedUserAgent.getDevice().type === 'mobile';\n\nexport const getAnalyticsDeviceId = () => {\n  let id;\n  const storage = new LocalStorage<string>('hms-analytics-deviceId');\n  const storageId = storage.get();\n  if (storageId) {\n    id = storageId;\n  } else {\n    id = uuid();\n    storage.set(id);\n  }\n  return id;\n};\n\nexport const isPageHidden = () => typeof document !== 'undefined' && document.hidden;\n\nexport const isIOS = () => parsedUserAgent.getOS().name?.toLowerCase() === 'ios';\n", "import { initializeLocalstoragePolyfill } from './local-storage-polyfill';\nimport { isBrowser } from './support';\n\nexport class LocalStorage<T> {\n  private storage: Storage | null = null;\n\n  constructor(public readonly key: string) {}\n\n  /**\n   * localstorage is not available in SSR, so get it only at time of use\n   */\n  getStorage() {\n    if (isBrowser && !this.storage) {\n      initializeLocalstoragePolyfill();\n      this.storage = window.localStorage;\n    }\n    return this.storage;\n  }\n\n  get(): T | undefined {\n    const stringItem = this.getStorage()?.getItem(this.key);\n    if (!stringItem) {\n      return;\n    }\n    const item = JSON.parse(stringItem) as T;\n    return item;\n  }\n\n  set(value: T) {\n    const stringValue = JSON.stringify(value);\n    this.getStorage()?.setItem(this.key, stringValue);\n  }\n\n  clear() {\n    this.getStorage()?.removeItem(this.key);\n  }\n}\n", "import { isBrowser } from './support';\n\nclass LocalStorage {\n  valuesMap = new Map();\n  getItem(key: string) {\n    if (this.valuesMap.has(key)) {\n      return String(this.valuesMap.get(key));\n    }\n    return null;\n  }\n\n  setItem(key: string, val: string) {\n    this.valuesMap.set(key, val);\n  }\n\n  removeItem(key: string) {\n    this.valuesMap.delete(key);\n  }\n\n  clear() {\n    this.valuesMap.clear();\n  }\n\n  key(i: number) {\n    if (arguments.length === 0) {\n      throw new TypeError(\"Failed to execute 'key' on 'Storage': 1 argument required, but only 0 present.\"); // this is a TypeError implemented on Chrome, Firefox throws Not enough arguments to Storage.key.\n    }\n    const arr = Array.from(this.valuesMap.keys());\n    return arr[i];\n  }\n\n  get length() {\n    return this.valuesMap.size;\n  }\n}\n\nexport const initializeLocalstoragePolyfill = () => {\n  if (isBrowser && !localStorage) {\n    window.localStorage = new LocalStorage();\n  }\n};\n", "export enum HMSLogLevel {\n  VERBOSE,\n  DEBUG,\n  INFO,\n  WARN,\n  TIME,\n  TIMEEND,\n  ERROR,\n  NONE,\n}\n\n// @ts-ignore - window.expect is available only when in test environment\nconst isTestEnv = typeof window !== 'undefined' && typeof window.expect !== 'undefined';\n/**\n * TODO: fix this so logs show the real file and line numbers where they originated from instead of this class\n * https://stackoverflow.com/questions/13815640/a-proper-wrapper-for-console-log-with-correct-line-number\n */\nexport default class HMSLogger {\n  static level: HMSLogLevel = isTestEnv ? HMSLogLevel.NONE : HMSLogLevel.VERBOSE;\n\n  static v(tag: string, ...data: any[]) {\n    this.log(HMSLogLevel.VERBOSE, tag, ...data);\n  }\n\n  static d(tag: string, ...data: any[]) {\n    this.log(HMSLogLevel.DEBUG, tag, ...data);\n  }\n\n  static i(tag: string, ...data: any[]) {\n    this.log(HMSLogLevel.INFO, tag, ...data);\n  }\n\n  static w(tag: string, ...data: any[]) {\n    this.log(HMSLogLevel.WARN, tag, ...data);\n  }\n\n  static e(tag: string, ...data: any[]) {\n    this.log(HMSLogLevel.ERROR, tag, ...data);\n  }\n\n  static time(mark: string) {\n    this.log(HMSLogLevel.TIME, '[HMSPerformanceTiming]', mark);\n  }\n\n  static timeEnd(mark: string) {\n    this.log(HMSLogLevel.TIMEEND, '[HMSPerformanceTiming]', mark, mark);\n  }\n\n  static cleanUp() {\n    performance.clearMarks();\n    performance.clearMeasures();\n  }\n\n  // eslint-disable-next-line complexity\n  private static log(level: HMSLogLevel, tag: string, ...data: any[]) {\n    if (this.level.valueOf() > level.valueOf()) {\n      return;\n    }\n\n    switch (level) {\n      case HMSLogLevel.VERBOSE: {\n        console.log(tag, ...data);\n        break;\n      }\n      case HMSLogLevel.DEBUG: {\n        console.debug(tag, ...data);\n        break;\n      }\n      case HMSLogLevel.INFO: {\n        console.info(tag, ...data);\n        break;\n      }\n      case HMSLogLevel.WARN: {\n        console.warn(tag, ...data);\n        break;\n      }\n      case HMSLogLevel.ERROR: {\n        console.error(tag, ...data);\n        break;\n      }\n      case HMSLogLevel.TIME: {\n        performance.mark(data[0]);\n        break;\n      }\n      case HMSLogLevel.TIMEEND: {\n        const mark = data[0];\n        try {\n          const entry = performance.measure(mark, mark);\n          // @ts-ignore\n          this.log(HMSLogLevel.DEBUG, tag, mark, entry?.duration);\n          performance.clearMarks(mark);\n          performance.clearMeasures(mark);\n        } catch (error) {\n          this.log(HMSLogLevel.DEBUG, tag, mark, error);\n        }\n        break;\n      }\n    }\n  }\n}\n", "import { HMSPeer } from './peer';\nimport { HMSRole } from '../../interfaces';\nimport { HMSMessage } from '../../interfaces/message';\nimport { SendMessage } from '../../notification-manager';\nimport { ISignalParamsProvider } from '../../signal/ISignalSendParamsProvider';\n\nexport default class Message implements HMSMessage, ISignalParamsProvider<SendMessage> {\n  sender?: HMSPeer;\n  recipientPeer?: HMSPeer;\n  recipientRoles?: HMSRole[];\n  message: any;\n  time: Date;\n  type: string;\n\n  constructor({ sender, message, type = 'chat', recipientPeer, recipientRoles, time }: HMSMessage) {\n    this.sender = sender;\n    this.message = message;\n    this.type = type;\n    this.recipientPeer = recipientPeer;\n    this.recipientRoles = recipientRoles;\n    this.time = time;\n  }\n\n  toSignalParams() {\n    const roles = this.recipientRoles?.map(role => role.name);\n    const peer = this.recipientPeer?.peerId;\n    const sendParams: SendMessage = {\n      info: {\n        message: this.message,\n        type: this.type,\n      },\n    };\n    if (roles?.length) {\n      sendParams.roles = roles;\n    }\n    if (peer) {\n      sendParams.peer_id = peer;\n    }\n    return sendParams;\n  }\n\n  toString() {\n    return `{\n      sender: ${this.sender};\n      recipientPeer: ${this.recipientPeer};\n      recipientRoles: ${this.recipientRoles?.map(role => role.name)};\n      message: ${this.message};\n      time: ${this.time};\n      type: ${this.type};\n    }`;\n  }\n}\n", "import { HMSHLS, HMSRecording, HMSRoom, HMSRTMP } from '../../interfaces/room';\nimport { IStore } from '../store/IStore';\n\nexport default class Room implements HMSRoom {\n  sessionId?: string;\n  startedAt?: Date;\n  recording: HMSRecording = { server: { running: false }, browser: { running: false }, hls: { running: false } };\n  rtmp: HMSRTMP = { running: false };\n  hls: HMSHLS = { running: false, variants: [] };\n  name?: string;\n  peerCount?: number;\n\n  public get localPeer() {\n    return this.store.getLocalPeer()!;\n  }\n\n  public get peers() {\n    return this.store.getPeers();\n  }\n\n  constructor(public id: string, private store: IStore) {}\n}\n", "import { HMSPeer as IHMSPeer } from '../../../interfaces/peer';\nimport { HMSRole } from '../../../interfaces/role';\nimport { HMSAudioTrack, HMSTrack, HMSVideoTrack } from '../../../media/tracks';\n\nexport type HMSPeerInit = {\n  peerId: string;\n  name: string;\n  isLocal: boolean;\n  customerUserId?: string;\n  metadata?: string;\n  role?: HMSRole;\n  joinedAt?: Date;\n  fromRoomState?: boolean;\n};\n\nexport class HMSPeer implements IHMSPeer {\n  readonly peerId: string;\n  readonly isLocal: boolean;\n  name: string;\n  customerUserId?: string = '';\n  metadata?: string = '';\n  audioTrack?: HMSAudioTrack;\n  videoTrack?: HMSVideoTrack;\n  auxiliaryTracks: HMSTrack[] = [];\n  role?: HMSRole;\n  joinedAt?: Date;\n\n  constructor({ peerId, name, isLocal, customerUserId, metadata, role, joinedAt }: HMSPeerInit) {\n    this.name = name;\n    this.peerId = peerId;\n    this.isLocal = isLocal;\n    this.customerUserId = customerUserId;\n    this.metadata = metadata;\n    this.joinedAt = joinedAt;\n\n    if (role) {\n      this.role = role;\n    }\n  }\n\n  /**\n   * @internal\n   */\n  updateRole(newRole: HMSRole) {\n    this.role = newRole;\n  }\n  /**\n   * @internal\n   */\n  updateName(newName: string) {\n    this.name = newName;\n  }\n  /**\n   * @internal\n   */\n  updateMetadata(data: string) {\n    this.metadata = data;\n  }\n\n  toString() {\n    return `{\n      name: ${this.name};\n      role: ${this.role?.name};\n      peerId: ${this.peerId};\n      customerUserId: ${this.customerUserId};\n      ${this.audioTrack ? `audioTrack: ${this.audioTrack?.trackId};` : ''}\n      ${this.videoTrack ? `videoTrack: ${this.videoTrack?.trackId};` : ''}\n    }`;\n  }\n}\n", "import { v4 as uuidv4 } from 'uuid';\n\nexport default class HMSIdFactory {\n  static makePeerId = () => uuidv4();\n}\n", "import { HMSPeer, HMSPeerInit } from './HMSPeer';\nimport { HMSLocalPeer as IHMSLocalPeer } from '../../../interfaces/peer';\nimport { HMSRole } from '../../../interfaces/role';\nimport { HMSLocalAudioTrack, HMSLocalTrack, HMSLocalVideoTrack } from '../../../media/tracks';\nimport HMSIdFactory from '../../../utils/id-factory';\n\ntype HMSLocalPeerInit = Omit<HMSPeerInit, 'isLocal' | 'peerId'> & { asRole?: HMSRole };\n\nexport class HMSLocalPeer extends HMSPeer implements IHMSLocalPeer {\n  isLocal = true;\n  declare audioTrack?: HMSLocalAudioTrack;\n  declare videoTrack?: HMSLocalVideoTrack;\n  auxiliaryTracks: HMSLocalTrack[] = [];\n  asRole?: HMSRole;\n\n  constructor(peerData: HMSLocalPeerInit) {\n    super({ ...peerData, peerId: HMSIdFactory.makePeerId(), isLocal: true });\n    this.asRole = peerData.asRole;\n  }\n\n  isInPreview() {\n    return !!this.asRole;\n  }\n\n  toString(): string {\n    return `{\n      name: ${this.name};\n      role: ${this.role?.name};\n      peerId: ${this.peerId};\n      customerUserId: ${this.customerUserId};\n      ${this.asRole ? `asRole: ${this.asRole.name};` : ''}\n      ${this.audioTrack ? `audioTrack: ${this.audioTrack?.trackId};` : ''}\n      ${this.videoTrack ? `videoTrack: ${this.videoTrack?.trackId};` : ''}\n    }`;\n  }\n}\n", "import { HMSPeer, HMSPeerInit } from './HMSPeer';\nimport { HMSRemotePeer as IHMSRemotePeer } from '../../../interfaces/peer';\nimport { HMSRemoteAudioTrack, HMSRemoteTrack, HMSRemoteVideoTrack } from '../../../media/tracks';\n\ntype HMSRemotePeerInit = Omit<HMSPeerInit, 'isLocal'>;\n\nexport class HMSRemotePeer extends HMSPeer implements IHMSRemotePeer {\n  isLocal = false;\n  declare audioTrack?: HMSRemoteAudioTrack;\n  declare videoTrack?: HMSRemoteVideoTrack;\n  auxiliaryTracks: HMSRemoteTrack[] = [];\n  fromRoomState = false;\n\n  constructor(peerData: HMSRemotePeerInit) {\n    super({ ...peerData, isLocal: false });\n    this.fromRoomState = !!peerData.fromRoomState;\n  }\n}\n", "import { v4 as uuid } from 'uuid';\nimport { IStore } from './store';\nimport AnalyticsEventFactory from '../analytics/AnalyticsEventFactory';\nimport { AnalyticsTimer, TimedEvent } from '../analytics/AnalyticsTimer';\nimport { DeviceManager } from '../device-manager';\nimport { ErrorCodes } from '../error/ErrorCodes';\nimport { ErrorFactory, HMSAction } from '../error/ErrorFactory';\nimport { HMSException } from '../error/HMSException';\nimport { BuildGetMediaError, HMSGetMediaActions } from '../error/utils';\nimport { EventBus } from '../events/EventBus';\nimport { HMSAudioCodec, HMSScreenShareConfig, HMSVideoCodec, ScreenCaptureHandleConfig } from '../interfaces';\nimport InitialSettings from '../interfaces/settings';\nimport {\n  HMSAudioTrackSettings,\n  HMSAudioTrackSettingsBuilder,\n  HMSTrackSettings,\n  HMSTrackSettingsBuilder,\n  HMSVideoTrackSettings,\n  HMSVideoTrackSettingsBuilder,\n} from '../media/settings';\nimport HMSLocalStream from '../media/streams/HMSLocalStream';\nimport { HMSLocalAudioTrack, HMSLocalTrack, HMSLocalVideoTrack, HMSTrackType } from '../media/tracks';\nimport { IFetchAVTrackOptions } from '../transport/ITransport';\nimport ITransportObserver from '../transport/ITransportObserver';\nimport HMSLogger from '../utils/logger';\nimport { HMSAudioContextHandler } from '../utils/media';\n\nconst defaultSettings = {\n  isAudioMuted: false,\n  isVideoMuted: false,\n  audioInputDeviceId: 'default',\n  audioOutputDeviceId: 'default',\n  videoDeviceId: 'default',\n};\n\nlet blankCanvas: any;\n\nexport class LocalTrackManager {\n  readonly TAG: string = '[LocalTrackManager]';\n  private captureHandleIdentifier?: string;\n\n  constructor(\n    private store: IStore,\n    private observer: ITransportObserver,\n    private deviceManager: DeviceManager,\n    private eventBus: EventBus,\n    private analyticsTimer: AnalyticsTimer,\n  ) {\n    this.setScreenCaptureHandleConfig();\n  }\n\n  // eslint-disable-next-line complexity\n  async getTracksToPublish(initialSettings: InitialSettings): Promise<HMSLocalTrack[]> {\n    const trackSettings = this.getAVTrackSettings(initialSettings);\n    if (!trackSettings) {\n      return [];\n    }\n    const canPublishAudio = !!trackSettings.audio;\n    const canPublishVideo = !!trackSettings.video;\n    let tracksToPublish: Array<HMSLocalTrack> = [];\n    const { videoTrack, audioTrack } = await this.updateCurrentLocalTrackSettings(trackSettings);\n    const localStream = (videoTrack?.stream || audioTrack?.stream) as HMSLocalStream | undefined;\n    // The track gets added to the store only after it is published.\n    const isVideoTrackPublished = Boolean(videoTrack && this.store.getTrackById(videoTrack.trackId));\n    const isAudioTrackPublished = Boolean(audioTrack && this.store.getTrackById(audioTrack.trackId));\n\n    if (isVideoTrackPublished && isAudioTrackPublished) {\n      // there is nothing to publish\n      return [];\n    }\n\n    const fetchTrackOptions: IFetchAVTrackOptions = {\n      audio: canPublishAudio && !audioTrack && (initialSettings.isAudioMuted ? 'empty' : true),\n      video: canPublishVideo && !videoTrack && (initialSettings.isVideoMuted ? 'empty' : true),\n    };\n\n    this.analyticsTimer.start(TimedEvent.LOCAL_AUDIO_TRACK);\n    this.analyticsTimer.start(TimedEvent.LOCAL_VIDEO_TRACK);\n    try {\n      HMSLogger.d(this.TAG, 'Init Local Tracks', { fetchTrackOptions });\n      tracksToPublish = await this.getLocalTracks(fetchTrackOptions, trackSettings, localStream);\n    } catch (error) {\n      tracksToPublish = await this.retryGetLocalTracks(\n        error as HMSException,\n        trackSettings,\n        fetchTrackOptions,\n        localStream,\n      );\n    }\n    this.analyticsTimer.end(TimedEvent.LOCAL_AUDIO_TRACK);\n    this.analyticsTimer.end(TimedEvent.LOCAL_VIDEO_TRACK);\n\n    if (videoTrack && canPublishVideo && !isVideoTrackPublished) {\n      tracksToPublish.push(videoTrack);\n    }\n    if (audioTrack && canPublishAudio && !isAudioTrackPublished) {\n      tracksToPublish.push(audioTrack);\n    }\n    return tracksToPublish;\n  }\n\n  /**\n   * @throws {HMSException}\n   */\n  async getLocalTracks(\n    fetchTrackOptions: IFetchAVTrackOptions = { audio: true, video: true },\n    settings: HMSTrackSettings,\n    localStream?: HMSLocalStream,\n  ): Promise<Array<HMSLocalTrack>> {\n    try {\n      const nativeTracks = await this.getNativeLocalTracks(fetchTrackOptions, settings);\n      return this.createHMSLocalTracks(nativeTracks, settings, localStream);\n    } catch (error) {\n      // TOOD: On OverConstrained error, retry with dropping all constraints.\n      // Just retry getusermedia again - it sometimes work when AbortError or NotFoundError is thrown on a few devices\n      this.eventBus.analytics.publish(\n        AnalyticsEventFactory.publish({\n          devices: this.deviceManager.getDevices(),\n          error: error as Error,\n          settings,\n        }),\n      );\n      throw error;\n    }\n  }\n\n  /**\n   * @throws {HMSException}\n   */\n  private async getNativeLocalTracks(\n    fetchTrackOptions: IFetchAVTrackOptions = { audio: false, video: false },\n    settings: HMSTrackSettings,\n  ) {\n    const trackSettings = new HMSTrackSettings(\n      fetchTrackOptions.video === true ? settings.video : null,\n      fetchTrackOptions.audio === true ? settings.audio : null,\n      settings.simulcast,\n    );\n    const nativeTracks: MediaStreamTrack[] = [];\n\n    if (trackSettings.audio || trackSettings.video) {\n      nativeTracks.push(...(await this.getAVTracks(trackSettings)));\n    }\n    nativeTracks.push(...this.getEmptyTracks(fetchTrackOptions));\n    return nativeTracks;\n  }\n\n  async getLocalScreen(partialConfig?: HMSScreenShareConfig) {\n    const config = await this.getOrDefaultScreenshareConfig(partialConfig);\n    const screenSettings = this.getScreenshareSettings(config.videoOnly);\n    const constraints = {\n      video: { ...screenSettings?.video.toConstraints(true), displaySurface: config.displaySurface },\n      preferCurrentTab: config.preferCurrentTab,\n      selfBrowserSurface: config.selfBrowserSurface,\n      surfaceSwitching: config.surfaceSwitching,\n      systemAudio: config.systemAudio,\n    } as MediaStreamConstraints;\n    if (screenSettings?.audio) {\n      const audioConstraints: MediaTrackConstraints = screenSettings?.audio?.toConstraints();\n      // remove advanced constraints as it not supported for screenshare audio\n      delete audioConstraints.advanced;\n      constraints.audio = {\n        ...audioConstraints,\n        autoGainControl: false,\n        noiseSuppression: false,\n        // @ts-ignore\n        googAutoGainControl: false,\n        echoCancellation: false,\n      };\n    }\n    let stream;\n    try {\n      HMSLogger.d('retrieving screenshare with ', { config }, { constraints });\n      // @ts-ignore [https://github.com/microsoft/TypeScript/issues/33232]\n      stream = (await navigator.mediaDevices.getDisplayMedia(constraints)) as MediaStream;\n    } catch (err) {\n      HMSLogger.w(this.TAG, 'error in getting screenshare - ', err);\n      const error = BuildGetMediaError(err as Error, HMSGetMediaActions.SCREEN);\n      this.eventBus.analytics.publish(\n        AnalyticsEventFactory.publish({\n          error: error as Error,\n          devices: this.deviceManager.getDevices(),\n          settings: new HMSTrackSettings(screenSettings?.video, screenSettings?.audio, false),\n        }),\n      );\n      throw error;\n    }\n\n    const tracks: Array<HMSLocalTrack> = [];\n    const local = new HMSLocalStream(stream);\n    const nativeVideoTrack = stream.getVideoTracks()[0];\n    const videoTrack = new HMSLocalVideoTrack(local, nativeVideoTrack, 'screen', this.eventBus, screenSettings?.video);\n    videoTrack.setSimulcastDefinitons(this.store.getSimulcastDefinitionsForPeer(this.store.getLocalPeer()!, 'screen'));\n\n    try {\n      const isCurrentTabShared = this.validateCurrentTabCapture(videoTrack, config.forceCurrentTab);\n      videoTrack.isCurrentTab = isCurrentTabShared;\n      await videoTrack.cropTo(config.cropTarget);\n    } catch (err) {\n      stream.getTracks().forEach(track => track.stop());\n      throw err;\n    }\n\n    tracks.push(videoTrack);\n    const nativeAudioTrack = stream.getAudioTracks()[0];\n    if (nativeAudioTrack) {\n      const audioTrack = new HMSLocalAudioTrack(\n        local,\n        nativeAudioTrack,\n        'screen',\n        this.eventBus,\n        screenSettings?.audio,\n      );\n      tracks.push(audioTrack);\n    }\n\n    HMSLogger.v(this.TAG, 'getLocalScreen', tracks);\n    return tracks;\n  }\n\n  setScreenCaptureHandleConfig(config?: Partial<ScreenCaptureHandleConfig>) {\n    // @ts-ignore\n    if (!navigator.mediaDevices?.setCaptureHandleConfig || this.isInIframe()) {\n      // setCaptureHandleConfig can't be called from within an iframe\n      return;\n    }\n    config = config || {};\n    Object.assign(config, { handle: uuid(), exposeOrigin: false, permittedOrigins: [window.location.origin] });\n    HMSLogger.d('setting capture handle - ', config.handle);\n    // @ts-ignore\n    navigator.mediaDevices.setCaptureHandleConfig(config);\n    this.captureHandleIdentifier = config.handle;\n  }\n\n  validateCurrentTabCapture(track: HMSLocalVideoTrack, forceCurrentTab: boolean): boolean {\n    const trackHandle = track.getCaptureHandle();\n    const isCurrentTabShared = !!(this.captureHandleIdentifier && trackHandle?.handle === this.captureHandleIdentifier);\n    if (forceCurrentTab && !isCurrentTabShared) {\n      HMSLogger.e(this.TAG, 'current tab was not shared with forceCurrentTab as true');\n      throw ErrorFactory.TracksErrors.CurrentTabNotShared();\n    }\n    return isCurrentTabShared;\n  }\n\n  async requestPermissions() {\n    try {\n      const stream = await navigator.mediaDevices.getUserMedia({\n        audio: true,\n        video: true,\n      });\n      // Stop stream\n      stream.getTracks().forEach(track => track.stop());\n    } catch (error) {\n      HMSLogger.e(this.TAG, error);\n    }\n  }\n\n  static getEmptyVideoTrack(prevTrack?: MediaStreamTrack): MediaStreamTrack {\n    const width = prevTrack?.getSettings()?.width || 320;\n    const height = prevTrack?.getSettings()?.height || 240;\n    const frameRate = 10; // fps TODO: experiment, see if this can be reduced\n    if (!blankCanvas) {\n      blankCanvas = Object.assign(document.createElement('canvas'), { width, height });\n      blankCanvas.getContext('2d')?.fillRect(0, 0, width, height);\n    }\n    const stream = blankCanvas.captureStream(frameRate);\n    const emptyTrack = stream.getVideoTracks()[0];\n    const intervalID = setInterval(() => {\n      if (emptyTrack.readyState === 'ended') {\n        clearInterval(intervalID);\n        return;\n      }\n      const ctx = blankCanvas.getContext('2d');\n      if (ctx) {\n        const pixel = ctx.getImageData(0, 0, 1, 1).data;\n        const red = pixel[0] === 0 ? 1 : 0; // toggle red in pixel\n        ctx.fillStyle = `rgb(${red}, 0, 0)`;\n        ctx.fillRect(0, 0, 1, 1);\n      }\n    }, 1000 / frameRate);\n    emptyTrack.onended = () => {\n      clearInterval(intervalID);\n    };\n    emptyTrack.enabled = false;\n    return emptyTrack;\n  }\n\n  static getEmptyAudioTrack(): MediaStreamTrack {\n    const ctx = HMSAudioContextHandler.getAudioContext();\n    const oscillator = ctx.createOscillator();\n    const dst = ctx.createMediaStreamDestination();\n    oscillator.connect(dst);\n    oscillator.start();\n    const emptyTrack = dst.stream.getAudioTracks()[0];\n    emptyTrack.enabled = false;\n    return emptyTrack;\n  }\n\n  /**\n   * @throws {HMSException}\n   */\n  private async getAVTracks(settings: HMSTrackSettings): Promise<Array<MediaStreamTrack>> {\n    try {\n      const stream = await navigator.mediaDevices.getUserMedia({\n        audio: settings.audio ? settings.audio.toConstraints() : false,\n        video: settings.video ? settings.video.toConstraints() : false,\n      });\n\n      return stream.getVideoTracks().concat(stream.getAudioTracks());\n    } catch (error) {\n      await this.deviceManager.init();\n      const videoError = !!(!this.deviceManager.hasWebcamPermission && settings.video);\n      const audioError = !!(!this.deviceManager.hasMicrophonePermission && settings.audio);\n      /**\n       * TODO: Only permission error throws correct device info in error(audio or video or both),\n       * Right now for other errors such as overconstrained error we are unable to get whether audio/video failure.\n       * Fix this by checking the native error message.\n       */\n      const errorType = this.getErrorType(videoError, audioError);\n      throw BuildGetMediaError(error as Error, errorType);\n    }\n  }\n\n  private getAVTrackSettings(initialSettings: InitialSettings): HMSTrackSettings | null {\n    const audioSettings = this.getAudioSettings(initialSettings);\n    const videoSettings = this.getVideoSettings(initialSettings);\n    if (!audioSettings && !videoSettings) {\n      return null;\n    }\n    return new HMSTrackSettingsBuilder().video(videoSettings).audio(audioSettings).build();\n  }\n\n  private isInIframe() {\n    try {\n      return window.self !== window.top;\n    } catch (e) {\n      return true;\n    }\n  }\n\n  // eslint-disable-next-line complexity\n  private async retryGetLocalTracks(\n    error: HMSException,\n    trackSettings: HMSTrackSettings,\n    fetchTrackOptions: IFetchAVTrackOptions,\n    localStream?: HMSLocalStream,\n  ): Promise<Array<HMSLocalTrack>> {\n    if (error instanceof HMSException && error.action === HMSAction.TRACK) {\n      this.observer.onFailure(error);\n\n      const overConstrainedFailure = error.code === ErrorCodes.TracksErrors.OVER_CONSTRAINED;\n      const audioFailure = error.message.includes('audio');\n      const videoFailure = error.message.includes('video');\n      if (overConstrainedFailure) {\n        // TODO: Use this once TODO@L#250 is completed\n        // const newTrackSettings = new HMSTrackSettingsBuilder()\n        //   .video(videoFailure ? new HMSVideoTrackSettings() : trackSettings.video)\n        //   .audio(audioFailure ? new HMSAudioTrackSettings() : trackSettings.audio)\n        //   .build();\n        const newTrackSettings = new HMSTrackSettingsBuilder()\n          .video(new HMSVideoTrackSettings())\n          .audio(new HMSAudioTrackSettings())\n          .build();\n\n        HMSLogger.w(this.TAG, 'Fetch AV Tracks failed with overconstrained error', { fetchTrackOptions }, { error });\n\n        try {\n          // Try get local tracks with no constraints\n          return await this.getLocalTracks(fetchTrackOptions, newTrackSettings, localStream);\n        } catch (error) {\n          /**\n           * This error shouldn't be overconstrained error(as we've dropped all constraints).\n           * If it's an overconstrained error, change error code to avoid recursive loop\n           * Try get local tracks for empty tracks\n           */\n          const nativeError: Error | undefined = error instanceof HMSException ? error.nativeError : (error as Error);\n          let ex = error;\n          if (nativeError?.name === 'OverconstrainedError') {\n            const newError = ErrorFactory.TracksErrors.GenericTrack(\n              HMSAction.TRACK,\n              'Overconstrained error after dropping all constraints',\n            );\n            newError.addNativeError(nativeError);\n            ex = newError;\n          }\n\n          return await this.retryGetLocalTracks(ex as HMSException, trackSettings, fetchTrackOptions, localStream);\n        }\n      }\n\n      fetchTrackOptions.audio = audioFailure ? 'empty' : fetchTrackOptions.audio;\n      fetchTrackOptions.video = videoFailure ? 'empty' : fetchTrackOptions.video;\n      HMSLogger.w(this.TAG, 'Fetch AV Tracks failed', { fetchTrackOptions }, error);\n      try {\n        return await this.getLocalTracks(fetchTrackOptions, trackSettings, localStream);\n      } catch (error) {\n        HMSLogger.w(this.TAG, 'Fetch empty tacks failed', error);\n        fetchTrackOptions.audio = fetchTrackOptions.audio && 'empty';\n        fetchTrackOptions.video = fetchTrackOptions.video && 'empty';\n        this.observer.onFailure(error as HMSException);\n        return await this.getLocalTracks(fetchTrackOptions, trackSettings, localStream);\n      }\n    } else {\n      HMSLogger.w(this.TAG, 'Fetch AV Tracks failed - unknown exception', error);\n      this.observer.onFailure(error);\n      return [];\n    }\n  }\n\n  private getErrorType(videoError: boolean, audioError: boolean): HMSGetMediaActions {\n    if (videoError && audioError) {\n      return HMSGetMediaActions.AV;\n    }\n    if (videoError) {\n      return HMSGetMediaActions.VIDEO;\n    }\n    if (audioError) {\n      return HMSGetMediaActions.AUDIO;\n    }\n    return HMSGetMediaActions.UNKNOWN;\n  }\n\n  private getEmptyTracks(fetchTrackOptions: IFetchAVTrackOptions) {\n    const nativeTracks: MediaStreamTrack[] = [];\n    if (fetchTrackOptions.audio === 'empty') {\n      nativeTracks.push(LocalTrackManager.getEmptyAudioTrack());\n    }\n\n    if (fetchTrackOptions.video === 'empty') {\n      nativeTracks.push(LocalTrackManager.getEmptyVideoTrack());\n    }\n    return nativeTracks;\n  }\n\n  private async updateCurrentLocalTrackSettings(trackSettings: HMSTrackSettings | null) {\n    const localTracks = this.store.getLocalPeerTracks();\n    const videoTrack = localTracks.find(t => t.type === HMSTrackType.VIDEO && t.source === 'regular') as\n      | HMSLocalVideoTrack\n      | undefined;\n    const audioTrack = localTracks.find(t => t.type === HMSTrackType.AUDIO && t.source === 'regular') as\n      | HMSLocalAudioTrack\n      | undefined;\n\n    if (trackSettings?.video) {\n      await videoTrack?.setSettings(trackSettings.video);\n    }\n\n    if (trackSettings?.audio) {\n      await audioTrack?.setSettings(trackSettings.audio);\n    }\n\n    return { videoTrack, audioTrack };\n  }\n\n  private getAudioSettings(initialSettings: InitialSettings) {\n    const publishParams = this.store.getPublishParams();\n    if (!publishParams || !publishParams.allowed?.includes('audio')) {\n      return null;\n    }\n    const localPeer = this.store.getLocalPeer();\n    const audioTrack = localPeer?.audioTrack;\n    // Get device from the tracks already added in preview\n    const audioDeviceId = audioTrack?.settings.deviceId || initialSettings.audioInputDeviceId;\n\n    return new HMSAudioTrackSettingsBuilder()\n      .codec(publishParams.audio.codec as HMSAudioCodec)\n      .maxBitrate(publishParams.audio.bitRate)\n      .deviceId(audioDeviceId || defaultSettings.audioInputDeviceId)\n      .build();\n  }\n\n  private getVideoSettings(initialSettings: InitialSettings) {\n    const publishParams = this.store.getPublishParams();\n    if (!publishParams || !publishParams.allowed?.includes('video')) {\n      return null;\n    }\n    const localPeer = this.store.getLocalPeer();\n    const videoTrack = localPeer?.videoTrack;\n    // Get device from the tracks already added in preview\n    const videoDeviceId = videoTrack?.settings.deviceId || initialSettings.videoDeviceId;\n    const video = publishParams.video;\n    return new HMSVideoTrackSettingsBuilder()\n      .codec(video.codec as HMSVideoCodec)\n      .maxBitrate(video.bitRate)\n      .maxFramerate(video.frameRate)\n      .setWidth(video.width) // take simulcast width if available\n      .setHeight(video.height) // take simulcast width if available\n      .deviceId(videoDeviceId || defaultSettings.videoDeviceId)\n      .build();\n  }\n\n  private getScreenshareSettings(isVideoOnly = false) {\n    const publishParams = this.store.getPublishParams();\n    if (!publishParams || !publishParams.allowed?.includes('screen')) {\n      return null;\n    }\n    const screen = publishParams.screen;\n    return {\n      video: new HMSVideoTrackSettingsBuilder()\n        // Don't cap maxBitrate for screenshare.\n        // If publish params doesn't have bitRate value - don't set maxBitrate.\n        .maxBitrate(screen.bitRate, false)\n        .codec(screen.codec as HMSVideoCodec)\n        .maxFramerate(screen.frameRate)\n        .setWidth(screen.width)\n        .setHeight(screen.height)\n        .build(),\n      audio: isVideoOnly ? undefined : new HMSAudioTrackSettingsBuilder().build(),\n    };\n  }\n\n  // eslint-disable-next-line complexity\n  private async getOrDefaultScreenshareConfig(partialConfig?: Partial<HMSScreenShareConfig>) {\n    type RequiredConfig = HMSScreenShareConfig &\n      Required<Omit<HMSScreenShareConfig, 'cropTarget' | 'cropElement' | 'displaySurface'>>;\n    const config: RequiredConfig = Object.assign(\n      {\n        videoOnly: false,\n        audioOnly: false,\n        forceCurrentTab: false,\n        preferCurrentTab: false,\n        selfBrowserSurface: 'exclude', // don't give self tab in options\n        surfaceSwitching: 'include', // give option to switch tabs while sharing\n        systemAudio: 'exclude', // system audio share leads to echo in windows\n        displaySurface: 'monitor',\n      },\n      partialConfig || {},\n    );\n    if (config.forceCurrentTab) {\n      config.videoOnly = true; // there will be echo otherwise\n      config.preferCurrentTab = true;\n      config.selfBrowserSurface = 'include';\n      config.surfaceSwitching = 'exclude';\n    }\n    if (config.preferCurrentTab) {\n      config.selfBrowserSurface = 'include';\n      config.displaySurface = undefined; // so the default selected is the current tab\n    }\n    // @ts-ignore\n    if (config.cropElement && window.CropTarget?.fromElement) {\n      // @ts-ignore\n      config.cropTarget = await window.CropTarget.fromElement(config.cropElement);\n    }\n    return config;\n  }\n\n  private createHMSLocalTracks(\n    nativeTracks: MediaStreamTrack[],\n    settings: HMSTrackSettings,\n    localStream?: HMSLocalStream,\n  ) {\n    const nativeVideoTrack = nativeTracks.find(track => track.kind === 'video');\n    const nativeAudioTrack = nativeTracks.find(track => track.kind === 'audio');\n    if (localStream) {\n      nativeTracks.forEach(track => localStream?.nativeStream.addTrack(track));\n    } else {\n      localStream = new HMSLocalStream(new MediaStream(nativeTracks));\n    }\n\n    const tracks: Array<HMSLocalTrack> = [];\n    if (nativeAudioTrack && settings?.audio) {\n      const audioTrack = new HMSLocalAudioTrack(\n        localStream,\n        nativeAudioTrack,\n        'regular',\n        this.eventBus,\n        settings.audio,\n      );\n      tracks.push(audioTrack);\n    }\n\n    if (nativeVideoTrack && settings?.video) {\n      const videoTrack = new HMSLocalVideoTrack(\n        localStream,\n        nativeVideoTrack,\n        'regular',\n        this.eventBus,\n        settings.video,\n      );\n      videoTrack.setSimulcastDefinitons(\n        this.store.getSimulcastDefinitionsForPeer(this.store.getLocalPeer()!, 'regular'),\n      );\n      tracks.push(videoTrack);\n    }\n    return tracks;\n  }\n}\n", "import { v4 as uuid } from 'uuid';\nimport { AnalyticsEventLevel } from './AnalyticsEventLevel';\nimport { domainCategory } from './domain-analytics';\nimport { ISignalParamsProvider } from '../signal/ISignalSendParamsProvider';\nimport { getAnalyticsDeviceId } from '../utils/support';\nimport { createUserAgent } from '../utils/user-agent';\n\ninterface AnalyticsEventInit {\n  name: string;\n  level: AnalyticsEventLevel;\n  includesPII?: boolean;\n  properties?: Record<string, any>;\n  timestamp?: number;\n}\n\ninterface SignalEventParams {\n  name: string;\n  info: any;\n  timestamp: number;\n}\n\nexport default class AnalyticsEvent implements ISignalParamsProvider<SignalEventParams> {\n  name: string;\n  level: AnalyticsEventLevel;\n  includesPII: boolean;\n  properties: Record<string, any>;\n  metadata: {\n    token?: string;\n    peer: {\n      peer_id?: string;\n      session_id?: string;\n      room_id?: string;\n      role?: string;\n      room_name?: string;\n      joined_at?: number;\n      template_id?: string;\n      session_started_at?: number;\n      user_name?: string;\n      user_data?: string;\n    };\n    userAgent: string;\n  } = {\n    peer: {},\n    userAgent: createUserAgent(),\n  };\n  timestamp: number;\n  event_id: string;\n  device_id: string;\n\n  constructor({ name, level, properties, includesPII, timestamp }: AnalyticsEventInit) {\n    this.name = name;\n    this.level = level;\n    this.includesPII = includesPII || false;\n    this.properties = properties || {};\n    this.timestamp = timestamp || new Date().getTime(); // Timestamp of generating the event\n    this.event_id = uuid();\n    this.device_id = getAnalyticsDeviceId();\n  }\n\n  toSignalParams() {\n    return {\n      name: this.name,\n      info: { ...this.properties, timestamp: this.timestamp, domain: domainCategory },\n      timestamp: new Date().getTime(), // Timestamp of sending the event\n    };\n  }\n}\n", "export enum DomainCategory {\n  CUSTOM = 'CUSTOM',\n  LOCAL = 'LOCAL',\n  HMS = 'HMS',\n}\n", "import { DomainCategory } from './AnalyticsEventDomains';\nimport { isBrowser } from '../utils/support';\n\nfunction getDomainCategory() {\n  // this function gives us the domain category(sutom, hms , local) of the base url.\n  // below if statement checks if it's running in a browser ; or if we can use 'window' safely\n\n  if (isBrowser && window) {\n    const baseurl = window.location.hostname;\n\n    if (baseurl === 'localhost' || baseurl === '127.0.0.1') {\n      return DomainCategory.LOCAL;\n    }\n\n    if (baseurl.includes('app.100ms.live')) {\n      return DomainCategory.HMS;\n    } else {\n      return DomainCategory.CUSTOM;\n    }\n  }\n\n  return DomainCategory.CUSTOM;\n}\n\nexport const domainCategory = getDomainCategory();\n", "import { ENV, isNode, parsedUserAgent } from './support';\nimport { DomainCategory } from '../analytics/AnalyticsEventDomains';\nimport { domainCategory } from '../analytics/domain-analytics';\nimport { HMSFrameworkInfo } from '../interfaces';\n\nconst sdk_version = require('../../package.json').version;\n\ntype UserAgent = {\n  os: string;\n  os_version: string;\n  sdk: 'web';\n  sdk_version: string;\n  env: 'debug' | 'prod';\n  domain: DomainCategory;\n  device_model?: string;\n  framework?: HMSFrameworkInfo['type'] | 'node';\n  framework_version?: HMSFrameworkInfo['version'];\n  framework_sdk_version?: HMSFrameworkInfo['sdkVersion'];\n};\n\nexport function createUserAgent(sdkEnv: ENV = ENV.PROD, frameworkInfo?: HMSFrameworkInfo): string {\n  const sdk = 'web';\n  const env = domainCategory !== DomainCategory.LOCAL && sdkEnv === ENV.PROD ? 'prod' : 'debug';\n\n  if (isNode) {\n    return convertObjectToString({\n      os: 'web_nodejs',\n      os_version: process.version,\n      sdk,\n      sdk_version,\n      env,\n      domain: domainCategory,\n      framework: 'node',\n      framework_version: process.version,\n      framework_sdk_version: frameworkInfo?.sdkVersion,\n    });\n  }\n\n  const parsedOs = parsedUserAgent.getOS();\n  const parsedDevice = parsedUserAgent.getDevice();\n  const parsedBrowser = parsedUserAgent.getBrowser();\n\n  const os = replaceSpaces(`web_${parsedOs.name}`);\n  const os_version = parsedOs.version || '';\n\n  const browser = replaceSpaces(`${parsedBrowser.name}_${parsedBrowser.version}`);\n  let device_model = browser;\n  if (parsedDevice.type) {\n    const deviceVendor = replaceSpaces(`${parsedDevice.vendor}_${parsedDevice.type}`);\n    device_model = `${deviceVendor}/${browser}`;\n  }\n\n  return convertObjectToString({\n    os,\n    os_version,\n    sdk,\n    sdk_version,\n    device_model,\n    env,\n    domain: domainCategory,\n    framework: frameworkInfo?.type,\n    framework_version: frameworkInfo?.version,\n    framework_sdk_version: frameworkInfo?.sdkVersion,\n  });\n}\n\nfunction replaceSpaces(s: string) {\n  return s.replace(/ /g, '_');\n}\n\nconst convertObjectToString = (object: UserAgent, delimiter = ',') =>\n  Object.keys(object)\n    .filter(key => !!object[key as keyof UserAgent])\n    .map(key => `${key}:${object[key as keyof UserAgent]}`)\n    .join(delimiter);\n", "export enum HMSAnalyticsLevel {\n  VERBOSE,\n  INFO,\n  ERROR,\n  OFF,\n}\n\nexport enum AnalyticsEventLevel {\n  VERBOSE,\n  INFO,\n  ERROR,\n  OFF,\n}\n", "import { HMSAction } from './ErrorFactory';\nimport { IAnalyticsPropertiesProvider } from '../analytics/IAnalyticsPropertiesProvider';\nimport { HMSSignalMethod } from '../signal/jsonrpc/models';\n\nexport class HMSException extends Error implements IAnalyticsPropertiesProvider {\n  action: string;\n  nativeError?: Error;\n\n  constructor(\n    public readonly code: number,\n    public name: string,\n    action: HMSAction | HMSSignalMethod,\n    public message: string,\n    public description: string,\n    public isTerminal: boolean = false,\n  ) {\n    super(message);\n\n    // Ref: https://github.com/Microsoft/TypeScript/wiki/Breaking-Changes#extending-built-ins-like-error-array-and-map-may-no-longer-work\n    Object.setPrototypeOf(this, HMSException.prototype);\n    this.action = action.toString();\n  }\n\n  toAnalyticsProperties() {\n    return {\n      error_name: this.name,\n      error_code: this.code,\n      error_message: this.message,\n      error_description: this.description,\n      action: this.action,\n      is_terminal: this.isTerminal,\n    };\n  }\n\n  addNativeError(error: Error) {\n    this.nativeError = error;\n  }\n\n  toString() {\n    return `{\n      code: ${this.code};\n      name: ${this.name};\n      action: ${this.action};\n      message: ${this.message};\n      description: ${this.description};\n      isTerminal: ${this.isTerminal};\n      nativeError: ${this.nativeError?.message};\n    }`;\n  }\n}\n", "import { AdditionalAnalyticsProperties } from './AdditionalAnalyticsProperties';\nimport AnalyticsEvent from './AnalyticsEvent';\nimport { AnalyticsEventLevel } from './AnalyticsEventLevel';\nimport { IAnalyticsPropertiesProvider } from './IAnalyticsPropertiesProvider';\nimport { SelectedDevices } from '../device-manager';\nimport { HMSException } from '../error/HMSException';\nimport { DeviceMap } from '../interfaces';\nimport { HMSTrackSettings } from '../media/settings/HMSTrackSettings';\nimport { HMSRemoteVideoTrack } from '../media/tracks';\n\nexport default class AnalyticsEventFactory {\n  private static KEY_REQUESTED_AT = 'requested_at';\n  private static KEY_RESPONDED_AT = 'responded_at';\n\n  static connect(\n    error?: Error,\n    additionalProperties?: AdditionalAnalyticsProperties,\n    requestedAt: Date = new Date(),\n    respondedAt: Date = new Date(),\n    endpoint?: string,\n  ) {\n    const name = this.eventNameFor('connect', error === undefined);\n    const level = error ? AnalyticsEventLevel.ERROR : AnalyticsEventLevel.INFO;\n\n    const properties = this.getPropertiesWithError(\n      {\n        ...additionalProperties,\n        [this.KEY_REQUESTED_AT]: requestedAt?.getTime(),\n        [this.KEY_RESPONDED_AT]: respondedAt?.getTime(),\n        endpoint,\n      },\n      error,\n    );\n\n    return new AnalyticsEvent({ name, level, properties });\n  }\n\n  static disconnect(error?: Error, additionalProperties?: AdditionalAnalyticsProperties) {\n    const name = 'disconnected';\n    const level = error ? AnalyticsEventLevel.ERROR : AnalyticsEventLevel.INFO;\n    const properties = this.getPropertiesWithError(additionalProperties, error);\n\n    return new AnalyticsEvent({ name, level, properties });\n  }\n\n  static preview({\n    error,\n    ...props\n  }: {\n    error?: Error;\n    time?: number;\n    init_response_time?: number;\n    ws_connect_time?: number;\n    on_policy_change_time?: number;\n    local_audio_track_time?: number;\n    local_video_track_time?: number;\n  }) {\n    const name = this.eventNameFor('preview', error === undefined);\n    const level = error ? AnalyticsEventLevel.ERROR : AnalyticsEventLevel.INFO;\n    const properties = this.getPropertiesWithError(props, error);\n\n    return new AnalyticsEvent({ name, level, properties });\n  }\n\n  static join({\n    error,\n    ...props\n  }: {\n    error?: Error;\n    is_preview_called?: boolean;\n    start?: Date;\n    end?: Date;\n    time?: number;\n    init_response_time?: number;\n    ws_connect_time?: number;\n    on_policy_change_time?: number;\n    local_audio_track_time?: number;\n    local_video_track_time?: number;\n    retries_join?: number;\n  }) {\n    const name = this.eventNameFor('join', error === undefined);\n    const level = error ? AnalyticsEventLevel.ERROR : AnalyticsEventLevel.INFO;\n\n    const properties = this.getPropertiesWithError({ ...props, is_preview_called: !!props.is_preview_called }, error);\n\n    return new AnalyticsEvent({ name, level, properties });\n  }\n\n  static publish({ devices, settings, error }: { devices?: DeviceMap; settings?: HMSTrackSettings; error?: Error }) {\n    const name = this.eventNameFor('publish', error === undefined);\n    const level = error ? AnalyticsEventLevel.ERROR : AnalyticsEventLevel.INFO;\n    const properties = this.getPropertiesWithError(\n      {\n        devices,\n        audio: settings?.audio,\n        video: settings?.video,\n      },\n      error,\n    );\n    return new AnalyticsEvent({\n      name,\n      level,\n      properties,\n    });\n  }\n\n  static subscribeFail(error: Error) {\n    const name = this.eventNameFor('subscribe', false);\n    const level = AnalyticsEventLevel.ERROR;\n    const properties = this.getErrorProperties(error);\n\n    return new AnalyticsEvent({ name, level, properties });\n  }\n\n  static leave() {\n    return new AnalyticsEvent({ name: 'leave', level: AnalyticsEventLevel.INFO });\n  }\n\n  static autoplayError() {\n    return new AnalyticsEvent({ name: 'autoplayError', level: AnalyticsEventLevel.ERROR });\n  }\n\n  static audioPlaybackError(error: HMSException) {\n    return new AnalyticsEvent({\n      name: 'audioPlaybackError',\n      level: AnalyticsEventLevel.ERROR,\n      properties: this.getErrorProperties(error),\n    });\n  }\n\n  static deviceChange({\n    selection,\n    type,\n    devices,\n    error,\n  }: {\n    selection: Partial<SelectedDevices>;\n    type?: 'change' | 'list' | 'audioInput' | 'audioOutput' | 'video';\n    devices: DeviceMap;\n    error?: Error;\n  }) {\n    const name = this.eventNameFor(error ? 'publish' : `device.${type}`, error === undefined);\n    const level = error ? AnalyticsEventLevel.ERROR : AnalyticsEventLevel.INFO;\n    const properties = this.getPropertiesWithError({ selection, devices }, error);\n    return new AnalyticsEvent({\n      name,\n      level,\n      properties,\n    });\n  }\n\n  static performance(stats: IAnalyticsPropertiesProvider) {\n    const name = 'perf.stats';\n    const level = AnalyticsEventLevel.INFO;\n    const properties = stats.toAnalyticsProperties();\n\n    return new AnalyticsEvent({ name, level, properties });\n  }\n\n  static rtcStats(stats: IAnalyticsPropertiesProvider) {\n    const name = 'rtc.stats';\n    const level = AnalyticsEventLevel.INFO;\n    const properties = stats.toAnalyticsProperties();\n\n    return new AnalyticsEvent({ name, level, properties });\n  }\n\n  /**\n   * TODO: remove once everything is switched to server side degradation, this\n   * event can be handled on server side as well.\n   */\n  static degradationStats(track: HMSRemoteVideoTrack, isDegraded: boolean) {\n    const name = 'video.degradation.stats';\n    const level = AnalyticsEventLevel.INFO;\n    let properties: any = {\n      degradedAt: track.degradedAt,\n      trackId: track.trackId,\n    };\n\n    if (!isDegraded && track.degradedAt instanceof Date) {\n      // not degraded => restored\n      const restoredAt = new Date();\n      const duration = restoredAt.valueOf() - track.degradedAt.valueOf();\n      properties = { ...properties, duration, restoredAt };\n    }\n\n    return new AnalyticsEvent({ name, level, properties });\n  }\n\n  static audioDetectionFail(error: Error, device?: MediaDeviceInfo): AnalyticsEvent {\n    const properties = this.getPropertiesWithError({ device }, error);\n    const level = AnalyticsEventLevel.ERROR;\n    const name = 'audiopresence.failed';\n\n    return new AnalyticsEvent({ name, level, properties });\n  }\n\n  static previewNetworkQuality(properties: { downLink?: string; score?: number; error?: string }) {\n    return new AnalyticsEvent({\n      name: 'perf.networkquality.preview',\n      level: properties.error ? AnalyticsEventLevel.ERROR : AnalyticsEventLevel.INFO,\n      properties,\n    });\n  }\n\n  private static eventNameFor(name: string, ok: boolean) {\n    const suffix = ok ? 'success' : 'failed';\n    return `${name}.${suffix}`;\n  }\n\n  private static getPropertiesWithError(initialProperties: any, error?: Error) {\n    const errorProperties = this.getErrorProperties(error);\n    initialProperties = { ...errorProperties, ...initialProperties };\n    return initialProperties;\n  }\n\n  private static getErrorProperties(error?: Error): Record<string, any> {\n    if (error) {\n      return error instanceof HMSException\n        ? error.toAnalyticsProperties()\n        : {\n            error_name: error.name,\n            error_message: error.message,\n            error_description: error.cause,\n          };\n    } else {\n      return {};\n    }\n  }\n}\n", "import HMSLogger from '../utils/logger';\n\nexport type TimedEventName = 'init' | 'websocket-open' | 'on-policy-change' | 'local-tracks' | 'preview' | 'join';\n\nexport enum TimedEvent {\n  INIT = 'init_response_time',\n  WEBSOCKET_CONNECT = 'ws_connect_time',\n  ON_POLICY_CHANGE = 'on_policy_change_time',\n  LOCAL_AUDIO_TRACK = 'local_audio_track_time',\n  LOCAL_VIDEO_TRACK = 'local_video_track_time',\n  JOIN = 'join_time',\n  PREVIEW = 'preview_time',\n  PEER_LIST = 'peer_list_time',\n  ROOM_STATE = 'room_state_time',\n  JOIN_RESPONSE = 'join_response_time',\n}\n\nconst defaultEventNames = [\n  TimedEvent.INIT,\n  TimedEvent.WEBSOCKET_CONNECT,\n  TimedEvent.ON_POLICY_CHANGE,\n  TimedEvent.LOCAL_AUDIO_TRACK,\n  TimedEvent.LOCAL_VIDEO_TRACK,\n  TimedEvent.PEER_LIST,\n  TimedEvent.ROOM_STATE,\n];\n\nexport class AnalyticsTimer {\n  private eventPerformanceMeasures: Partial<Record<TimedEvent, PerformanceMeasure>> = {};\n\n  start(eventName: TimedEvent) {\n    performance.mark(eventName);\n  }\n\n  end(eventName: TimedEvent) {\n    try {\n      this.eventPerformanceMeasures[eventName] = performance.measure(eventName, eventName);\n      HMSLogger.d('[HMSPerformanceTiming]', eventName, this.eventPerformanceMeasures[eventName]?.duration);\n    } catch (error) {\n      HMSLogger.w('[AnalyticsTimer]', `Error in measuring performance for event ${eventName}`, { error });\n    }\n  }\n\n  getTimeTaken(eventName: TimedEvent) {\n    return this.eventPerformanceMeasures[eventName]?.duration;\n  }\n\n  getTimes(...eventNames: TimedEvent[]) {\n    return [...defaultEventNames, ...eventNames].reduce(\n      (timeObject, eventName) => ({ ...timeObject, [eventName]: this.getTimeTaken(eventName) }),\n      {},\n    );\n  }\n\n  cleanUp() {\n    this.eventPerformanceMeasures = {};\n  }\n}\n", "/*\n * ErrorCodes.ts\n *\n * Created by codegen\n * Copyright \u00A9 2021 100ms. All rights reserved.\n */\n\nexport const ErrorCodes = {\n  // https://www.rfc-editor.org/rfc/rfc6455#section-7.4.1\n  WebSocketConnectionErrors: {\n    // Error connecting to ws or init config not available\n    FAILED_TO_CONNECT: 1000,\n\n    // Network connection lost\n    WEBSOCKET_CONNECTION_LOST: 1003,\n\n    // Abnormal close without receiving a Close control frame\n    ABNORMAL_CLOSE: 1006,\n  },\n\n  InitAPIErrors: {\n    // [INIT]: Server error\n    SERVER_ERRORS: 2000,\n    //init config not available\n    INIT_CONFIG_NOT_AVAILABLE: 2002,\n\n    // Endpoint is not reachable.\n    ENDPOINT_UNREACHABLE: 2003,\n\n    // Token is not in proper JWT format\n    INVALID_TOKEN_FORMAT: 2004,\n  },\n\n  TracksErrors: {\n    // [PUBLISH]: Error with getusermedia request\n    GENERIC_TRACK: 3000,\n\n    // [PUBLISH]: No permission to access capture device - {device_type}\n    CANT_ACCESS_CAPTURE_DEVICE: 3001,\n\n    // [PUBLISH]: Capture device is no longer available - {device_type}\n    DEVICE_NOT_AVAILABLE: 3002,\n\n    // [PUBLISH]: Capture device is in use by another application - {device_type}\n    DEVICE_IN_USE: 3003,\n\n    // Lost access to capture device midway - {device_type}\n    DEVICE_LOST_MIDWAY: 3008,\n\n    // There is no media to return. Please select either video or audio or both.\n    NOTHING_TO_RETURN: 3005,\n\n    // Cannot enable simulcast when no video settings are provided\n    INVALID_VIDEO_SETTINGS: 3006,\n\n    // Codec can't be changed mid call.\n    CODEC_CHANGE_NOT_PERMITTED: 3007,\n\n    // When the browser throws autoplay exception if something is played before interacting\n    AUTOPLAY_ERROR: 3008,\n\n    // Over constrained error - device hardware unable to satisfy requested constraints\n    OVER_CONSTRAINED: 3009,\n\n    // No audio detected from track, indicates problem with device hardware\n    NO_AUDIO_DETECTED: 3010,\n\n    // Operating System denied permission\n    SYSTEM_DENIED_PERMISSION: 3011,\n\n    // Current tab is not shared when forceCurrentTab was set to true for screenshare\n    CURRENT_TAB_NOT_SHARED: 3012,\n\n    // any error that occurs while playing audio of remote audio tracks\n    AUDIO_PLAYBACK_ERROR: 3013,\n  },\n\n  WebrtcErrors: {\n    // [{action}]: Failed to create offer.\n    CREATE_OFFER_FAILED: 4001,\n\n    // [{action}]: Failed to create answer.\n    CREATE_ANSWER_FAILED: 4002,\n\n    // [{action}]: Failed to set offer.\n    SET_LOCAL_DESCRIPTION_FAILED: 4003,\n\n    // [{action}]: Failed to set answer.\n    SET_REMOTE_DESCRIPTION_FAILED: 4004,\n\n    // [{action}]: Ice connection state FAILED\n    ICE_FAILURE: 4005,\n\n    // [{action}]: Ice connection state FAILED\n    ICE_DISCONNECTED: 4006,\n  },\n\n  WebsocketMethodErrors: {\n    // [JOIN]: {server_error}\n    SERVER_ERRORS: 5000,\n\n    // [JOIN]: You have already joined this room.\n    ALREADY_JOINED: 5001,\n\n    // [JOIN]: Cannot join if preview is in progress\n    CANNOT_JOIN_PREVIEW_IN_PROGRESS: 5002,\n  },\n\n  GenericErrors: {\n    // Client is not connected\n    NOT_CONNECTED: 6000,\n\n    // Unknown signalling error: {action} {error_info}\n    SIGNALLING: 6001,\n\n    // Unknown exception: {error_info}\n    UNKNOWN: 6002,\n\n    // WebRTC engine is not ready yet\n    NOT_READY: 6003,\n\n    // Failed to parse JSON message - {json_message}\n    JSON_PARSING_FAILED: 6004,\n\n    // Track Metadata Missing\n    TRACK_METADATA_MISSING: 6005,\n\n    // RTC Track missing\n    RTC_TRACK_MISSING: 6006,\n\n    // Peer Metadata Missing\n    PEER_METADATA_MISSING: 6007,\n\n    // Joined with invalid role\n    INVALID_ROLE: 6008,\n\n    PREVIEW_IN_PROGRESS: 6009,\n\n    MISSING_MEDIADEVICES: 6010,\n\n    MISSING_RTCPEERCONNECTION: 6011,\n  },\n\n  PlaylistErrors: {\n    NO_ENTRY_TO_PLAY: 8001,\n    NO_ENTRY_IS_PLAYING: 8002,\n  },\n};\n", "/*\n * ErrorFactory.ts\n *\n * Created by codegen\n * Copyright \u00A9 2021 100ms. All rights reserved.\n */\n\nimport { ErrorCodes } from './ErrorCodes';\nimport { HMSException } from './HMSException';\nimport { HMSSignalMethod } from '../signal/jsonrpc/models';\n\nexport enum HMSAction {\n  NONE = 'NONE',\n  TRACK = 'TRACK',\n  INIT = 'INIT',\n  PUBLISH = 'PUBLISH',\n  UNPUBLISH = 'UNPUBLISH',\n  JOIN = 'JOIN',\n  SUBSCRIBE = 'SUBSCRIBE',\n  DATA_CHANNEL_SEND = 'DATA_CHANNEL_SEND',\n  RESTART_ICE = 'RESTART_ICE',\n  VIDEO_PLUGINS = 'VIDEO_PLUGINS',\n  AUDIO_PLUGINS = 'AUDIO_PLUGINS',\n  AUTOPLAY = 'AUTOPLAY',\n  RECONNECT_SIGNAL = 'RECONNECT_SIGNAL',\n  VALIDATION = 'VALIDATION',\n  PLAYLIST = 'PLAYLIST',\n  PREVIEW = 'PREVIEW',\n}\n\nexport const ErrorFactory = {\n  WebSocketConnectionErrors: {\n    FailedToConnect(action: HMSAction, description = '') {\n      return new HMSException(\n        ErrorCodes.WebSocketConnectionErrors.FAILED_TO_CONNECT,\n        'WebsocketFailedToConnect',\n        action,\n        `[WS]: ${description}`,\n        `[WS]: ${description}`,\n      );\n    },\n\n    WebSocketConnectionLost(action: HMSAction, description = '') {\n      return new HMSException(\n        ErrorCodes.WebSocketConnectionErrors.WEBSOCKET_CONNECTION_LOST,\n        'WebSocketConnectionLost',\n        action,\n        `Network connection lost `,\n        description,\n      );\n    },\n\n    AbnormalClose(action: HMSAction, description = '') {\n      return new HMSException(\n        ErrorCodes.WebSocketConnectionErrors.ABNORMAL_CLOSE,\n        'WebSocketAbnormalClose',\n        action,\n        `Websocket closed abnormally`,\n        description,\n      );\n    },\n  },\n\n  InitAPIErrors: {\n    ServerErrors(code: number, action: HMSAction, description = '') {\n      return new HMSException(code, 'ServerErrors', action, `[INIT]: Server error ${description}`, description, true);\n    },\n\n    EndpointUnreachable(action: HMSAction, description = '') {\n      return new HMSException(\n        ErrorCodes.InitAPIErrors.ENDPOINT_UNREACHABLE,\n        'EndpointUnreachable',\n        action,\n        `Endpoint is not reachable - ${description}`,\n        description,\n      );\n    },\n\n    InvalidTokenFormat(action: HMSAction, description = '') {\n      return new HMSException(\n        ErrorCodes.InitAPIErrors.INVALID_TOKEN_FORMAT,\n        'InvalidTokenFormat',\n        action,\n        `Token is not in proper JWT format - ${description}`,\n        description,\n        true,\n      );\n    },\n\n    InitConfigNotAvailable(action: HMSAction, description = '') {\n      return new HMSException(\n        ErrorCodes.InitAPIErrors.INIT_CONFIG_NOT_AVAILABLE,\n        'InitError',\n        action,\n        `[INIT]: ${description}`,\n        `[INIT]: ${description}`,\n      );\n    },\n  },\n\n  TracksErrors: {\n    GenericTrack(action: HMSAction, description = '') {\n      return new HMSException(\n        ErrorCodes.TracksErrors.GENERIC_TRACK,\n        'GenericTrack',\n        action,\n        `[TRACK]: ${description}`,\n        `[TRACK]: ${description}`,\n      );\n    },\n\n    CantAccessCaptureDevice(action: HMSAction, deviceInfo: string, description = '') {\n      return new HMSException(\n        ErrorCodes.TracksErrors.CANT_ACCESS_CAPTURE_DEVICE,\n        'CantAccessCaptureDevice',\n        action,\n        `User denied permission to access capture device - ${deviceInfo}`,\n        description,\n      );\n    },\n\n    DeviceNotAvailable(action: HMSAction, deviceInfo: string, description = '') {\n      return new HMSException(\n        ErrorCodes.TracksErrors.DEVICE_NOT_AVAILABLE,\n        'DeviceNotAvailable',\n        action,\n        `[TRACK]: Capture device is no longer available - ${deviceInfo}`,\n        description,\n      );\n    },\n\n    DeviceInUse(action: HMSAction, deviceInfo: string, description = '') {\n      return new HMSException(\n        ErrorCodes.TracksErrors.DEVICE_IN_USE,\n        'DeviceInUse',\n        action,\n        `[TRACK]: Capture device is in use by another application - ${deviceInfo}`,\n        description,\n      );\n    },\n\n    DeviceLostMidway(action: HMSAction, deviceInfo: string, description = '') {\n      return new HMSException(\n        ErrorCodes.TracksErrors.DEVICE_LOST_MIDWAY,\n        'DeviceLostMidway',\n        action,\n        `Lost access to capture device midway - ${deviceInfo}`,\n        description,\n      );\n    },\n\n    NothingToReturn(\n      action: HMSAction,\n      description = '',\n      message = `There is no media to return. Please select either video or audio or both.`,\n    ) {\n      return new HMSException(\n        ErrorCodes.TracksErrors.NOTHING_TO_RETURN,\n        'NothingToReturn',\n        action,\n        message,\n        description,\n      );\n    },\n\n    InvalidVideoSettings(action: HMSAction, description = '') {\n      return new HMSException(\n        ErrorCodes.TracksErrors.INVALID_VIDEO_SETTINGS,\n        'InvalidVideoSettings',\n        action,\n        `Cannot enable simulcast when no video settings are provided`,\n        description,\n      );\n    },\n\n    AutoplayBlocked(action: HMSAction, description = '') {\n      return new HMSException(\n        ErrorCodes.TracksErrors.AUTOPLAY_ERROR,\n        'AutoplayBlocked',\n        action,\n        \"Autoplay blocked because the user didn't interact with the document first\",\n        description,\n      );\n    },\n\n    CodecChangeNotPermitted(action: HMSAction, description = '') {\n      return new HMSException(\n        ErrorCodes.TracksErrors.CODEC_CHANGE_NOT_PERMITTED,\n        'CodecChangeNotPermitted',\n        action,\n        `Codec can't be changed mid call.`,\n        description,\n      );\n    },\n\n    OverConstrained(action: HMSAction, deviceInfo: string, description = '') {\n      return new HMSException(\n        ErrorCodes.TracksErrors.OVER_CONSTRAINED,\n        'OverConstrained',\n        action,\n        `[TRACK]: Requested constraints cannot be satisfied with the device hardware - ${deviceInfo}`,\n        description,\n      );\n    },\n\n    NoAudioDetected(action: HMSAction, description = 'Please check the mic or use another audio input') {\n      return new HMSException(\n        ErrorCodes.TracksErrors.NO_AUDIO_DETECTED,\n        'NoAudioDetected',\n        action,\n        'No audio input detected from microphone',\n        description,\n      );\n    },\n\n    SystemDeniedPermission(action: HMSAction, deviceInfo: string, description = '') {\n      return new HMSException(\n        ErrorCodes.TracksErrors.SYSTEM_DENIED_PERMISSION,\n        'SystemDeniedPermission',\n        action,\n        `Operating System denied permission to access capture device - ${deviceInfo}`,\n        description,\n      );\n    },\n\n    CurrentTabNotShared() {\n      return new HMSException(\n        ErrorCodes.TracksErrors.CURRENT_TAB_NOT_SHARED,\n        'CurrentTabNotShared',\n        HMSAction.TRACK,\n        'The app requires you to share the current tab',\n        'You must screen share the current tab in order to proceed',\n      );\n    },\n\n    AudioPlaybackError(description: string) {\n      return new HMSException(\n        ErrorCodes.TracksErrors.AUDIO_PLAYBACK_ERROR,\n        'Audio playback error',\n        HMSAction.TRACK,\n        description,\n        description,\n      );\n    },\n  },\n\n  WebrtcErrors: {\n    CreateOfferFailed(action: HMSAction, description = '') {\n      return new HMSException(\n        ErrorCodes.WebrtcErrors.CREATE_OFFER_FAILED,\n        'CreateOfferFailed',\n        action,\n        `[${action.toString()}]: Failed to create offer. `,\n        description,\n      );\n    },\n\n    CreateAnswerFailed(action: HMSAction, description = '') {\n      return new HMSException(\n        ErrorCodes.WebrtcErrors.CREATE_ANSWER_FAILED,\n        'CreateAnswerFailed',\n        action,\n        `[${action.toString()}]: Failed to create answer. `,\n        description,\n      );\n    },\n\n    SetLocalDescriptionFailed(action: HMSAction, description = '') {\n      return new HMSException(\n        ErrorCodes.WebrtcErrors.SET_LOCAL_DESCRIPTION_FAILED,\n        'SetLocalDescriptionFailed',\n        action,\n        `[${action.toString()}]: Failed to set offer. `,\n        description,\n      );\n    },\n\n    SetRemoteDescriptionFailed(action: HMSAction, description = '') {\n      return new HMSException(\n        ErrorCodes.WebrtcErrors.SET_REMOTE_DESCRIPTION_FAILED,\n        'SetRemoteDescriptionFailed',\n        action,\n        `[${action.toString()}]: Failed to set answer. `,\n        description,\n        true,\n      );\n    },\n\n    ICEFailure(action: HMSAction, description = '') {\n      return new HMSException(\n        ErrorCodes.WebrtcErrors.ICE_FAILURE,\n        'ICEFailure',\n        action,\n        `[${action.toString()}]: Ice connection state FAILED`,\n        description,\n      );\n    },\n\n    ICEDisconnected(action: HMSAction, description = '') {\n      return new HMSException(\n        ErrorCodes.WebrtcErrors.ICE_DISCONNECTED,\n        'ICEDisconnected',\n        action,\n        `[${action.toString()}]: Ice connection state DISCONNECTED`,\n        description,\n      );\n    },\n  },\n\n  WebsocketMethodErrors: {\n    ServerErrors(code: number, action: HMSAction | HMSSignalMethod, description: string) {\n      return new HMSException(code, 'ServerErrors', action, description, description, true);\n    },\n\n    AlreadyJoined(action: HMSAction, description = '') {\n      return new HMSException(\n        ErrorCodes.WebsocketMethodErrors.ALREADY_JOINED,\n        'AlreadyJoined',\n        action,\n        `[JOIN]: You have already joined this room.`,\n        description,\n      );\n    },\n\n    CannotJoinPreviewInProgress(action: HMSAction, description = '') {\n      return new HMSException(\n        ErrorCodes.WebsocketMethodErrors.CANNOT_JOIN_PREVIEW_IN_PROGRESS,\n        'CannotJoinPreviewInProgress',\n        action,\n        `[JOIN]: Cannot join if preview is in progress`,\n        description,\n      );\n    },\n  },\n\n  GenericErrors: {\n    NotConnected(action: HMSAction, description = '') {\n      return new HMSException(\n        ErrorCodes.GenericErrors.NOT_CONNECTED,\n        'NotConnected',\n        action,\n        `Client is not connected`,\n        description,\n      );\n    },\n\n    Signalling(action: HMSAction, description: string) {\n      return new HMSException(\n        ErrorCodes.GenericErrors.SIGNALLING,\n        'Signalling',\n        action,\n        `Unknown signalling error: ${action.toString()} ${description} `,\n        description,\n      );\n    },\n\n    Unknown(action: HMSAction, description: string) {\n      return new HMSException(\n        ErrorCodes.GenericErrors.UNKNOWN,\n        'Unknown',\n        action,\n        `Unknown exception: ${description}`,\n        description,\n      );\n    },\n\n    NotReady(action: HMSAction, description = '') {\n      return new HMSException(ErrorCodes.GenericErrors.NOT_READY, 'NotReady', action, description, description);\n    },\n\n    JsonParsingFailed(action: HMSAction, jsonMessage: string, description = '') {\n      return new HMSException(\n        ErrorCodes.GenericErrors.JSON_PARSING_FAILED,\n        'JsonParsingFailed',\n        action,\n        `Failed to parse JSON message - ${jsonMessage}`,\n        description,\n      );\n    },\n\n    TrackMetadataMissing(action: HMSAction, description = '') {\n      return new HMSException(\n        ErrorCodes.GenericErrors.TRACK_METADATA_MISSING,\n        'TrackMetadataMissing',\n        action,\n        `Track Metadata Missing`,\n        description,\n      );\n    },\n\n    RTCTrackMissing(action: HMSAction, description = '') {\n      return new HMSException(\n        ErrorCodes.GenericErrors.RTC_TRACK_MISSING,\n        'RTCTrackMissing',\n        action,\n        `RTC Track missing`,\n        description,\n      );\n    },\n\n    PeerMetadataMissing(action: HMSAction, description = '') {\n      return new HMSException(\n        ErrorCodes.GenericErrors.PEER_METADATA_MISSING,\n        'PeerMetadataMissing',\n        action,\n        `Peer Metadata Missing`,\n        description,\n      );\n    },\n\n    ValidationFailed(message: string, entity?: any) {\n      return new HMSException(\n        ErrorCodes.GenericErrors.INVALID_ROLE,\n        'ValidationFailed',\n        HMSAction.VALIDATION,\n        message,\n        entity ? JSON.stringify(entity) : '',\n      );\n    },\n\n    InvalidRole(action: HMSAction, description: string) {\n      return new HMSException(\n        ErrorCodes.GenericErrors.INVALID_ROLE,\n        'InvalidRole',\n        action,\n        `Invalid role. Join with valid role`,\n        description,\n        true,\n      );\n    },\n\n    PreviewAlreadyInProgress(action: HMSAction, description = '') {\n      return new HMSException(\n        ErrorCodes.GenericErrors.PREVIEW_IN_PROGRESS,\n        'PreviewAlreadyInProgress',\n        action,\n        `[Preview]: Cannot join if preview is in progress`,\n        description,\n      );\n    },\n\n    MissingMediaDevices() {\n      return new HMSException(\n        ErrorCodes.GenericErrors.MISSING_MEDIADEVICES,\n        'MissingMediaDevices',\n        HMSAction.JOIN,\n        `navigator.mediaDevices is undefined. 100ms SDK won't work on this website as WebRTC is not supported on HTTP endpoints(missing navigator.mediaDevices). Please ensure you're using the SDK either on localhost or a valid HTTPS endpoint.`,\n        '',\n        true,\n      );\n    },\n\n    MissingRTCPeerConnection() {\n      return new HMSException(\n        ErrorCodes.GenericErrors.MISSING_RTCPEERCONNECTION,\n        'MissingRTCPeerConnection',\n        HMSAction.JOIN,\n        `RTCPeerConnection which is a core requirement for WebRTC call was not found, this could be due to an unsupported browser or browser extensions blocking WebRTC`,\n        '',\n        true,\n      );\n    },\n  },\n\n  MediaPluginErrors: {\n    PlatformNotSupported(action: HMSAction, description = '') {\n      return new HMSException(\n        7001,\n        'PlatformNotSupported',\n        action,\n        'Check HMS Docs to see the list of supported platforms',\n        description,\n      );\n    },\n\n    InitFailed(action: HMSAction, description = '') {\n      return new HMSException(7002, 'InitFailed', action, 'Plugin init failed', description);\n    },\n\n    ProcessingFailed(action: HMSAction, description = '') {\n      return new HMSException(7003, 'ProcessingFailed', action, 'Plugin processing failed', description);\n    },\n\n    AddAlreadyInProgress(action: HMSAction, description = '') {\n      return new HMSException(7004, 'AddAlreadyInProgress', action, 'Plugin add already in progress', description);\n    },\n\n    DeviceNotSupported(action: HMSAction, description = '') {\n      return new HMSException(\n        7005,\n        'DeviceNotSupported',\n        action,\n        'Check HMS Docs to see the list of supported devices',\n        description,\n      );\n    },\n  },\n\n  PlaylistErrors: {\n    NoEntryToPlay(action: HMSAction, description: string) {\n      return new HMSException(\n        ErrorCodes.PlaylistErrors.NO_ENTRY_TO_PLAY,\n        'NoEntryToPlay',\n        action,\n        'Reached end of playlist',\n        description,\n      );\n    },\n    NoEntryPlaying(action: HMSAction, description: string) {\n      return new HMSException(\n        ErrorCodes.PlaylistErrors.NO_ENTRY_IS_PLAYING,\n        'NoEntryIsPlaying',\n        action,\n        'No entry is playing at this time',\n        description,\n      );\n    },\n  },\n};\n", "import adapter from 'webrtc-adapter';\nimport { ErrorFactory, HMSAction } from './ErrorFactory';\nimport { HMSException } from './HMSException';\n\nexport enum HMSGetMediaActions {\n  UNKNOWN = 'unknown(video or audio)',\n  AUDIO = 'audio',\n  VIDEO = 'video',\n  AV = 'audio, video',\n  SCREEN = 'screen',\n}\n\nfunction getDefaultError(error: string, deviceInfo: string) {\n  const message = error.toLowerCase();\n  if (message.includes('device not found')) {\n    return ErrorFactory.TracksErrors.DeviceNotAvailable(HMSAction.TRACK, deviceInfo, error);\n  } else if (message.includes('permission denied')) {\n    return ErrorFactory.TracksErrors.CantAccessCaptureDevice(HMSAction.TRACK, deviceInfo, error);\n  } else {\n    return ErrorFactory.TracksErrors.GenericTrack(HMSAction.TRACK, error);\n  }\n}\n\n/**\n * # Edge Cases:\n * - Screenshare error: The problem is when block at OS level, chrome throws NotAllowedError(HMS code - 3001) while firefox throws NotFoundError(HMS code - 3002),\n * we will handle this internally and throw error as User block - 3001 and OS block - 3011 for all browsers.\n * Chrome -\n * User blocked - NotAllowedError - Permission denied\n * System blocked - NotAllowedError - Permission denied by system\n */\n// eslint-disable-next-line complexity\nfunction convertMediaErrorToHMSException(err: Error, deviceInfo = ''): HMSException {\n  /**\n   * Note: Adapter detects all chromium browsers as 'chrome'\n   */\n  const chromeSystemDenied =\n    adapter.browserDetails.browser === 'chrome' &&\n    err.name === 'NotAllowedError' &&\n    err.message.includes('denied by system');\n\n  if (chromeSystemDenied) {\n    return ErrorFactory.TracksErrors.SystemDeniedPermission(HMSAction.TRACK, deviceInfo, err.message);\n  }\n\n  if (adapter.browserDetails.browser === 'firefox' && err.name === 'NotFoundError') {\n    const hmsError = ErrorFactory.TracksErrors.SystemDeniedPermission(HMSAction.TRACK, deviceInfo, err.message);\n    hmsError.description = `Capture device is either blocked at Operating System level or not available - ${deviceInfo}`;\n    return hmsError;\n  }\n\n  switch (err.name) {\n    case 'OverconstrainedError':\n      return ErrorFactory.TracksErrors.OverConstrained(\n        HMSAction.TRACK,\n        deviceInfo,\n        (err as OverconstrainedError).constraint,\n      );\n    case 'NotAllowedError':\n      return ErrorFactory.TracksErrors.CantAccessCaptureDevice(HMSAction.TRACK, deviceInfo, err.message);\n    case 'NotFoundError':\n      return ErrorFactory.TracksErrors.DeviceNotAvailable(HMSAction.TRACK, deviceInfo, err.message);\n    case 'NotReadableError':\n      return ErrorFactory.TracksErrors.DeviceInUse(HMSAction.TRACK, deviceInfo, err.message);\n    case 'TypeError':\n      return ErrorFactory.TracksErrors.NothingToReturn(HMSAction.TRACK, err.message);\n    default:\n      return getDefaultError(err.message, deviceInfo);\n  }\n}\n\nexport function BuildGetMediaError(err: Error, deviceInfo: string): HMSException {\n  const exception = convertMediaErrorToHMSException(err, deviceInfo);\n  exception.addNativeError(err);\n  return exception;\n}\n", "import { HMSChangeMultiTrackStateRequest, HMSChangeTrackStateRequest } from './change-track-state';\nimport { DeviceChangeListener } from './devices';\nimport { HMSLeaveRoomRequest } from './leave-room-request';\nimport { HMSMessage } from './message';\nimport { HMSConnectionQuality } from './peer';\nimport { HMSRoleChangeRequest } from './role-change-request';\nimport { HMSRoom } from './room';\nimport { HMSSpeaker } from './speaker';\nimport { HMSException } from '../error/HMSException';\nimport { HMSTrack } from '../media/tracks/HMSTrack';\nimport { HMSPeer } from '../sdk/models/peer';\n\nexport enum HMSRoomUpdate {\n  RECORDING_STATE_UPDATED = 'RECORDING_STATE_UPDATED',\n  BROWSER_RECORDING_STATE_UPDATED = 'BROWSER_RECORDING_STATE_UPDATED',\n  SERVER_RECORDING_STATE_UPDATED = 'SERVER_RECORDING_STATE_UPDATED',\n  RTMP_STREAMING_STATE_UPDATED = 'RTMP_STREAMING_STATE_UPDATED',\n  HLS_STREAMING_STATE_UPDATED = 'HLS_STREAMING_STATE_UPDATED',\n}\n\nexport enum HMSPeerUpdate {\n  PEER_JOINED,\n  PEER_LEFT,\n  AUDIO_TOGGLED,\n  VIDEO_TOGGLED,\n  BECAME_DOMINANT_SPEAKER,\n  RESIGNED_DOMINANT_SPEAKER,\n  STARTED_SPEAKING,\n  STOPPED_SPEAKING,\n  ROLE_UPDATED,\n  PEER_LIST,\n  NAME_UPDATED,\n  METADATA_UPDATED,\n}\n\nexport enum HMSTrackUpdate {\n  TRACK_ADDED,\n  TRACK_REMOVED,\n  TRACK_MUTED,\n  TRACK_UNMUTED,\n  TRACK_DESCRIPTION_CHANGED,\n  TRACK_DEGRADED,\n  TRACK_RESTORED,\n}\n\nexport interface HMSAudioListener {\n  onAudioLevelUpdate(speakers: HMSSpeaker[]): void;\n}\n\nexport interface HMSConnectionQualityListener {\n  onConnectionQualityUpdate(qualityUpdates: HMSConnectionQuality[]): void;\n}\n\nexport interface HMSUpdateListener extends DeviceChangeListener {\n  onJoin(room: HMSRoom): void;\n  onRoomUpdate(type: HMSRoomUpdate, room: HMSRoom): void;\n  onPeerUpdate(type: HMSPeerUpdate, peer: HMSPeer | HMSPeer[] | null): void;\n  onTrackUpdate(type: HMSTrackUpdate, track: HMSTrack, peer: HMSPeer): void;\n  onMessageReceived(message: HMSMessage): void;\n  onError(error: HMSException): void;\n  onReconnecting(error: HMSException): void;\n  onReconnected(): void;\n  onRoleChangeRequest(request: HMSRoleChangeRequest): void;\n  onRoleUpdate(newRole: string): void;\n  onChangeTrackStateRequest(request: HMSChangeTrackStateRequest): void;\n  onChangeMultiTrackStateRequest(request: HMSChangeMultiTrackStateRequest): void;\n  onRemovedFromRoom(request: HMSLeaveRoomRequest): void;\n  onNetworkQuality?(score: number): void;\n}\n", "export enum HMSSimulcastLayer {\n  NONE = 'none',\n  LOW = 'low',\n  MEDIUM = 'medium',\n  HIGH = 'high',\n}\n\nexport interface SimulcastLayer {\n  rid: string;\n  scaleResolutionDownBy: number;\n  maxBitrate: number;\n  maxFramerate: number;\n}\n\nexport interface SimulcastResolution {\n  width: number;\n  height: number;\n}\n\nexport interface SimulcastLayers {\n  layers: SimulcastLayer[];\n}\n\nexport type HMSPreferredSimulcastLayer = Exclude<HMSSimulcastLayer, HMSSimulcastLayer.NONE>;\nexport interface HMSSimulcastLayerDefinition {\n  layer: HMSPreferredSimulcastLayer;\n  resolution: SimulcastResolution;\n}\n\nexport type RID = 'f' | 'h' | 'q';\n\nexport const simulcastMapping = {\n  f: HMSSimulcastLayer.HIGH,\n  h: HMSSimulcastLayer.MEDIUM,\n  q: HMSSimulcastLayer.LOW,\n};\n", "export enum HMSVideoCodec {\n  VP8 = 'vp8',\n  VP9 = 'vp9',\n  H264 = 'h264',\n}\n\nexport enum HMSAudioCodec {\n  OPUS = 'opus',\n}\n\nexport interface HMSAudioTrackSettings {\n  volume?: number;\n  codec?: HMSAudioCodec;\n  maxBitrate?: number;\n  deviceId?: string;\n  advanced?: Array<MediaTrackConstraintSet>;\n}\n\nexport interface HMSVideoTrackSettings {\n  width?: number;\n  height?: number;\n  codec?: HMSVideoCodec;\n  maxFramerate?: number;\n  maxBitrate?: number;\n  deviceId?: string;\n  advanced?: Array<MediaTrackConstraintSet>;\n}\n\n/**\n * Config to have control over screenshare being captured. Note that\n * not all fields are supported on all browsers. Even when they're supported\n * the fields acts as hints and the browser can override them.\n */\nexport interface HMSScreenShareConfig {\n  /**\n   * discard the video and only share audio track with others, useful\n   * for sharing music.\n   * @default false\n   */\n  audioOnly?: boolean;\n  /**\n   * do not give an option to share audio while screen sharing.\n   * @default false\n   */\n  videoOnly?: boolean;\n  /**\n   * preselect the relevant tab in screenshare menu\n   * browser - for preferring a browser tab\n   * window - for application window\n   * monitor - for full screen\n   * @default monitor\n   */\n  displaySurface?: 'browser' | 'monitor' | 'window';\n  /**\n   * show the current tab first in supported browser, throws\n   * error if user doesn't select current tab for sharing.\n   * @default false\n   */\n  forceCurrentTab?: boolean;\n  /**\n   * show the current tab first in supported browser, but don't throw error\n   * if user selects something else.\n   * @default false\n   */\n  preferCurrentTab?: boolean;\n  /**\n   * whether to show an option for sharing the current tab in the screen share\n   * prompt. Screen sharing current tab might lead to hall of mirrors effect.\n   * Default is exclude, if either of forceCurrentTab or preferCurrentTab are true,\n   * this is set to include.\n   * @default exclude\n   */\n  selfBrowserSurface?: 'include' | 'exclude';\n  /**\n   * whether to hint browser to show a \"share this tab instead\" option when\n   * tab is shared.\n   * Default is include, set to exclude if forceCurrentTab is true\n   * @default include\n   */\n  surfaceSwitching?: 'include' | 'exclude';\n  /**\n   * whether to show option for sharing system level audio if full screen\n   * is being shared. Not applicable if isVideoOnly is true.\n   * Note that sharing system audio will cause echo if mic is on.\n   * @default exclude\n   */\n  systemAudio?: 'include' | 'exclude';\n  /**\n   * used for region capture in screenshare, if the current tab is being screenshared\n   * the screenshare video track will be cropped to only this element. Will throw\n   * error if the element is not present in DOM.\n   */\n  cropElement?: HTMLDivElement;\n  /**\n   * used for region capture in screenshare, the screenshare video track will be\n   * cropped to only the passed in cropTarget. This cropTarget must come from\n   * the tab which is being shared\n   */\n  cropTarget?: object;\n}\n\nexport interface ScreenCaptureHandle {\n  handle: string;\n  exposeOrigin: boolean;\n}\n\nexport interface ScreenCaptureHandleConfig extends ScreenCaptureHandle {\n  permittedOrigins: string[];\n}\n", "import { HMSException } from '../error/HMSException';\n\nexport interface HMSDeviceChangeEvent {\n  error?: HMSException;\n  devices: DeviceMap;\n  selection?: MediaDeviceInfo;\n  type: 'audioOutput' | 'audioInput' | 'video';\n}\n\nexport enum DeviceType {\n  videoInput = 'videoInput',\n  audioInput = 'audioInput',\n  audioOutput = 'audioOutput',\n}\n\nexport interface DeviceMap {\n  [DeviceType.audioInput]: MediaDeviceInfo[];\n  [DeviceType.audioOutput]: MediaDeviceInfo[];\n  [DeviceType.videoInput]: MediaDeviceInfo[];\n}\n\nexport interface DeviceChangeListener {\n  onDeviceChange?(event: HMSDeviceChangeEvent): void;\n}\n", "export enum HMSPlaylistType {\n  audio = 'audio',\n  video = 'video',\n}\n\nexport interface HMSPlaylistItem<T> {\n  /**\n   * uniquely identifies a playlist item\n   */\n  id: string;\n  name: string;\n  type: HMSPlaylistType;\n  /**\n   * the url to play from, local files are not supported currently.\n   */\n  url: string;\n  /**\n   * any additional info, for eg. composer, musician etc.\n   */\n  metadata?: T;\n  /**\n   * duration in seconds\n   */\n  duration?: number;\n}\n\nexport interface HMSPlaylistProgressEvent {\n  type: HMSPlaylistType;\n  progress: number;\n}\n\nexport interface HMSPlaylistManager {\n  getList<T>(type: HMSPlaylistType): HMSPlaylistItem<T>[];\n  setList<T>(list: HMSPlaylistItem<T>[]): void;\n  clearList(type: HMSPlaylistType): Promise<void>;\n  playNext(type: HMSPlaylistType): Promise<void>;\n  playPrevious(type: HMSPlaylistType): Promise<void>;\n  removeItem(id: string, type: HMSPlaylistType): Promise<boolean>;\n  /**\n   * Seek forward/backward on selected type relative to currentTime\n   * @param value - number in seconds to go forward(if negative, it goes backwards)\n   * @param {HMSPlaylistType} type\n   */\n  seek(value: number, type: HMSPlaylistType): void;\n  /**\n   * Seek forward/backward on selected type - absolute value\n   * @param value - point in playlist item to go to\n   * @param {HMSPlaylistType} type\n   */\n  seekTo(value: number, type: HMSPlaylistType): void;\n  /**\n   * set volume on the selected type\n   * @param value - number between 0-100\n   * @param type\n   */\n  setVolume(value: number, type: HMSPlaylistType): void;\n  /**\n   * Get volume of selected type, between 0-100\n   * @param type\n   */\n  getVolume(type: HMSPlaylistType): number;\n  isPlaying(type: HMSPlaylistType): boolean;\n  getCurrentIndex(type: HMSPlaylistType): number;\n  getCurrentSelection<T>(type: HMSPlaylistType): HMSPlaylistItem<T> | undefined;\n  /**\n   * Returns a value between 0-100\n   * @param {HMSPlaylistType} type\n   */\n  getCurrentProgress(type: HMSPlaylistType): number;\n  /**\n   * Get the currentTime of audio/video based on type\n   * @param {HMSPlaylistType} type\n   */\n  getCurrentTime(type: HMSPlaylistType): number;\n  setEnabled(enabled: boolean, info: { id: string; type: HMSPlaylistType }): Promise<void>;\n  stop(type: HMSPlaylistType): Promise<void>;\n  /**\n   * Subscriber to progress event with a callback\n   * @param fn\n   */\n  onProgress(fn: (event: HMSPlaylistProgressEvent) => void): void;\n  /**\n   * This will be called when a new track is played\n   * @param fn\n   */\n  onNewTrackStart<T>(fn: (item: HMSPlaylistItem<T>) => void): void;\n\n  onPlaylistEnded(fn: (type: HMSPlaylistType) => void): void;\n  onCurrentTrackEnded<T>(fn: (item: HMSPlaylistItem<T>) => void): void;\n  /**\n   * Function to autoplay status i.e. whether next item in playlist after the current one ends\n   * @param {HMSPlaylistType} type\n   * @param {boolean} autoplay\n   */\n  setIsAutoplayOn(type: HMSPlaylistType, autoplay: boolean): void;\n  /**\n   * Get the current playback rate of audio/video playlist\n   * @param {HMSPlaylistType} type\n   */\n  getPlaybackRate(type: HMSPlaylistType): number;\n  /**\n   * set the current playback rate of audio/video playlist\n   * @param {HMSPlaylistType}type\n   * @param {number}value - number between 0.25 and 2.0\n   */\n  setPlaybackRate(type: HMSPlaylistType, value: number): void;\n}\n", "import { IAnalyticsPropertiesProvider } from '../../analytics/IAnalyticsPropertiesProvider';\nimport { HMSAudioCodec, HMSAudioTrackSettings as IHMSAudioTrackSettings } from '../../interfaces';\n\nexport class HMSAudioTrackSettingsBuilder {\n  private _volume = 1.0;\n  private _codec?: HMSAudioCodec = HMSAudioCodec.OPUS;\n  private _maxBitrate?: number = 32;\n  private _deviceId = 'default';\n  private _advanced: Array<MediaTrackConstraintSet> = [\n    // @ts-ignore\n    { googEchoCancellation: { exact: true } },\n    // @ts-ignore\n    { googExperimentalEchoCancellation: { exact: true } },\n    // @ts-ignore\n    { autoGainControl: { exact: true } },\n    // @ts-ignore\n    { noiseSuppression: { exact: true } },\n    // @ts-ignore\n    { googHighpassFilter: { exact: true } },\n    // @ts-ignore\n    { googAudioMirroring: { exact: true } },\n  ];\n\n  volume(volume: number) {\n    if (!(0.0 <= volume && volume <= 1.0)) {\n      throw Error('volume can only be in range [0.0, 1.0]');\n    }\n    this._volume = volume;\n    return this;\n  }\n\n  codec(codec?: HMSAudioCodec) {\n    this._codec = codec;\n    return this;\n  }\n\n  maxBitrate(maxBitrate?: number) {\n    if (maxBitrate && maxBitrate <= 0) {\n      throw Error('maxBitrate should be >= 1');\n    }\n    this._maxBitrate = maxBitrate;\n    return this;\n  }\n\n  deviceId(deviceId: string) {\n    // TODO: Validate if device-id is OK\n    this._deviceId = deviceId;\n    return this;\n  }\n\n  advanced(advanced: Array<MediaTrackConstraintSet>) {\n    this._advanced = advanced;\n    return this;\n  }\n\n  build() {\n    return new HMSAudioTrackSettings(this._volume, this._codec, this._maxBitrate, this._deviceId, this._advanced);\n  }\n}\n\nexport class HMSAudioTrackSettings implements IHMSAudioTrackSettings, IAnalyticsPropertiesProvider {\n  readonly volume?: number;\n  readonly codec?: HMSAudioCodec;\n  readonly maxBitrate?: number;\n  readonly deviceId?: string;\n  readonly advanced?: Array<MediaTrackConstraintSet>;\n\n  constructor(\n    volume?: number,\n    codec?: HMSAudioCodec,\n    maxBitrate?: number,\n    deviceId?: string,\n    advanced?: Array<MediaTrackConstraintSet>,\n  ) {\n    this.volume = volume;\n    this.codec = codec;\n    this.maxBitrate = maxBitrate;\n    this.deviceId = deviceId;\n    this.advanced = advanced;\n  }\n\n  toConstraints(): MediaTrackConstraints {\n    return {\n      deviceId: this.deviceId,\n      advanced: this.advanced,\n    };\n  }\n\n  toAnalyticsProperties() {\n    return {\n      audio_bitrate: this.maxBitrate,\n      audio_codec: this.codec,\n    };\n  }\n}\n", "import { IAnalyticsPropertiesProvider } from '../../analytics/IAnalyticsPropertiesProvider';\nimport { HMSVideoCodec, HMSVideoTrackSettings as IHMSVideoTrackSettings } from '../../interfaces';\n\nexport class HMSVideoTrackSettingsBuilder {\n  private _width?: number = 320;\n  private _height?: number = 180;\n  private _codec?: HMSVideoCodec = HMSVideoCodec.VP8;\n  private _maxFramerate?: number = 30;\n  private _maxBitrate?: number = 150;\n  private _deviceId?: string;\n  private _advanced: Array<MediaTrackConstraintSet> = [];\n\n  setWidth(width?: number) {\n    this._width = width;\n    return this;\n  }\n\n  setHeight(height?: number) {\n    this._height = height;\n    return this;\n  }\n\n  codec(codec?: HMSVideoCodec) {\n    this._codec = codec;\n    return this;\n  }\n\n  maxFramerate(maxFramerate?: number) {\n    if (maxFramerate && maxFramerate <= 0) {\n      throw Error('maxFramerate should be >= 1');\n    }\n    this._maxFramerate = maxFramerate;\n    return this;\n  }\n\n  /**\n   * @param useDefault Ignored if maxBitrate is valid.\n   * If true and maxBitrate is undefined - sets a default value.\n   * If false and maxBitrate is undefined - sets undefined.\n   */\n  maxBitrate(maxBitrate?: number, useDefault = true) {\n    if (typeof maxBitrate === 'number' && maxBitrate <= 0) {\n      throw Error('maxBitrate should be >= 1');\n    }\n    this._maxBitrate = maxBitrate;\n    if (!this._maxBitrate && useDefault) {\n      this._maxBitrate = 150_000;\n    }\n    return this;\n  }\n\n  deviceId(deviceId: string) {\n    // TODO: Validate if device-id is OK\n    this._deviceId = deviceId;\n    return this;\n  }\n\n  advanced(advanced: Array<MediaTrackConstraintSet>) {\n    this._advanced = advanced;\n    return this;\n  }\n\n  build() {\n    return new HMSVideoTrackSettings(\n      this._width,\n      this._height,\n      this._codec,\n      this._maxFramerate,\n      this._deviceId,\n      this._advanced,\n      this._maxBitrate,\n    );\n  }\n}\n\nexport class HMSVideoTrackSettings implements IHMSVideoTrackSettings, IAnalyticsPropertiesProvider {\n  readonly width?: number;\n  readonly height?: number;\n  readonly codec?: HMSVideoCodec;\n  readonly maxFramerate?: number;\n  readonly maxBitrate?: number;\n  readonly deviceId?: string;\n  readonly advanced?: Array<MediaTrackConstraintSet>;\n\n  constructor(\n    width?: number,\n    height?: number,\n    codec?: HMSVideoCodec,\n    maxFramerate?: number,\n    deviceId?: string | undefined,\n    advanced?: Array<MediaTrackConstraintSet>,\n    maxBitrate?: number,\n  ) {\n    this.width = width;\n    this.height = height;\n    this.codec = codec;\n    this.maxFramerate = maxFramerate;\n    this.maxBitrate = maxBitrate;\n    this.deviceId = deviceId;\n    this.advanced = advanced;\n  }\n\n  toConstraints(isScreenShare?: boolean): MediaTrackConstraints {\n    let dimensionConstraintKey = 'ideal';\n    if (isScreenShare) {\n      dimensionConstraintKey = 'max';\n    }\n    return {\n      width: { [dimensionConstraintKey]: this.width },\n      height: { [dimensionConstraintKey]: this.height },\n      frameRate: this.maxFramerate,\n      deviceId: this.deviceId,\n    };\n  }\n\n  toAnalyticsProperties() {\n    return {\n      width: this.width,\n      height: this.height,\n      video_bitrate: this.maxBitrate,\n      framerate: this.maxFramerate,\n      video_codec: this.codec,\n    };\n  }\n}\n", "import { HMSAudioTrackSettings, HMSAudioTrackSettingsBuilder } from './HMSAudioTrackSettings';\nimport { HMSVideoTrackSettings, HMSVideoTrackSettingsBuilder } from './HMSVideoTrackSettings';\nimport { IAnalyticsPropertiesProvider } from '../../analytics/IAnalyticsPropertiesProvider';\nimport { ErrorFactory, HMSAction } from '../../error/ErrorFactory';\n\nexport class HMSTrackSettingsBuilder {\n  private _video: HMSVideoTrackSettings | null = new HMSVideoTrackSettingsBuilder().build();\n  private _audio: HMSAudioTrackSettings | null = new HMSAudioTrackSettingsBuilder().build();\n  private _screen: HMSVideoTrackSettings | null = new HMSVideoTrackSettingsBuilder().build();\n  private _simulcast = false;\n\n  video(video: HMSVideoTrackSettings | null) {\n    this._video = video;\n    return this;\n  }\n\n  audio(audio: HMSAudioTrackSettings | null) {\n    this._audio = audio;\n    return this;\n  }\n\n  screen(screen: HMSVideoTrackSettings | null) {\n    this._screen = screen;\n    return this;\n  }\n\n  simulcast(enabled: boolean) {\n    this._simulcast = enabled;\n    return this;\n  }\n\n  build() {\n    if (this._audio === null && this._video === null) {\n      throw ErrorFactory.TracksErrors.NothingToReturn(HMSAction.TRACK);\n    }\n\n    if (this._video === null && this._simulcast) {\n      throw ErrorFactory.TracksErrors.InvalidVideoSettings(\n        HMSAction.TRACK,\n        'Cannot enable simulcast when no video settings are provided',\n      );\n    }\n\n    return new HMSTrackSettings(this._video, this._audio, this._simulcast, this._screen || undefined);\n  }\n}\n\nexport class HMSTrackSettings implements IAnalyticsPropertiesProvider {\n  readonly video: HMSVideoTrackSettings | null | undefined;\n  readonly audio: HMSAudioTrackSettings | null | undefined;\n  readonly screen: HMSVideoTrackSettings | null;\n  readonly simulcast: boolean;\n\n  constructor(\n    video: HMSVideoTrackSettings | null | undefined,\n    audio: HMSAudioTrackSettings | null | undefined,\n    simulcast: boolean,\n    screen: HMSVideoTrackSettings | null = null,\n  ) {\n    this.video = video;\n    this.audio = audio;\n    this.simulcast = simulcast;\n    this.screen = screen;\n  }\n\n  toAnalyticsProperties() {\n    let properties = {\n      audio_enabled: this.audio !== null,\n      video_enabled: this.video !== null,\n    };\n\n    if (this.audio) {\n      properties = { ...this.audio.toAnalyticsProperties(), ...properties };\n    }\n\n    if (this.video) {\n      properties = { ...this.video.toAnalyticsProperties(), ...properties };\n    }\n\n    return properties;\n  }\n}\n", "import { HMSTrack } from '../tracks/HMSTrack';\n\nexport default class HMSMediaStream {\n  readonly nativeStream: MediaStream;\n  readonly id: string;\n\n  readonly tracks = new Array<HMSTrack>();\n\n  constructor(nativeStream: MediaStream) {\n    this.nativeStream = nativeStream;\n    this.id = nativeStream.id;\n  }\n}\n", "export const stringifyMediaStreamTrack = (track: MediaStreamTrack) => {\n  if (!track) {\n    return '';\n  }\n  return `{\n    trackId: ${track.id};\n    kind: ${track.kind};\n    enabled: ${track.enabled};\n    muted: ${track.muted};\n    readyState: ${track.readyState};\n  }`;\n};\n", "import { HMSTrackType } from './HMSTrackType';\nimport { stringifyMediaStreamTrack } from '../../utils/json';\nimport HMSLogger from '../../utils/logger';\nimport HMSMediaStream from '../streams/HMSMediaStream';\n\nexport type HMSTrackSource = 'regular' | 'screen' | 'plugin' | 'audioplaylist' | 'videoplaylist' | string;\n\nexport abstract class HMSTrack {\n  /**\n   * @internal\n   */\n  readonly stream: HMSMediaStream;\n  source?: HMSTrackSource;\n  peerId?: string;\n\n  /**\n   * @internal to print as a helpful identifier alongside logs\n   */\n  logIdentifier = '';\n\n  /** The native mediastream track, for local, this changes on mute/unmute(for video),\n   * and on device change.\n   * @internal */\n  nativeTrack: MediaStreamTrack;\n\n  /**\n   * Firefox doesn't respect the track id as sent from the backend when calling peerconnection.ontrack callback. This\n   * breaks correlation of future track updates from backend. So we're storing the sdp track id as present in the\n   * original offer along with the track as well and will let this override the native track id for any correlation\n   * purpose.\n   * This applies for remote tracks only.\n   * @internal */\n  private sdpTrackId?: string;\n\n  /**\n   * @internal\n   * The local track id is changed on mute/unmute or when device id changes, this is abstracted as an internal\n   * detail of HMSTrack and the variable is used for this enacapsulation where the first track id is remembered\n   * and treated as the fixed track id for this HMSTrack. This simplifies things for the user of the sdk who\n   * do not have to worry about changing track IDs.\n   * This applies for local tracks only.\n   */\n  private firstTrackId?: string;\n\n  abstract readonly type: HMSTrackType;\n\n  public get enabled(): boolean {\n    return this.nativeTrack.enabled;\n  }\n\n  /**\n   * firstTrackId => encapsulates change in local track ids\n   * sdpTrackId => fixes remote track updates correlation on firefox\n   */\n  public get trackId(): string {\n    return this.firstTrackId || this.sdpTrackId || this.nativeTrack.id;\n  }\n\n  getMediaTrackSettings(): MediaTrackSettings {\n    return this.nativeTrack.getSettings();\n  }\n\n  async setEnabled(value: boolean): Promise<void> {\n    this.nativeTrack.enabled = value;\n  }\n\n  protected constructor(stream: HMSMediaStream, track: MediaStreamTrack, source?: HMSTrackSource) {\n    this.stream = stream;\n    this.nativeTrack = track;\n    this.source = source;\n  }\n\n  /**\n   * @internal\n   */\n  setSdpTrackId(sdpTrackId: string) {\n    this.sdpTrackId = sdpTrackId;\n  }\n\n  /**\n   * @internal\n   */\n  protected setFirstTrackId(trackId: string) {\n    this.firstTrackId = trackId;\n  }\n\n  /**\n   * @internal\n   * take care of -\n   * 1. https://bugs.chromium.org/p/chromium/issues/detail?id=1232649\n   * 2. stopping any tracks\n   * 3. plugins related cleanups and stopping\n   */\n  cleanup() {\n    HMSLogger.d('[HMSTrack]', 'Stopping track', this.toString());\n    this.nativeTrack?.stop();\n  }\n\n  toString() {\n    return `{\n      streamId: ${this.stream.id};\n      peerId: ${this.peerId};\n      trackId: ${this.trackId};\n      logIdentifier: ${this.logIdentifier};\n      source: ${this.source};\n      enabled: ${this.enabled};\n      nativeTrack: ${stringifyMediaStreamTrack(this.nativeTrack)};\n    }`;\n  }\n}\n", "export enum HMSTrackType {\n  AUDIO = 'audio',\n  VIDEO = 'video',\n}\n", "import HMSMediaStream from './HMSMediaStream';\nimport HMSSubscribeConnection from '../../connection/subscribe/subscribeConnection';\nimport { HMSSimulcastLayer } from '../../interfaces';\nimport HMSLogger from '../../utils/logger';\n\n/** @internal */\nexport default class HMSRemoteStream extends HMSMediaStream {\n  private readonly connection: HMSSubscribeConnection;\n  private audio = true;\n  private video = HMSSimulcastLayer.NONE;\n\n  constructor(nativeStream: MediaStream, connection: HMSSubscribeConnection) {\n    super(nativeStream);\n    this.connection = connection;\n  }\n\n  async setAudio(enabled: boolean, trackId: string, identifier?: string) {\n    if (this.audio === enabled) {\n      return;\n    }\n\n    this.audio = enabled;\n    HMSLogger.d(`[Remote stream] ${identifier || ''} ${this.id}`, `subscribing audio - ${this.audio}`);\n    await this.connection.sendOverApiDataChannelWithResponse({\n      params: {\n        subscribed: this.audio,\n        track_id: trackId,\n      },\n      method: 'prefer-audio-track-state',\n    });\n  }\n\n  /**\n   * Sets the video layer after receiving new state from SFU. This is used when server side subscribe\n   * degradation is ON.\n   * @param layer is simulcast layer to be set\n   * @param identifier is stream identifier to be printed in logs\n   */\n  setVideoLayerLocally(layer: HMSSimulcastLayer, identifier: string, source: string) {\n    this.video = layer;\n    HMSLogger.d(`[Remote stream] ${identifier} - ${this.id}`, `source: ${source} Setting layer field to - ${layer}`);\n  }\n\n  /**\n   * Sets the video layer and updates the track state to SFU via api datachannel. This is used when client\n   * side subscribe degradation is ON or client unsubscribes the current track.\n   * @param layer is simulcast layer to be set\n   * @param identifier is stream identifier to be printed in logs\n   */\n  setVideoLayer(layer: HMSSimulcastLayer, trackId: string, identifier: string, source: string) {\n    this.setVideoLayerLocally(layer, identifier, source);\n    HMSLogger.d(`[Remote stream] ${identifier} - ${this.id}`, `request ${layer} layer`);\n    return this.connection.sendOverApiDataChannelWithResponse({\n      params: {\n        max_spatial_layer: this.video,\n        track_id: trackId,\n      },\n      method: 'prefer-video-track-state',\n    });\n  }\n\n  /**\n   * @deprecated\n   * @returns {HMSSimulcastLayer}\n   */\n  getSimulcastLayer() {\n    return this.video;\n  }\n\n  getVideoLayer() {\n    return this.video;\n  }\n\n  isAudioSubscribed() {\n    return this.audio;\n  }\n}\n", "import { HMSTrack, HMSTrackSource } from './HMSTrack';\nimport { HMSTrackType } from './HMSTrackType';\nimport HMSLogger from '../../utils/logger';\nimport HMSMediaStream from '../streams/HMSMediaStream';\nimport HMSRemoteStream from '../streams/HMSRemoteStream';\n\nexport class HMSAudioTrack extends HMSTrack {\n  readonly type: HMSTrackType = HMSTrackType.AUDIO;\n  private audioElement: HTMLAudioElement | null = null;\n  private outputDevice?: MediaDeviceInfo;\n\n  constructor(stream: HMSMediaStream, track: MediaStreamTrack, source?: string) {\n    super(stream, track, source as HMSTrackSource);\n    if (track.kind !== 'audio') {\n      throw new Error(\"Expected 'track' kind = 'audio'\");\n    }\n  }\n\n  getVolume() {\n    return this.audioElement ? this.audioElement.volume * 100 : null;\n  }\n\n  async setVolume(value: number) {\n    if (value < 0 || value > 100) {\n      throw Error('Please pass a valid number between 0-100');\n    }\n    // Don't subscribe to audio when volume is 0\n    await this.subscribeToAudio(value === 0 ? false : this.enabled);\n    if (this.audioElement) {\n      this.audioElement.volume = value / 100;\n    }\n  }\n\n  setAudioElement(element: HTMLAudioElement | null) {\n    this.audioElement = element;\n  }\n\n  /**\n   * @internal\n   * @returns {HTMLAudioElement | null}\n   */\n  getAudioElement(): HTMLAudioElement | null {\n    return this.audioElement;\n  }\n\n  getOutputDevice() {\n    return this.outputDevice;\n  }\n\n  cleanup() {\n    super.cleanup();\n    if (this.audioElement) {\n      this.audioElement.srcObject = null;\n      this.audioElement.remove();\n      this.audioElement = null;\n    }\n  }\n\n  async setOutputDevice(device: MediaDeviceInfo) {\n    if (!this.audioElement) {\n      HMSLogger.d('audio-track', 'no audio element to set output');\n      return;\n    }\n    try {\n      // @ts-ignore\n      if (typeof this.audioElement.setSinkId === 'function') {\n        // @ts-ignore\n        await this.audioElement?.setSinkId(device.deviceId);\n        this.outputDevice = device;\n      }\n    } catch (error) {\n      HMSLogger.d('audio-track', error);\n    }\n  }\n\n  protected async subscribeToAudio(value: boolean) {\n    if (this.stream instanceof HMSRemoteStream) {\n      await this.stream.setAudio(value, this.trackId, this.logIdentifier);\n    }\n  }\n}\n", "import { SelectedDevices } from './DeviceManager';\nimport { DeviceMap } from '../interfaces';\nimport { LocalStorage } from '../utils/local-storage';\nimport HMSLogger from '../utils/logger';\n\ntype DeviceInfo = { deviceId?: string; groupId?: string };\n/**\n * This class is to manage storing and retrieving selected devices\n * from localstorage\n * @internal\n */\nclass DeviceStorage {\n  private storage = new LocalStorage<SelectedDevices>('hms-device-selection');\n  private remember = false;\n  private devices?: DeviceMap;\n  private readonly TAG = '[HMSDeviceStorage]';\n\n  setDevices(devices: DeviceMap) {\n    this.devices = devices;\n  }\n\n  rememberDevices(value: boolean) {\n    this.remember = value;\n  }\n\n  /**\n   * This will update the passed in type value in storage\n   * @param {string} type - One of audioInput | videoInput | audioOutput\n   * @param {DeviceInfo} param\n   * @returns {void}\n   */\n  updateSelection(type: 'audioInput' | 'videoInput' | 'audioOutput', { deviceId, groupId }: DeviceInfo) {\n    if (!this.devices || !this.remember) {\n      return;\n    }\n    const newSelection = this.devices[type].find(device => this.isSame({ deviceId, groupId }, device));\n    if (!newSelection) {\n      HMSLogger.w(this.TAG, `Could not find device with deviceId: ${deviceId}, groupId: ${groupId}`);\n      return;\n    }\n    const selectedDevices = this.storage.get() || {};\n    if (type === 'audioOutput') {\n      selectedDevices[type] = newSelection as MediaDeviceInfo;\n    } else {\n      selectedDevices[type] = newSelection as MediaDeviceInfo;\n    }\n    this.storage.set(selectedDevices);\n  }\n\n  getSelection() {\n    if (!this.remember) {\n      return undefined;\n    }\n    return this.storage.get();\n  }\n\n  cleanup() {\n    this.remember = false;\n    this.devices = undefined;\n  }\n\n  private isSame(current: DeviceInfo, device: DeviceInfo) {\n    // Safari doesn't give groupId from nativeTrack. Check if groupId's match or current groupId is not present\n    return current.deviceId === device.deviceId && (current.groupId === device.groupId || !current.groupId);\n  }\n}\n\nexport const DeviceStorageManager = new DeviceStorage();\n", "/**\n * A plugin implementing this interface can be registered with HMSLocalAudioTrack to transform, process or\n * analyze the local audio track.These can include applications like background noise removal, speech commands, live\n * analysis of audio etc. The below functions are required for the sdk to properly use the plugin, usually\n * the plugin would also be exposing some public functions of its own for the UI to control its working.\n */\n\nexport interface HMSAudioPlugin {\n  /**\n   * This function will be called by the SDK for audio track which the plugin needs to process.\n   * The reason audio context is also part of the interface is that it's recommeneded to reuse on audio context\n   * instead of creating new for every use - https://developer.mozilla.org/en-US/docs/Web/API/AudioContext\n   */\n  processAudioTrack(ctx: AudioContext, source: AudioNode): Promise<AudioNode>;\n\n  /**\n   * This function will be called before the call to init, it is used to check whether the plugin supports current\n   * OS, browser and audio device or not. An error object will be thrown back to the user if they try to use an unsupported plugin.\n   */\n  checkSupport(ctx?: AudioContext): HMSPluginSupportResult;\n\n  /**\n   * @deprecated. Will be deleted in future updates. Use checkSupport instead.\n   */\n  isSupported(): boolean;\n\n  /**\n   * This function will be called in the beginning for initialization which may include tasks like setting up\n   * variables, loading ML models etc. This can be used by a plugin to ensure it's prepared at the time\n   * processAudio is called.\n   */\n  init(): Promise<void> | void;\n\n  /**\n   * The name is meant to uniquely specify a plugin instance. This will be used to track number of plugins\n   * added to the track, and same name won't be allowed twice.\n   */\n  getName(): string;\n\n  /**\n   This sets the Plugin type @see HMSAudioPluginType, processing will happen\n   based on the type of plugin\n   */\n  getPluginType(): HMSAudioPluginType;\n  /*\n   * the plugin can use this function to dispose off its resources. It'll be called when the plugin instance is\n   * no longer needed at the end.\n   */\n  stop(): void;\n}\n\n/**\n * Specifies the type of the plugin a transforming plugin will get an output audio node to give the resulting\n * transformation. While an analyzing plugin will only be passed the input node.\n * For analyse plugins, you can return the source node passed to plugin.processTrack to not modify anything\n */\nexport enum HMSAudioPluginType {\n  TRANSFORM = 'TRANSFORM',\n  ANALYZE = 'ANALYZE',\n}\n\nexport interface HMSPluginSupportResult {\n  isSupported: boolean;\n  errType?: HMSPluginUnsupportedTypes;\n  errMsg?: string;\n}\n\nexport enum HMSPluginUnsupportedTypes {\n  PLATFORM_NOT_SUPPORTED = 'PLATFORM_NOT_SUPPORTED',\n  DEVICE_NOT_SUPPORTED = 'DEVICE_NOT_SUPPORTED',\n}\n", "import AnalyticsEvent from './AnalyticsEvent';\nimport { AnalyticsEventLevel } from './AnalyticsEventLevel';\nimport { HMSException } from '../error/HMSException';\n\nexport default class MediaPluginsAnalyticsFactory {\n  static failure(pluginName: string, error: HMSException) {\n    const name = 'mediaPlugin.failed';\n    const level = AnalyticsEventLevel.ERROR;\n    const properties = { plugin_name: pluginName, ...error.toAnalyticsProperties() };\n\n    return new AnalyticsEvent({ name, level, properties });\n  }\n\n  static audioPluginFailure(pluginName: string, sampleRate: number, error: HMSException) {\n    const name = 'mediaPlugin.failed';\n    const level = AnalyticsEventLevel.ERROR;\n    const properties = { plugin_name: pluginName, sampleRate: sampleRate, ...error.toAnalyticsProperties() };\n\n    return new AnalyticsEvent({ name, level, properties });\n  }\n\n  static audioPluginStats({\n    pluginName,\n    duration,\n    loadTime,\n    sampleRate,\n  }: {\n    pluginName: string;\n    duration: number;\n    loadTime: number;\n    sampleRate: number;\n  }) {\n    const name = 'mediaPlugin.stats';\n    const level = AnalyticsEventLevel.INFO;\n    const properties = {\n      plugin_name: pluginName,\n      duration: duration,\n      load_time: loadTime,\n      sampleRate: sampleRate,\n    };\n    return new AnalyticsEvent({ name, level, properties });\n  }\n\n  static stats({\n    pluginName,\n    duration,\n    loadTime,\n    avgPreProcessingTime,\n    avgProcessingTime,\n    inputFrameRate,\n    pluginFrameRate,\n  }: {\n    pluginName: string;\n    duration: number;\n    loadTime: number;\n    avgPreProcessingTime: number;\n    avgProcessingTime: number;\n    inputFrameRate: number;\n    pluginFrameRate: number;\n  }) {\n    const name = 'mediaPlugin.stats';\n    const level = AnalyticsEventLevel.INFO;\n    const properties = {\n      plugin_name: pluginName,\n      duration: duration,\n      load_time: loadTime,\n      avg_preprocessing_time: avgPreProcessingTime,\n      avg_processing_time: avgProcessingTime,\n      input_frame_rate: inputFrameRate,\n      plugin_frame_rate: pluginFrameRate,\n    };\n    return new AnalyticsEvent({ name, level, properties });\n  }\n}\n", "import MediaPluginsAnalyticsFactory from '../../analytics/MediaPluginsAnalyticsFactory';\nimport { ErrorFactory, HMSAction } from '../../error/ErrorFactory';\nimport { HMSException } from '../../error/HMSException';\nimport { EventBus } from '../../events/EventBus';\nimport HMSLogger from '../../utils/logger';\n\nexport class AudioPluginsAnalytics {\n  private readonly TAG = '[AudioPluginsAnalytics]';\n  private readonly initTime: Record<string, number>;\n  private readonly addedTimestamps: Record<string, number>;\n  private readonly pluginAdded: Record<string, boolean>;\n  private readonly pluginSampleRate: Record<string, number>;\n\n  constructor(private eventBus: EventBus) {\n    this.initTime = {};\n    this.addedTimestamps = {};\n    this.pluginAdded = {};\n    this.pluginSampleRate = {};\n  }\n\n  added(name: string, sampleRate: number) {\n    this.pluginAdded[name] = true;\n    this.addedTimestamps[name] = Date.now();\n    this.initTime[name] = 0;\n    this.pluginSampleRate[name] = sampleRate;\n  }\n\n  removed(name: string) {\n    //send stats\n    if (this.pluginAdded[name]) {\n      const stats = {\n        pluginName: name,\n        // duration in seconds\n        duration: Math.floor((Date.now() - this.addedTimestamps[name]) / 1000),\n        loadTime: this.initTime[name],\n        sampleRate: this.pluginSampleRate[name],\n      };\n      //send stats\n      this.eventBus.analytics.publish(MediaPluginsAnalyticsFactory.audioPluginStats(stats));\n      //clean the plugin details\n      this.clean(name);\n    }\n  }\n\n  failure(name: string, error: HMSException) {\n    // send failure event\n    if (this.pluginAdded[name]) {\n      this.eventBus.analytics.publish(\n        MediaPluginsAnalyticsFactory.audioPluginFailure(name, this.pluginSampleRate[name], error),\n      );\n      //clean the plugin details\n      this.clean(name);\n    }\n  }\n\n  async initWithTime<T>(name: string, initFn: () => Promise<T>) {\n    if (this.initTime[name]) {\n      HMSLogger.i(this.TAG, `Plugin Already loaded ${name}, time it took: ${this.initTime[name]}`);\n      return;\n    }\n    let time: number | undefined = undefined;\n    try {\n      time = await this.timeInMs(initFn);\n      HMSLogger.i(this.TAG, `Time taken for Plugin ${name} initialization : ${time}`);\n    } catch (e) {\n      //Failed during initialization of plugin(model loading etc...)\n      const err = ErrorFactory.MediaPluginErrors.InitFailed(\n        HMSAction.AUDIO_PLUGINS,\n        `failed during initialization of plugin${(e as Error).message || e}`,\n      );\n      HMSLogger.e(this.TAG, err);\n      this.failure(name, err);\n      throw err;\n    }\n    if (time) {\n      this.initTime[name] = time;\n    }\n  }\n\n  private async timeInMs<T>(fn: () => Promise<T>): Promise<number> {\n    const start = Date.now();\n    await fn();\n    return Math.floor(Date.now() - start);\n  }\n\n  private clean(name: string) {\n    delete this.addedTimestamps[name];\n    delete this.initTime[name];\n    delete this.pluginAdded[name];\n    delete this.pluginSampleRate[name];\n  }\n}\n", "import { AudioPluginsAnalytics } from './AudioPluginsAnalytics';\nimport { HMSAudioPlugin, HMSPluginUnsupportedTypes } from './HMSAudioPlugin'; //HMSAudioPluginType\nimport { ErrorFactory, HMSAction } from '../../error/ErrorFactory';\nimport { EventBus } from '../../events/EventBus';\nimport { HMSLocalAudioTrack } from '../../media/tracks';\nimport HMSLogger from '../../utils/logger';\n\nconst DEFAULT_SAMPLE_RATE = 48000;\n\n//Handling sample rate error in case of firefox\nconst checkBrowserSupport = () => {\n  return navigator.userAgent.indexOf('Firefox') !== -1;\n};\n\n/**\n * This class manages applying different plugins on a local audio track. Plugins which need to modify the audio\n * are called in the order they were added. Plugins which do not need to modify the audio are called\n * with the original input.\n *\n * Concepts -\n * Audio Plugin - A module which can take in input audio, do some processing on it and return an AudioNode\n *\n * For Each Plugin, an AudioNode will be created and the source will be created from local audio track.\n * Each Audio node will be connected in the following order\n * source -> first plugin -> second plugin -> third plugin .. so on\n * @see HMSAudioPlugin\n */\nexport class HMSAudioPluginsManager {\n  private readonly TAG = '[AudioPluginsManager]';\n  private readonly hmsTrack: HMSLocalAudioTrack;\n  // Map maintains the insertion order\n  private readonly pluginsMap: Map<string, HMSAudioPlugin>;\n  private audioContext?: AudioContext;\n\n  private sourceNode?: MediaStreamAudioSourceNode;\n  private destinationNode?: MediaStreamAudioDestinationNode;\n  private prevAudioNode?: any;\n  private analytics: AudioPluginsAnalytics;\n  // This will replace the native track in peer connection when plugins are enabled\n  private outputTrack?: MediaStreamTrack;\n  private pluginAddInProgress = false;\n\n  constructor(track: HMSLocalAudioTrack, eventBus: EventBus) {\n    this.hmsTrack = track;\n    this.pluginsMap = new Map();\n    this.analytics = new AudioPluginsAnalytics(eventBus);\n    this.createAudioContext();\n  }\n\n  getPlugins(): string[] {\n    return Array.from(this.pluginsMap.keys());\n  }\n\n  async addPlugin(plugin: HMSAudioPlugin) {\n    const name = plugin.getName?.();\n    if (!name) {\n      HMSLogger.w('no name provided by the plugin');\n      return;\n    }\n    if (this.pluginAddInProgress) {\n      const err = ErrorFactory.MediaPluginErrors.AddAlreadyInProgress(\n        HMSAction.AUDIO_PLUGINS,\n        'Add Plugin is already in Progress',\n      );\n      this.analytics.added(name, this.audioContext!.sampleRate);\n      this.analytics.failure(name, err);\n      HMSLogger.w(\"can't add another plugin when previous add is in progress\");\n      throw err;\n    }\n\n    this.pluginAddInProgress = true;\n\n    try {\n      await this.addPluginInternal(plugin);\n    } finally {\n      this.pluginAddInProgress = false;\n    }\n  }\n\n  // eslint-disable-next-line complexity\n  private async addPluginInternal(plugin: HMSAudioPlugin) {\n    const name = plugin.getName?.();\n    if (this.pluginsMap.get(name)) {\n      HMSLogger.w(this.TAG, `plugin - ${name} already added.`);\n      return;\n    }\n\n    await this.validateAndThrow(name, plugin);\n\n    try {\n      if (this.pluginsMap.size === 0) {\n        await this.initAudioNodes();\n      } else if (this.prevAudioNode) {\n        // Previous node will be connected to destination. Disconnect that\n        this.prevAudioNode.disconnect();\n      }\n      this.analytics.added(name, this.audioContext!.sampleRate);\n      await this.analytics.initWithTime(name, async () => plugin.init());\n      this.pluginsMap.set(name, plugin);\n      await this.processPlugin(plugin);\n      await this.connectToDestination();\n    } catch (err) {\n      HMSLogger.e(this.TAG, 'failed to add plugin', err);\n      throw err;\n    }\n  }\n\n  validatePlugin(plugin: HMSAudioPlugin) {\n    return plugin.checkSupport(this.audioContext);\n  }\n\n  async validateAndThrow(name: string, plugin: HMSAudioPlugin) {\n    const result = this.validatePlugin(plugin);\n    if (result.isSupported) {\n      HMSLogger.i(this.TAG, `plugin is supported,- ${plugin.getName()}`);\n    } else {\n      //Needed to re-add in the reprocess case, to send error message in case of failure\n      this.analytics.added(name, this.audioContext!.sampleRate);\n      if (result.errType === HMSPluginUnsupportedTypes.PLATFORM_NOT_SUPPORTED) {\n        const err = ErrorFactory.MediaPluginErrors.PlatformNotSupported(\n          HMSAction.AUDIO_PLUGINS,\n          'platform not supported, see docs',\n        );\n        this.analytics.failure(name, err);\n        await this.cleanup();\n        throw err;\n      } else if (result.errType === HMSPluginUnsupportedTypes.DEVICE_NOT_SUPPORTED) {\n        const err = ErrorFactory.MediaPluginErrors.DeviceNotSupported(\n          HMSAction.AUDIO_PLUGINS,\n          'audio device not supported, see docs',\n        );\n        this.analytics.failure(name, err);\n        await this.cleanup();\n        throw err;\n      }\n    }\n  }\n\n  async removePlugin(plugin: HMSAudioPlugin) {\n    await this.removePluginInternal(plugin);\n    if (this.pluginsMap.size === 0) {\n      // remove all previous nodes\n      await this.cleanup();\n      HMSLogger.i(this.TAG, `No plugins left, stopping plugins loop`);\n      await this.hmsTrack.setProcessedTrack(undefined);\n    } else {\n      // Reprocess the remaining plugins again because there is no way to connect\n      // the source of the removed plugin to destination of removed plugin\n      await this.reprocessPlugins();\n    }\n  }\n\n  async cleanup() {\n    for (const plugin of this.pluginsMap.values()) {\n      await this.removePluginInternal(plugin);\n    }\n    await this.hmsTrack.setProcessedTrack(undefined);\n    //disconnect nodes, stop track\n    this.sourceNode?.disconnect();\n    this.prevAudioNode?.disconnect();\n    this.outputTrack?.stop();\n\n    // reset all variables\n    this.sourceNode = undefined;\n    this.destinationNode = undefined;\n    this.prevAudioNode = undefined;\n    this.outputTrack = undefined;\n  }\n\n  //Keeping it separate since we are initializing context only once\n  async closeContext() {\n    this.audioContext?.close();\n    this.audioContext = undefined;\n  }\n\n  async reprocessPlugins() {\n    if (this.pluginsMap.size === 0 || !this.sourceNode) {\n      return;\n    }\n    const plugins = Array.from(this.pluginsMap.values()); // make a copy of plugins\n    await this.cleanup();\n    await this.initAudioNodes();\n    for (const plugin of plugins) {\n      await this.addPlugin(plugin);\n    }\n  }\n\n  private async initAudioNodes() {\n    if (this.audioContext) {\n      if (!this.sourceNode) {\n        const audioStream = new MediaStream([this.hmsTrack.nativeTrack]);\n        this.sourceNode = this.audioContext.createMediaStreamSource(audioStream);\n      }\n      if (!this.destinationNode) {\n        this.destinationNode = this.audioContext.createMediaStreamDestination();\n        this.outputTrack = this.destinationNode.stream.getAudioTracks()[0];\n        try {\n          await this.hmsTrack.setProcessedTrack(this.outputTrack);\n        } catch (err) {\n          HMSLogger.e(this.TAG, 'error in setting processed track', err);\n          throw err;\n        }\n      }\n    }\n  }\n\n  private async processPlugin(plugin: HMSAudioPlugin) {\n    try {\n      const currentNode = await plugin.processAudioTrack(\n        this.audioContext!, // it is always present at this point\n        this.prevAudioNode || this.sourceNode,\n      );\n      if (this.prevAudioNode) {\n        // if previous node was present while adding this plugin\n        // it is disconnected from destination, connect the previous node to\n        // to the current node\n        this.prevAudioNode.connect(currentNode);\n      }\n      this.prevAudioNode = currentNode;\n    } catch (err) {\n      const name = plugin.getName();\n      //TODO error happened on processing of plugin notify UI\n      HMSLogger.e(this.TAG, `error in processing plugin ${name}`, err);\n      //remove plugin from loop and stop analytics for it\n      await this.removePluginInternal(plugin);\n    }\n  }\n\n  private async connectToDestination() {\n    try {\n      if (this.prevAudioNode && this.destinationNode && this.prevAudioNode.context === this.destinationNode.context) {\n        this.prevAudioNode.connect(this.destinationNode);\n      }\n    } catch (err) {\n      HMSLogger.e(this.TAG, 'error in connecting to destination node', err);\n    }\n  }\n\n  private async removePluginInternal(plugin: HMSAudioPlugin) {\n    const name = plugin.getName?.();\n    if (!this.pluginsMap.get(name)) {\n      HMSLogger.w(this.TAG, `plugin - ${name} not found to remove.`);\n      return;\n    }\n    HMSLogger.i(this.TAG, `removing plugin ${name}`);\n    this.pluginsMap.delete(name);\n    plugin.stop();\n    this.analytics.removed(name);\n  }\n\n  private createAudioContext() {\n    if (!this.audioContext) {\n      if (checkBrowserSupport()) {\n        /**\n        Not setting default sample rate for firefox since connecting\n        audio nodes from context with different sample rate is not\n        supported in firefox\n */\n        this.audioContext = new AudioContext();\n      } else {\n        this.audioContext = new AudioContext({ sampleRate: DEFAULT_SAMPLE_RATE });\n      }\n    }\n  }\n}\n", "import { BuildGetMediaError, HMSGetMediaActions } from '../error/utils';\nimport { HMSAudioTrackSettings, HMSVideoTrackSettings } from '../media/settings';\n\nexport async function getAudioTrack(settings: HMSAudioTrackSettings): Promise<MediaStreamTrack> {\n  try {\n    const stream = await navigator.mediaDevices.getUserMedia({\n      audio: settings ? settings.toConstraints() : false,\n    });\n    return stream.getAudioTracks()[0];\n  } catch (err) {\n    throw BuildGetMediaError(err as Error, HMSGetMediaActions.AUDIO);\n  }\n}\n\nexport async function getVideoTrack(settings: HMSVideoTrackSettings): Promise<MediaStreamTrack> {\n  try {\n    const stream = await navigator.mediaDevices.getUserMedia({\n      video: settings ? settings.toConstraints() : false,\n    });\n    return stream.getVideoTracks()[0];\n  } catch (err) {\n    throw BuildGetMediaError(err as Error, HMSGetMediaActions.VIDEO);\n  }\n}\n\n// To differentiate between normal track and empty track.\nexport function isEmptyTrack(track: MediaStreamTrack) {\n  // Firefox gives '' as label for empty track(created from audio context)\n  return 'canvas' in track || track.label === 'MediaStreamAudioDestinationNode' || track.label === '';\n}\n", "import HMSLogger from './logger';\nimport { BuildGetMediaError, HMSGetMediaActions } from '../error/utils';\n\nexport async function getLocalStream(constraints: MediaStreamConstraints): Promise<MediaStream> {\n  try {\n    const stream = await navigator.mediaDevices.getUserMedia(constraints);\n    return stream;\n  } catch (err) {\n    throw BuildGetMediaError(err as Error, HMSGetMediaActions.AV);\n  }\n}\n\nexport async function getLocalScreen(constraints: MediaStreamConstraints['video']): Promise<MediaStream> {\n  try {\n    // @ts-ignore [https://github.com/microsoft/TypeScript/issues/33232]\n    const stream = await navigator.mediaDevices.getDisplayMedia({ video: constraints, audio: false });\n    return stream;\n  } catch (err) {\n    throw BuildGetMediaError(err as Error, HMSGetMediaActions.SCREEN);\n  }\n}\n\ninterface MediaDeviceGroups {\n  audioinput: MediaDeviceInfo[];\n  audiooutput: MediaDeviceInfo[];\n  videoinput: MediaDeviceInfo[];\n}\n\nexport async function getLocalDevices(): Promise<MediaDeviceGroups> {\n  try {\n    const devices = await navigator.mediaDevices.enumerateDevices();\n    const deviceGroups: MediaDeviceGroups = {\n      audioinput: [],\n      audiooutput: [],\n      videoinput: [],\n    };\n    devices.forEach(device => deviceGroups[device.kind].push(device));\n    return deviceGroups;\n  } catch (err) {\n    throw BuildGetMediaError(err as Error, HMSGetMediaActions.AV);\n  }\n}\n\nexport interface HMSAudioContext {\n  audioContext: AudioContext | null;\n  getAudioContext: () => AudioContext;\n  resumeContext: () => Promise<void>;\n}\n\nexport const HMSAudioContextHandler: HMSAudioContext = {\n  audioContext: null,\n  getAudioContext() {\n    if (!this.audioContext) {\n      this.audioContext = new AudioContext();\n    }\n    return this.audioContext;\n  },\n  async resumeContext() {\n    try {\n      return await this.getAudioContext().resume();\n    } catch (error) {\n      HMSLogger.e('AudioContext', error);\n    }\n  },\n};\n", "export interface IQueue<T> {\n  size(): number;\n  enqueue(item: T): void;\n  dequeue(): T | undefined;\n}\n\nexport class Queue<T> implements IQueue<T> {\n  protected storage: T[] = [];\n\n  constructor(private capacity: number = Infinity) {}\n\n  size() {\n    return this.storage.length;\n  }\n\n  toList() {\n    return this.storage.slice(0);\n  }\n\n  enqueue(item: T) {\n    if (this.size() === this.capacity) {\n      this.dequeue();\n    }\n    this.storage.push(item);\n  }\n\n  dequeue() {\n    return this.storage.shift();\n  }\n\n  aggregate<R>(aggregationFn: (values: T[]) => R): R {\n    return aggregationFn(this.storage);\n  }\n}\n", "/**\n * Delay for a @see ms amount of time\n * @param ms -- time in milliseconds\n */\nexport function sleep(ms: number): Promise<void> {\n  if (ms < 0) {\n    throw Error('`ms` should be a positive integer');\n  }\n  return new Promise(resolve => setTimeout(resolve, ms));\n}\n\n/**\n * Debounce Fn - Function to limit the number of executions of the passed in\n * function in a given time duration\n * @param fn Function to be called\n * @param delay time by which the function execution has to be delayed\n * @returns {void}\n */\nexport function debounce(fn: () => void, delay = 300) {\n  let timer: any | undefined;\n  return function (...args: []) {\n    clearTimeout(timer);\n    timer = undefined;\n    //@ts-ignore\n    //eslint-disable-next-line\n    const context = this;\n    timer = setTimeout(() => {\n      fn.apply(context, args);\n    }, delay);\n  };\n}\n", "import HMSLogger from './logger';\nimport { HMSAudioContextHandler } from './media';\nimport { Queue } from './queue';\nimport { sleep } from './timer-utils';\nimport { HMSInternalEvent } from '../events/HMSInternalEvent';\nimport { HMSLocalAudioTrack } from '../media/tracks';\n\n/** Send update only if audio level is above THRESHOLD */\nconst THRESHOLD = 35;\n\n/** Send update only if audio level is changed by UPDATE_THRESHOLD */\nconst UPDATE_THRESHOLD = 5;\n\nexport interface ITrackAudioLevelUpdate {\n  track: HMSLocalAudioTrack;\n  audioLevel: number;\n}\n\nexport class TrackAudioLevelMonitor {\n  private readonly TAG = '[TrackAudioLevelMonitor]';\n  private audioLevel = 0;\n  private analyserNode?: AnalyserNode;\n  private isMonitored = false;\n  /** Frequency of polling audio level from track */\n  private interval = 100;\n  /** Store past audio levels for this duration */\n  private historyInterval = 700;\n  private history = new Queue<number>(this.historyInterval / this.interval);\n\n  constructor(\n    private track: HMSLocalAudioTrack,\n    private audioLevelEvent: HMSInternalEvent<ITrackAudioLevelUpdate>,\n    private silenceEvent: HMSInternalEvent<{ track: HMSLocalAudioTrack }>,\n  ) {\n    try {\n      const stream = new MediaStream([this.track.nativeTrack]);\n      this.analyserNode = this.createAnalyserNodeForStream(stream);\n    } catch (ex) {\n      HMSLogger.w(this.TAG, 'Unable to initialize AudioContext', ex);\n    }\n  }\n\n  /**\n   * To detect silence we check if the track is unmuted and silent in the current moment\n   * periodically. If the track is found to be silent more than a threshold number of times\n   * we send the event. The threshold number of time is there to reduce the chance of false\n   * positives.\n   */\n  detectSilence = async () => {\n    const tickInterval = 20;\n    const tickThreshold = 50;\n    let silenceCounter = 0;\n\n    while (this.isMonitored) {\n      if (this.track.enabled) {\n        if (this.isSilentThisInstant()) {\n          silenceCounter++;\n          if (silenceCounter > tickThreshold) {\n            this.silenceEvent.publish({ track: this.track });\n            break;\n          }\n        } else {\n          // bail out immediately if sound is found\n          break;\n        }\n      }\n      await sleep(tickInterval);\n    }\n  };\n\n  start() {\n    this.stop();\n    this.isMonitored = true;\n    HMSLogger.d(this.TAG, 'Starting track Monitor', `${this.track}`);\n    this.loop().then(() => HMSLogger.d(this.TAG, 'Stopping track Monitor', `${this.track}`));\n  }\n\n  stop() {\n    if (!this.analyserNode) {\n      HMSLogger.d(this.TAG, 'AudioContext not initialized');\n      return;\n    }\n\n    this.sendAudioLevel(0);\n    this.isMonitored = false;\n  }\n\n  private async loop() {\n    while (this.isMonitored) {\n      this.sendAudioLevel(this.getMaxAudioLevelOverPeriod());\n      await sleep(this.interval);\n    }\n  }\n\n  private sendAudioLevel(audioLevel = 0) {\n    audioLevel = audioLevel > THRESHOLD ? audioLevel : 0;\n    const isSignificantChange = Math.abs(this.audioLevel - audioLevel) > UPDATE_THRESHOLD;\n    if (isSignificantChange) {\n      this.audioLevel = audioLevel;\n      const audioLevelUpdate: ITrackAudioLevelUpdate = { track: this.track, audioLevel: this.audioLevel };\n      this.audioLevelEvent.publish(audioLevelUpdate);\n    }\n  }\n\n  private getMaxAudioLevelOverPeriod() {\n    if (!this.analyserNode) {\n      HMSLogger.d(this.TAG, 'AudioContext not initialized');\n      return;\n    }\n    const newLevel = this.calculateAudioLevel();\n    newLevel !== undefined && this.history.enqueue(newLevel);\n    return this.history.aggregate(values => Math.max(...values));\n  }\n\n  private calculateAudioLevel() {\n    if (!this.analyserNode) {\n      HMSLogger.d(this.TAG, 'AudioContext not initialized');\n      return;\n    }\n\n    const data = new Uint8Array(this.analyserNode.fftSize);\n    this.analyserNode.getByteTimeDomainData(data);\n    const lowest = 0.009;\n    let max = lowest;\n    for (const frequency of data) {\n      max = Math.max(max, (frequency - 128) / 128);\n    }\n    const normalized = (Math.log(lowest) - Math.log(max)) / Math.log(lowest);\n    const percent = Math.ceil(Math.min(Math.max(normalized * 100, 0), 100));\n    return percent;\n  }\n\n  private isSilentThisInstant() {\n    if (!this.analyserNode) {\n      HMSLogger.d(this.TAG, 'AudioContext not initialized');\n      return;\n    }\n\n    const data = new Uint8Array(this.analyserNode.fftSize);\n    this.analyserNode.getByteTimeDomainData(data);\n\n    // For absolute silence(in case of mic/software failures), all frequencies are 128 or 0.\n    return !data.some(frequency => frequency !== 128 && frequency !== 0);\n  }\n\n  private createAnalyserNodeForStream(stream: MediaStream): AnalyserNode {\n    const audioContext = HMSAudioContextHandler.getAudioContext();\n    const analyser = audioContext.createAnalyser();\n    const source = audioContext.createMediaStreamSource(stream);\n    source.connect(analyser);\n    return analyser;\n  }\n}\n", "import { HMSAudioTrack } from './HMSAudioTrack';\nimport { DeviceStorageManager } from '../../device-manager/DeviceStorage';\nimport { HMSException } from '../../error/HMSException';\nimport { EventBus } from '../../events/EventBus';\nimport { HMSAudioTrackSettings as IHMSAudioTrackSettings } from '../../interfaces';\nimport { HMSAudioPlugin, HMSPluginSupportResult } from '../../plugins';\nimport { HMSAudioPluginsManager } from '../../plugins/audio';\nimport HMSLogger from '../../utils/logger';\nimport { isBrowser, isIOS } from '../../utils/support';\nimport { getAudioTrack, isEmptyTrack } from '../../utils/track';\nimport { TrackAudioLevelMonitor } from '../../utils/track-audio-level-monitor';\nimport { HMSAudioTrackSettings, HMSAudioTrackSettingsBuilder } from '../settings';\nimport HMSLocalStream from '../streams/HMSLocalStream';\n\nfunction generateHasPropertyChanged(newSettings: Partial<HMSAudioTrackSettings>, oldSettings: HMSAudioTrackSettings) {\n  return function hasChanged(prop: 'codec' | 'volume' | 'maxBitrate' | 'deviceId' | 'advanced') {\n    return prop in newSettings && newSettings[prop] !== oldSettings[prop];\n  };\n}\n\nexport class HMSLocalAudioTrack extends HMSAudioTrack {\n  private readonly TAG = '[HMSLocalAudioTrack]';\n  settings: HMSAudioTrackSettings;\n  private pluginsManager: HMSAudioPluginsManager;\n  private processedTrack?: MediaStreamTrack;\n\n  audioLevelMonitor?: TrackAudioLevelMonitor;\n\n  /**\n   * see the doc in HMSLocalVideoTrack\n   * @internal\n   */\n  publishedTrackId?: string;\n\n  /**\n   * will be false for preview tracks\n   */\n  isPublished = false;\n\n  constructor(\n    stream: HMSLocalStream,\n    track: MediaStreamTrack,\n    source: string,\n    private eventBus: EventBus,\n    settings: HMSAudioTrackSettings = new HMSAudioTrackSettingsBuilder().build(),\n  ) {\n    super(stream, track, source);\n    stream.tracks.push(this);\n\n    this.settings = settings;\n    // Replace the 'default' or invalid deviceId with the actual deviceId\n    // This is to maintain consistency with selected devices as in some cases there will be no 'default' device\n    if (settings.deviceId !== track.getSettings().deviceId && !isEmptyTrack(track)) {\n      this.settings = this.buildNewSettings({ deviceId: track.getSettings().deviceId });\n    }\n    this.pluginsManager = new HMSAudioPluginsManager(this, eventBus);\n    this.setFirstTrackId(track.id);\n    if (isIOS() && isBrowser) {\n      document.addEventListener('visibilitychange', this.handleVisibilityChange);\n    }\n  }\n\n  private handleVisibilityChange = async () => {\n    if (document.visibilityState === 'visible') {\n      await this.replaceTrackWith(this.settings);\n    }\n  };\n\n  private async replaceTrackWith(settings: HMSAudioTrackSettings) {\n    const prevTrack = this.nativeTrack;\n    const isLevelMonitored = Boolean(this.audioLevelMonitor);\n    const newTrack = await getAudioTrack(settings);\n    /*\n     * stop the previous only after acquiring the new track otherwise this can lead to\n     * no audio when the above getAudioTrack throws an error. ex: DeviceInUse error\n     */\n    prevTrack?.stop();\n    newTrack.enabled = this.enabled;\n    HMSLogger.d(this.TAG, 'replaceTrack, Previous track stopped', prevTrack, 'newTrack', newTrack);\n\n    const localStream = this.stream as HMSLocalStream;\n    // change nativeTrack so plugin can start its work\n    await localStream.replaceSenderTrack(prevTrack, this.processedTrack || newTrack);\n    await localStream.replaceStreamTrack(prevTrack, newTrack);\n    this.nativeTrack = newTrack;\n    isLevelMonitored && this.initAudioLevelMonitor();\n    try {\n      await this.pluginsManager.reprocessPlugins();\n    } catch (e) {\n      this.eventBus.audioPluginFailed.publish(e as HMSException);\n    }\n  }\n\n  async setEnabled(value: boolean) {\n    if (value === this.enabled) {\n      return;\n    }\n\n    // Replace silent empty track with an actual audio track, if enabled.\n    if (value && isEmptyTrack(this.nativeTrack)) {\n      await this.replaceTrackWith(this.settings);\n    }\n    await super.setEnabled(value);\n    if (value) {\n      this.settings = this.buildNewSettings({ deviceId: this.nativeTrack.getSettings().deviceId });\n    }\n    this.eventBus.localAudioEnabled.publish({ enabled: value, track: this });\n    (this.stream as HMSLocalStream).trackUpdate(this);\n  }\n\n  /**\n   * verify if the track id being passed is of this track for correlating server messages like audio level\n   */\n  isPublishedTrackId(trackId: string) {\n    return this.publishedTrackId === trackId;\n  }\n\n  async setSettings(settings: Partial<IHMSAudioTrackSettings>, internal = false) {\n    const newSettings = this.buildNewSettings(settings);\n\n    if (isEmptyTrack(this.nativeTrack)) {\n      // if it is an empty track, cache the settings for when it is unmuted\n      this.settings = newSettings;\n      return;\n    }\n    await this.handleDeviceChange(newSettings, internal);\n    await this.handleSettingsChange(newSettings);\n    this.settings = newSettings;\n  }\n\n  /**\n   * @see HMSAudioPlugin\n   */\n  getPlugins(): string[] {\n    return this.pluginsManager.getPlugins();\n  }\n\n  /**\n   * @see HMSAudioPlugin\n   */\n  async addPlugin(plugin: HMSAudioPlugin): Promise<void> {\n    return this.pluginsManager.addPlugin(plugin);\n  }\n\n  /**\n   * @see HMSAudioPlugin\n   */\n  async removePlugin(plugin: HMSAudioPlugin): Promise<void> {\n    return this.pluginsManager.removePlugin(plugin);\n  }\n\n  /**\n   * @see HMSAudioPlugin\n   */\n  validatePlugin(plugin: HMSAudioPlugin): HMSPluginSupportResult {\n    return this.pluginsManager.validatePlugin(plugin);\n  }\n\n  /**\n   * @internal\n   */\n  async setProcessedTrack(processedTrack?: MediaStreamTrack) {\n    // if all plugins are removed reset everything back to native track\n    if (!processedTrack) {\n      if (this.processedTrack) {\n        // remove, reset back to the native track\n        await (this.stream as HMSLocalStream).replaceSenderTrack(this.processedTrack, this.nativeTrack);\n      }\n      this.processedTrack = undefined;\n      return;\n    }\n    if (processedTrack !== this.processedTrack) {\n      if (this.processedTrack) {\n        // replace previous processed track with new one\n        await (this.stream as HMSLocalStream).replaceSenderTrack(this.processedTrack, processedTrack);\n      } else {\n        // there is no prev processed track, replace native with new one\n        await (this.stream as HMSLocalStream).replaceSenderTrack(this.nativeTrack, processedTrack);\n      }\n      this.processedTrack = processedTrack;\n    }\n  }\n\n  initAudioLevelMonitor() {\n    if (this.audioLevelMonitor) {\n      this.destroyAudioLevelMonitor();\n    }\n    HMSLogger.d(this.TAG, 'Monitor Audio Level for', this, this.getMediaTrackSettings().deviceId);\n    this.audioLevelMonitor = new TrackAudioLevelMonitor(\n      this,\n      this.eventBus.trackAudioLevelUpdate,\n      this.eventBus.localAudioSilence,\n    );\n    this.audioLevelMonitor.start();\n    this.audioLevelMonitor.detectSilence();\n  }\n\n  destroyAudioLevelMonitor() {\n    this.audioLevelMonitor?.stop();\n    this.audioLevelMonitor = undefined;\n  }\n\n  async cleanup() {\n    super.cleanup();\n    await this.pluginsManager.cleanup();\n    await this.pluginsManager.closeContext();\n    this.processedTrack?.stop();\n    this.isPublished = false;\n    this.destroyAudioLevelMonitor();\n    if (isIOS() && isBrowser) {\n      document.removeEventListener('visibilitychange', this.handleVisibilityChange);\n    }\n  }\n\n  /**\n   * @internal\n   * published track id will be different in case there was some processing done using plugins.\n   */\n  getTrackIDBeingSent() {\n    return this.processedTrack ? this.processedTrack.id : this.nativeTrack.id;\n  }\n\n  /**\n   * @internal\n   */\n  getTrackBeingSent() {\n    return this.processedTrack || this.nativeTrack;\n  }\n\n  private buildNewSettings(settings: Partial<HMSAudioTrackSettings>) {\n    const { volume, codec, maxBitrate, deviceId, advanced } = { ...this.settings, ...settings };\n    const newSettings = new HMSAudioTrackSettings(volume, codec, maxBitrate, deviceId, advanced);\n    return newSettings;\n  }\n\n  private handleSettingsChange = async (settings: HMSAudioTrackSettings) => {\n    const stream = this.stream as HMSLocalStream;\n    const hasPropertyChanged = generateHasPropertyChanged(settings, this.settings);\n    if (hasPropertyChanged('maxBitrate') && settings.maxBitrate) {\n      await stream.setMaxBitrateAndFramerate(this);\n    }\n\n    if (hasPropertyChanged('advanced')) {\n      await this.replaceTrackWith(settings);\n    }\n  };\n\n  /**\n   * Replace audio track with new track on device change if enabled\n   * @param settings - AudioSettings Object constructed with new settings\n   * @param internal - whether the change was because of internal sdk call or external client call\n   */\n  private handleDeviceChange = async (settings: HMSAudioTrackSettings, internal = false) => {\n    const hasPropertyChanged = generateHasPropertyChanged(settings, this.settings);\n    if (hasPropertyChanged('deviceId')) {\n      await this.replaceTrackWith(settings);\n      if (!internal) {\n        DeviceStorageManager.updateSelection('audioInput', {\n          deviceId: settings.deviceId,\n          groupId: this.nativeTrack.getSettings().groupId,\n        });\n      }\n    }\n  };\n}\n", "import { HMSAudioTrack } from './HMSAudioTrack';\n\nexport class HMSRemoteAudioTrack extends HMSAudioTrack {\n  async setEnabled(value: boolean): Promise<void> {\n    if (value === this.enabled) {\n      return;\n    }\n    await super.setEnabled(value);\n    await this.subscribeToAudio(value);\n  }\n}\n", "import { HMSTrack, HMSTrackSource } from './HMSTrack';\nimport { HMSTrackType } from './HMSTrackType';\nimport HMSMediaStream from '../streams/HMSMediaStream';\n\nexport class HMSVideoTrack extends HMSTrack {\n  readonly type: HMSTrackType = HMSTrackType.VIDEO;\n  private sinkCount = 0;\n\n  /**\n   * sink=video element rendering the video\n   */\n  hasSinks() {\n    return this.sinkCount > 0;\n  }\n\n  constructor(stream: HMSMediaStream, track: MediaStreamTrack, source?: string) {\n    super(stream, track, source as HMSTrackSource);\n    if (track.kind !== 'video') {\n      throw new Error(\"Expected 'track' kind = 'video'\");\n    }\n  }\n\n  /**\n   * attaches the track to the passed in video element\n   * @param videoElement\n   */\n  addSink(videoElement: HTMLVideoElement) {\n    this.addSinkInternal(videoElement, this.nativeTrack);\n  }\n\n  /**\n   * removes the track from the passed in video element\n   * @param videoElement\n   */\n  removeSink(videoElement: HTMLVideoElement) {\n    if (videoElement.srcObject !== null) {\n      videoElement.srcObject = null;\n      if (this.sinkCount > 0) {\n        this.sinkCount--;\n      }\n    }\n  }\n\n  protected addSinkInternal(videoElement: HTMLVideoElement, track: MediaStreamTrack) {\n    const srcObject = videoElement.srcObject;\n    if (srcObject !== null && srcObject instanceof MediaStream) {\n      const existingTrackID = srcObject.getVideoTracks()[0]?.id;\n      if (existingTrackID === track.id) {\n        // it's already attached, attaching again would just cause flickering\n        return;\n      }\n    }\n    videoElement.srcObject = new MediaStream([track]);\n    this.sinkCount++;\n  }\n}\n", "import { HMSPluginSupportResult } from '../audio';\n\n/**\n * A plugin implementing this interface can be registered with HMSLocalVideoTrack to transform, process or\n * analyze the local video track.These can include applications like video filters, virtual background, live\n * analysis of video etc. The below functions are required for the sdk to properly use the plugin, usually\n * the plugin would also be exposing some public functions of its own for the UI to control its working.\n */\nexport interface HMSVideoPlugin {\n  /**\n   * The name is meant to uniquely specify a plugin instance. This will be used to track number of plugins\n   * added to the track, and same name won't be allowed twice.\n   */\n  getName(): string;\n\n  /**\n   * This function will be called before the call to init, it is used to check whether the plugin supports current\n   * OS and device or not. An error will be thrown back to the user if they try to use an unsupported plugin.\n   */\n  checkSupport(): HMSPluginSupportResult;\n\n  /**\n   * @deprecated. Will be deleted in future updates. Use checkSupport instead.\n   */\n  isSupported(): boolean;\n\n  /**\n   * This function will be called in the beginning for initialization which may include tasks like setting up\n   * variables, loading ML models etc. This can be used by a plugin to ensure it's prepared at the time\n   * processVideoFrame is called.\n   */\n  init(): Promise<void>;\n\n  /**\n   * @see HMSVideoPluginType\n   */\n  getPluginType(): HMSVideoPluginType;\n\n  getContextType?(): HMSVideoPluginCanvasContextType;\n\n  /**\n   * This function will be called by the SDK for every video frame which the plugin needs to process.\n   * PluginFrameRate - the rate at which the plugin is expected to process the video frames. This is not necessarily\n   * equal to the capture frame rate. The user can specify this rate, and the sdk might also change it on basis of\n   * device type, or CPU usage.\n   * For an analyzing plugin, the below function will be called at plugin framerate.\n   * For a transforming plugin, the sdk will pass in the input and output at real frame rate with an additional boolean\n   * pass. The expectation is that the plugin should use results of previous runs instead of doing a complex processing\n   * again when pass is set to true. This helps in maintaining the framerate of the video as well as bringing down\n   * CPU usage in case of complex processing.\n   * @param input input canvas containing the input frame\n   * @param output the output canvas which should contain the output frame\n   * @param skipProcessing use results from previous run if true\n   */\n  processVideoFrame(\n    input: HTMLCanvasElement,\n    output?: HTMLCanvasElement,\n    skipProcessing?: boolean,\n  ): Promise<void> | void;\n\n  /**\n   * the plugin can use this function to dispose off its resources. It'll be called when the processor instance is\n   * no longer needed at the end.\n   */\n  stop(): void;\n}\n\n/**\n * Specifies the type of the plugin a transforming plugin will get an output canvas to give the resulting\n * transformation. While an analyzing plugin will only be passed the input canvas.\n */\nexport enum HMSVideoPluginType {\n  TRANSFORM = 'TRANSFORM',\n  ANALYZE = 'ANALYZE',\n}\n\nexport enum HMSVideoPluginCanvasContextType {\n  '2D' = '2d',\n  WEBGL = 'webgl',\n  'WEBGL2' = 'webgl2',\n}\n", "export class RunningAverage {\n  private total = 0;\n  private count = 0;\n\n  add(item: number) {\n    this.count++;\n    this.total += item;\n  }\n\n  getAvg(): number {\n    return Math.floor(this.total / this.count);\n  }\n\n  reset() {\n    this.total = 0;\n    this.count = 0;\n  }\n}\n", "import MediaPluginsAnalyticsFactory from '../../analytics/MediaPluginsAnalyticsFactory';\nimport { ErrorFactory, HMSAction } from '../../error/ErrorFactory';\nimport { HMSException } from '../../error/HMSException';\nimport { EventBus } from '../../events/EventBus';\nimport HMSLogger from '../../utils/logger';\nimport { RunningAverage } from '../../utils/math';\n\nexport class VideoPluginsAnalytics {\n  private readonly TAG = '[VideoPluginsAnalytics]';\n  private readonly initTime: Record<string, number>;\n  private readonly addedTimestamps: Record<string, number>;\n  private readonly preProcessingAvgs: RunningAverage;\n  private readonly processingAvgs: Record<string, RunningAverage>;\n  private readonly pluginAdded: Record<string, boolean>;\n  private readonly pluginInputFrameRate: Record<string, number>;\n  private readonly pluginFrameRate: Record<string, number>;\n\n  constructor(private eventBus: EventBus) {\n    this.initTime = {};\n    this.preProcessingAvgs = new RunningAverage();\n    this.addedTimestamps = {};\n    this.processingAvgs = {};\n    this.pluginAdded = {};\n    this.pluginInputFrameRate = {};\n    this.pluginFrameRate = {};\n  }\n\n  added(name: string, inputFrameRate: number, pluginFrameRate?: number) {\n    this.pluginAdded[name] = true;\n    this.addedTimestamps[name] = Date.now();\n    this.initTime[name] = 0;\n    this.processingAvgs[name] = new RunningAverage();\n    this.pluginInputFrameRate[name] = inputFrameRate;\n    this.pluginFrameRate[name] = pluginFrameRate || inputFrameRate;\n  }\n\n  removed(name: string) {\n    //send stats\n    if (this.pluginAdded[name]) {\n      const stats = {\n        pluginName: name,\n        // duration in seconds\n        duration: Math.floor((Date.now() - this.addedTimestamps[name]) / 1000),\n        loadTime: this.initTime[name],\n        avgPreProcessingTime: this.preProcessingAvgs.getAvg(), //Do we need this in stat not plugin specific\n        avgProcessingTime: this.processingAvgs[name]?.getAvg(),\n        inputFrameRate: this.pluginInputFrameRate[name],\n        pluginFrameRate: this.pluginFrameRate[name],\n      };\n      //send stats\n      this.eventBus.analytics.publish(MediaPluginsAnalyticsFactory.stats(stats));\n      //clean the plugin details\n      this.clean(name);\n    }\n  }\n\n  failure(name: string, error: HMSException) {\n    // send failure event\n    if (this.pluginAdded[name]) {\n      this.eventBus.analytics.publish(MediaPluginsAnalyticsFactory.failure(name, error));\n      //clean the plugin details\n      this.clean(name);\n    }\n  }\n\n  async initWithTime<T>(name: string, initFn: () => Promise<T>) {\n    if (this.initTime[name]) {\n      HMSLogger.i(this.TAG, `Plugin Already loaded ${name}, time it took: ${this.initTime[name]}`);\n      return;\n    }\n    let time: number | undefined = undefined;\n    try {\n      time = await this.timeInMs(initFn);\n      HMSLogger.i(this.TAG, `Time taken for Plugin ${name} initialization : ${time}`);\n    } catch (e) {\n      //Failed during initialization of plugin(model loading etc...)\n      const err = ErrorFactory.MediaPluginErrors.InitFailed(\n        HMSAction.VIDEO_PLUGINS,\n        `failed during initialization of plugin${(e as Error).message || e}`,\n      );\n      HMSLogger.e(this.TAG, err);\n      this.failure(name, err);\n      throw err;\n    }\n    if (time) {\n      this.initTime[name] = time;\n    }\n  }\n\n  async preProcessWithTime<T>(preProcessFn: () => Promise<T>) {\n    //TODO: check if it is required to maintain and shall we handle preprocess failures\n    const time = await this.timeInMs(preProcessFn);\n    this.preProcessingAvgs.add(time);\n  }\n\n  async processWithTime<T>(name: string, processFn: () => Promise<T>) {\n    let time: number | undefined = undefined;\n    try {\n      time = await this.timeInMs(processFn);\n    } catch (e) {\n      //Failed during processing of plugin\n      const err = ErrorFactory.MediaPluginErrors.ProcessingFailed(\n        HMSAction.VIDEO_PLUGINS,\n        `Failed during processing of plugin${(e as Error).message || e}`,\n      );\n      HMSLogger.e(this.TAG, err);\n      this.failure(name, err);\n      throw err;\n    }\n    if (time) {\n      this.processingAvgs[name]?.add(time);\n    }\n  }\n\n  private async timeInMs<T>(fn: () => Promise<T>): Promise<number> {\n    const start = Date.now();\n    await fn();\n    return Math.floor(Date.now() - start);\n  }\n\n  private clean(name: string) {\n    delete this.addedTimestamps[name];\n    delete this.initTime[name];\n    delete this.processingAvgs[name];\n    delete this.pluginAdded[name];\n    delete this.pluginInputFrameRate[name];\n    delete this.pluginFrameRate[name];\n  }\n}\n", "/* eslint-disable complexity */\nimport { HMSVideoPlugin, HMSVideoPluginCanvasContextType, HMSVideoPluginType } from './HMSVideoPlugin';\nimport { VideoPluginsAnalytics } from './VideoPluginsAnalytics';\nimport { ErrorFactory, HMSAction } from '../../error/ErrorFactory';\nimport { EventBus } from '../../events/EventBus';\nimport { HMSLocalVideoTrack } from '../../media/tracks';\nimport HMSLogger from '../../utils/logger';\nimport { sleep } from '../../utils/timer-utils';\nimport { HMSPluginUnsupportedTypes } from '../audio';\n\nconst DEFAULT_FRAME_RATE = 24;\nconst DEFAULT_WIDTH = 320;\nconst DEFAULT_HEIGHT = 240;\n\ninterface CanvasElement extends HTMLCanvasElement {\n  captureStream(frameRate?: number): MediaStream;\n}\n\n/**\n * This class manages applying different plugins on a local video track. Plugins which need to modify the video\n * are called in the order they were added. Plugins which do not need to modify the video frames are called\n * with the original input.\n *\n * Concepts -\n * Video Plugin - A module which can take in input video painted on a canvas, do some processing on it and optionally\n * render its output on a passed in output canvas which will be shown in the UI.\n *\n * frameRate - the frame rate of the input video as present in track.getSettings, this is the rate at which new frames\n * are being produced and the rate we need to maintain in output as well.\n *\n * pluginFrameRate - this is the rate at which the plugin is supposed to do its processing. The processing can be an\n * expensive operation and can result in high usage of resources like CPU. This rate would usually be lower than the\n * real frame rate.\n *\n * pluginsLoop - a loop is run at framerate in this class, on each loop if the original track is unmuted all added\n * plugins are called one by one in the order they were called.\n *\n * @see HMSVideoPlugin\n */\nexport class HMSVideoPluginsManager {\n  private readonly TAG = '[VideoPluginsManager]';\n\n  /**\n   * plugins loop is the loop in which all plugins are applied\n   */\n  private pluginsLoopRunning = false;\n  private pluginsLoopState: 'paused' | 'running' = 'paused';\n  private readonly hmsTrack: HMSLocalVideoTrack;\n  private readonly pluginsMap: Map<string, HMSVideoPlugin>; // plugin names to their instance mapping\n  private inputVideo?: HTMLVideoElement;\n  private inputCanvas?: CanvasElement;\n  private outputCanvas?: CanvasElement;\n  private outputTrack?: MediaStreamTrack;\n  private analytics: VideoPluginsAnalytics;\n  private pluginAddInProgress = false;\n  private pluginNumFramesToSkip: Record<string, number>;\n  private pluginNumFramesSkipped: Record<string, number>;\n  private canvases: Array<CanvasElement>; //array of canvases to store intermediate result\n\n  constructor(track: HMSLocalVideoTrack, eventBus: EventBus) {\n    this.hmsTrack = track;\n    this.pluginsMap = new Map();\n    this.pluginNumFramesToSkip = {};\n    this.pluginNumFramesSkipped = {};\n    this.analytics = new VideoPluginsAnalytics(eventBus);\n    this.canvases = new Array<CanvasElement>();\n  }\n\n  getPlugins(): string[] {\n    return Array.from(this.pluginsMap.keys());\n  }\n\n  /**\n   * @param plugin\n   * @param pluginFrameRate\n   */\n  async addPlugin(plugin: HMSVideoPlugin, pluginFrameRate?: number) {\n    if (this.pluginAddInProgress) {\n      const name = plugin.getName?.();\n      if (!name || name === '') {\n        HMSLogger.w('no name provided by the plugin');\n        return;\n      }\n\n      const err = ErrorFactory.MediaPluginErrors.AddAlreadyInProgress(\n        HMSAction.VIDEO_PLUGINS,\n        'Add Plugin is already in Progress',\n      );\n      this.analytics.failure(name, err);\n\n      HMSLogger.w(\"can't add another plugin when previous add is in progress\");\n      throw err;\n    }\n\n    this.pluginAddInProgress = true;\n\n    try {\n      await this.addPluginInternal(plugin, pluginFrameRate);\n    } finally {\n      this.pluginAddInProgress = false;\n    }\n  }\n\n  private async addPluginInternal(plugin: HMSVideoPlugin, pluginFrameRate?: number) {\n    const name = plugin.getName?.();\n    if (!name || name === '') {\n      HMSLogger.w('no name provided by the plugin');\n      return;\n    }\n    if (this.pluginsMap.has(name)) {\n      HMSLogger.w(this.TAG, `plugin - ${plugin.getName()} already added.`);\n      return;\n    }\n    //TODO: assuming this inputFrameRate from getMediaTrackSettings will not change once set\n    //TODO: even if it changes will not have the info/params to know the change\n    const inputFrameRate = this.hmsTrack.getMediaTrackSettings().frameRate || DEFAULT_FRAME_RATE;\n\n    let numFramesToSkip = 0;\n    if (pluginFrameRate && pluginFrameRate > 0) {\n      HMSLogger.i(this.TAG, `adding plugin ${plugin.getName()} with framerate ${pluginFrameRate}`);\n      if (pluginFrameRate < inputFrameRate) {\n        numFramesToSkip = Math.ceil(inputFrameRate / pluginFrameRate) - 1;\n      }\n      this.analytics.added(name, inputFrameRate, pluginFrameRate);\n    } else {\n      HMSLogger.i(this.TAG, `adding plugin ${plugin.getName()}`);\n      this.analytics.added(name, inputFrameRate);\n    }\n\n    HMSLogger.i(this.TAG, 'numFrames to skip processing', numFramesToSkip);\n    this.pluginNumFramesToSkip[name] = numFramesToSkip;\n    this.pluginNumFramesSkipped[name] = numFramesToSkip;\n\n    this.validateAndThrow(name, plugin);\n\n    try {\n      await this.analytics.initWithTime(name, async () => await plugin.init());\n      this.pluginsMap.set(name, plugin);\n      // add new canvases according to new added plugins\n      if (this.pluginsMap.size + 1 > this.canvases.length) {\n        for (let i = this.canvases.length; i <= this.pluginsMap.size; i++) {\n          this.canvases[i] = document.createElement('canvas') as CanvasElement;\n        }\n      }\n      await this.startPluginsLoop(plugin.getContextType?.());\n    } catch (err) {\n      HMSLogger.e(this.TAG, 'failed to add plugin', err);\n      await this.removePlugin(plugin);\n      throw err;\n    }\n  }\n\n  validatePlugin(plugin: HMSVideoPlugin) {\n    return plugin.checkSupport();\n  }\n\n  validateAndThrow(name: string, plugin: HMSVideoPlugin) {\n    const result = this.validatePlugin(plugin);\n    if (result.isSupported) {\n      HMSLogger.i(this.TAG, `plugin is supported,- ${plugin.getName()}`);\n    } else {\n      let error;\n      switch (result.errType) {\n        case HMSPluginUnsupportedTypes.PLATFORM_NOT_SUPPORTED:\n          error = ErrorFactory.MediaPluginErrors.PlatformNotSupported(\n            HMSAction.VIDEO_PLUGINS,\n            'platform not supported, see docs',\n          );\n          this.analytics.failure(name, error);\n          throw error;\n        case HMSPluginUnsupportedTypes.DEVICE_NOT_SUPPORTED:\n          error = ErrorFactory.MediaPluginErrors.DeviceNotSupported(\n            HMSAction.VIDEO_PLUGINS,\n            'video device not supported, see docs',\n          );\n          this.analytics.failure(name, error);\n          throw error;\n      }\n    }\n  }\n\n  async removePlugin(plugin: HMSVideoPlugin) {\n    const name = plugin.getName();\n    if (!this.pluginsMap.get(name)) {\n      HMSLogger.w(this.TAG, `plugin - ${name} not found to remove.`);\n      return;\n    }\n    HMSLogger.i(this.TAG, `removing plugin ${name}`);\n    this.removePluginEntry(name);\n    if (this.pluginsMap.size === 0) {\n      HMSLogger.i(this.TAG, `No plugins left, stopping plugins loop`);\n      await this.stopPluginsLoop();\n    }\n    plugin.stop();\n    this.analytics.removed(name);\n  }\n\n  removePluginEntry(name: string) {\n    this.pluginsMap.delete(name);\n    if (this.pluginNumFramesToSkip[name]) {\n      delete this.pluginNumFramesToSkip[name];\n    }\n    if (this.pluginNumFramesSkipped[name]) {\n      delete this.pluginNumFramesSkipped[name];\n    }\n  }\n\n  /**\n   * when video is unmuted it takes some time for all the plugins to be re run and an output stream to be\n   * produced. It can await on this function to confirm and tell the new unmuted state.\n   * If this is not awaited on video will freeze with a frame from past run.\n   */\n  async waitForRestart() {\n    if (!this.pluginsLoopRunning || this.pluginsLoopState === 'running') {\n      return;\n    }\n    while (this.pluginsLoopState === 'paused') {\n      await sleep(100);\n    }\n  }\n\n  /**\n   * remove every plugin one by one\n   */\n  async cleanup() {\n    for (const plugin of this.pluginsMap.values()) {\n      await this.removePlugin(plugin);\n    }\n    // memory cleanup\n    this.outputTrack?.stop();\n  }\n\n  private initElementsAndStream(contextType?: HMSVideoPluginCanvasContextType) {\n    if (!this.inputCanvas) {\n      this.inputCanvas = document.createElement('canvas') as CanvasElement;\n    }\n    this.outputCanvas = document.createElement('canvas') as CanvasElement;\n    if (!this.inputVideo) {\n      this.inputVideo = document.createElement('video');\n    }\n    // FF issue https://bugzilla.mozilla.org/show_bug.cgi?id=1388974\n    this.inputCanvas.getContext('2d');\n    this.outputCanvas.getContext(contextType || HMSVideoPluginCanvasContextType['2D']);\n    // capture stream automatically uses the framerate at which the output canvas is changing\n    const outputStream = this.outputCanvas.captureStream();\n    this.outputTrack = outputStream.getVideoTracks()[0];\n  }\n\n  private async startPluginsLoop(contextType?: HMSVideoPluginCanvasContextType) {\n    if (this.pluginsLoopRunning) {\n      return;\n    }\n    this.initElementsAndStream(contextType);\n    this.pluginsLoopRunning = true;\n    try {\n      await this.hmsTrack.setProcessedTrack(this.outputTrack);\n    } catch (err) {\n      this.pluginsLoopRunning = false;\n      HMSLogger.e(this.TAG, 'error in setting processed track', err);\n      throw err;\n    }\n    // can't await on pluginsLoop as it'll run for a long long time\n    this.pluginsLoop().then(() => {\n      HMSLogger.d(this.TAG, 'processLoop stopped');\n    });\n  }\n\n  private async stopPluginsLoop() {\n    this.pluginsLoopRunning = false;\n    await this.hmsTrack.setProcessedTrack(undefined);\n    this.resetCanvases();\n    this.outputTrack?.stop();\n    if (this.inputVideo) {\n      this.inputVideo.srcObject = null;\n      this.inputVideo = undefined;\n    }\n  }\n\n  private async pluginsLoop() {\n    while (this.pluginsLoopRunning) {\n      const inputFrameRate = this.hmsTrack.getMediaTrackSettings().frameRate || DEFAULT_FRAME_RATE;\n      const sleepTimeMs = Math.floor(1000 / inputFrameRate);\n      if (!this.hmsTrack.enabled || this.hmsTrack.nativeTrack.readyState === 'ended') {\n        if (this.pluginsLoopState === 'running') {\n          // mute just happened, reset canvases to black so even if it is sent to remote, it\n          // is a black screen instead of a stucked frame from previous run\n          this.resetCanvases();\n        }\n        this.pluginsLoopState = 'paused';\n        await sleep(sleepTimeMs);\n        continue;\n      }\n      let processingTime = 0;\n      try {\n        await this.analytics.preProcessWithTime(async () => await this.doPreProcessing());\n        const start = Date.now();\n        await this.processFramesThroughPlugins();\n        processingTime = Math.floor(Date.now() - start);\n        if (processingTime > sleepTimeMs) {\n          processingTime = sleepTimeMs;\n        }\n      } catch (err) {\n        // TODO: handle failures properly, detect which plugin failed, stop it and notify back to the UI\n        HMSLogger.e(this.TAG, 'error in plugins loop', err);\n      }\n      this.pluginsLoopState = 'running';\n      // take into account processing time to decide time to wait for the next loop\n      await sleep(sleepTimeMs - processingTime);\n    }\n  }\n\n  private async doPreProcessing() {\n    await this.addTrackToVideo(); // ensure current native track is playing in video\n    await this.updateInputCanvas(); // put the latest video frame on input canvas\n  }\n\n  /**\n   * pass the input canvas through all plugins in a loop\n   * @private\n   */\n  private async processFramesThroughPlugins() {\n    this.canvases[0] = this.inputCanvas!;\n    let i = 0;\n    for (const plugin of this.pluginsMap.values()) {\n      const name = plugin.getName();\n      if (!plugin) {\n        continue;\n      }\n      try {\n        const skipProcessing = this.checkIfSkipRequired(name);\n\n        if (plugin.getPluginType() === HMSVideoPluginType.TRANSFORM) {\n          const process = async (input: CanvasElement, output: CanvasElement) => {\n            try {\n              await plugin.processVideoFrame(input, output, skipProcessing);\n            } catch (err) {\n              HMSLogger.e(this.TAG, `error in processing plugin ${name}`, err);\n            }\n          };\n          if (!skipProcessing) {\n            const currentCanvas = this.canvases[i];\n            const nextCanvas = this.canvases[i + 1];\n            if (i === this.pluginsMap.size - 1) {\n              await this.analytics.processWithTime(name, async () => process(currentCanvas, this.outputCanvas!));\n            } else {\n              await this.analytics.processWithTime(name, async () => process(currentCanvas, nextCanvas));\n            }\n          } else {\n            if (i === this.pluginsMap.size - 1) {\n              await process(this.canvases[i], this.outputCanvas!);\n            } else {\n              await process(this.canvases[i], this.canvases[i + 1]);\n            }\n          }\n        } else if (plugin.getPluginType() === HMSVideoPluginType.ANALYZE && !skipProcessing) {\n          // there is no need to await for this case\n          await this.analytics.processWithTime(name, async () => await plugin.processVideoFrame(this.inputCanvas!));\n        }\n      } catch (err) {\n        //TODO error happened on processing of plugin notify UI\n        HMSLogger.e(this.TAG, `error in processing plugin ${name}`, err);\n        //remove plugin from loop and stop analytics for it\n        await this.removePlugin(plugin);\n      }\n      i++;\n    }\n  }\n\n  /**\n   * add the current native track to the inputVideoElement if it's not already added.\n   * @private\n   */\n  private async addTrackToVideo() {\n    if (!this.inputVideo) {\n      return;\n    }\n    const srcObject = this.inputVideo.srcObject;\n    if (srcObject !== null && srcObject instanceof MediaStream) {\n      const existingTrackID = srcObject.getVideoTracks()[0]?.id;\n      if (existingTrackID === this.hmsTrack.nativeTrack.id) {\n        // it's already attached\n        return;\n      }\n    }\n    this.inputVideo.pause();\n    this.inputVideo.srcObject = new MediaStream([this.hmsTrack.nativeTrack]);\n    this.inputVideo.muted = true;\n    this.inputVideo.playsInline = true;\n    await this.inputVideo.play();\n  }\n\n  /**\n   * get the new video frame from input video element and put it on canvas\n   * @private\n   */\n  private async updateInputCanvas() {\n    if (!this.inputCanvas || !this.inputVideo) {\n      return;\n    }\n    const { width = DEFAULT_WIDTH, height = DEFAULT_HEIGHT } = this.hmsTrack.getMediaTrackSettings();\n    // TODO: should we reduce height/width to optimize?\n    if (this.inputCanvas.height !== height) {\n      this.inputCanvas.height = height;\n    }\n    if (this.inputCanvas.width !== width) {\n      this.inputCanvas.width = width;\n    }\n    const ctx = this.inputCanvas.getContext('2d');\n    ctx!.drawImage(this.inputVideo, 0, 0, width, height);\n  }\n\n  private resetCanvases() {\n    if (!this.outputCanvas || !this.inputCanvas) {\n      return;\n    }\n    const inputCtx = this.inputCanvas.getContext('2d');\n    if (inputCtx) {\n      inputCtx.fillStyle = `rgb(0, 0, 0)`;\n      inputCtx.fillRect(0, 0, this.outputCanvas.width, this.outputCanvas.height);\n    }\n    this.canvases = [];\n  }\n\n  /**\n    N = ceil(inputFrameRate/pluginFrameRate) - 1\n    N = this.pluginNumFramesToSkip[name] = frames to skip for every processed frame\n    all the frames we are skipping are using the previous frame output\n   **/\n  private checkIfSkipRequired(name: string) {\n    let skip = false;\n\n    if (this.pluginNumFramesSkipped[name] < this.pluginNumFramesToSkip[name]) {\n      this.pluginNumFramesSkipped[name]++;\n      skip = true;\n    } else {\n      skip = false;\n      this.pluginNumFramesSkipped[name] = 0;\n    }\n\n    return skip;\n  }\n}\n", "import { HMSVideoTrack } from './HMSVideoTrack';\nimport { DeviceStorageManager } from '../../device-manager/DeviceStorage';\nimport { ErrorFactory, HMSAction } from '../../error/ErrorFactory';\nimport { EventBus } from '../../events/EventBus';\nimport {\n  HMSSimulcastLayerDefinition,\n  HMSVideoTrackSettings as IHMSVideoTrackSettings,\n  ScreenCaptureHandle,\n} from '../../interfaces';\nimport { HMSPluginSupportResult, HMSVideoPlugin } from '../../plugins';\nimport { HMSVideoPluginsManager } from '../../plugins/video';\nimport { LocalTrackManager } from '../../sdk/LocalTrackManager';\nimport HMSLogger from '../../utils/logger';\nimport { getVideoTrack } from '../../utils/track';\nimport { HMSVideoTrackSettings, HMSVideoTrackSettingsBuilder } from '../settings';\nimport HMSLocalStream from '../streams/HMSLocalStream';\n\nfunction generateHasPropertyChanged(newSettings: Partial<HMSVideoTrackSettings>, oldSettings: HMSVideoTrackSettings) {\n  return function hasChanged(\n    prop: 'codec' | 'width' | 'height' | 'maxFramerate' | 'maxBitrate' | 'deviceId' | 'advanced',\n  ) {\n    return prop in newSettings && newSettings[prop] !== oldSettings[prop];\n  };\n}\n\nexport class HMSLocalVideoTrack extends HMSVideoTrack {\n  settings: HMSVideoTrackSettings;\n  private pluginsManager: HMSVideoPluginsManager;\n  private processedTrack?: MediaStreamTrack;\n  private _layerDefinitions: HMSSimulcastLayerDefinition[] = [];\n  private TAG = '[HMSLocalVideoTrack]';\n\n  /**\n   * true if it's screenshare and current tab is what is being shared. Browser dependent, Chromium only\n   * at the point of writing this comment.\n   */\n  isCurrentTab = false;\n\n  /**\n   * @internal\n   * This is required for handling remote mute/unmute as the published track will not necessarily be same as\n   * the first track id or current native track's id.\n   * It won't be same as first track id if the native track was changed after preview started but before join happened,\n   * with device change, or mute/unmute.\n   * It won't be same as native track id, as the native track can change post join(and publish), when the nativetrack\n   * changes, replacetrack is used which doesn't involve republishing which means from server's point of view, the track id\n   * is same as what was initially published.\n   * This will only be available if the track was actually published and won't be set for preview tracks.\n   */\n  publishedTrackId?: string;\n\n  /**\n   * will be false for preview tracks\n   */\n  isPublished = false;\n\n  constructor(\n    stream: HMSLocalStream,\n    track: MediaStreamTrack,\n    source: string,\n    private eventBus: EventBus,\n    settings: HMSVideoTrackSettings = new HMSVideoTrackSettingsBuilder().build(),\n  ) {\n    super(stream, track, source);\n    stream.tracks.push(this);\n    this.settings = settings;\n    // Replace the 'default' or invalid deviceId with the actual deviceId\n    // This is to maintain consistency with selected devices as in some cases there will be no 'default' device\n    if (settings.deviceId !== track.getSettings().deviceId && track.enabled) {\n      this.settings = this.buildNewSettings({ deviceId: track.getSettings().deviceId });\n    }\n    this.pluginsManager = new HMSVideoPluginsManager(this, eventBus);\n    this.setFirstTrackId(this.trackId);\n  }\n\n  /** @internal */\n  setSimulcastDefinitons(definitions: HMSSimulcastLayerDefinition[]) {\n    this._layerDefinitions = definitions;\n  }\n\n  /**\n   * Method to get available simulcast definitions for the track\n   * @returns {HMSSimulcastLayerDefinition[]}\n   */\n  getSimulcastDefinitions(): HMSSimulcastLayerDefinition[] {\n    return this._layerDefinitions;\n  }\n\n  /**\n   * use this function to set the enabled state of a track. If true the track will be unmuted and muted otherwise.\n   * @param value\n   */\n  async setEnabled(value: boolean): Promise<void> {\n    if (value === this.enabled) {\n      return;\n    }\n    if (this.source === 'regular') {\n      let track: MediaStreamTrack;\n      if (value) {\n        track = await this.replaceTrackWith(this.settings);\n      } else {\n        track = await this.replaceTrackWithBlank();\n      }\n      await this.replaceSender(track, value);\n      this.nativeTrack?.stop();\n      this.nativeTrack = track;\n      if (value) {\n        await this.pluginsManager.waitForRestart();\n        this.settings = this.buildNewSettings({ deviceId: track.getSettings().deviceId });\n      }\n    }\n    await super.setEnabled(value);\n    this.eventBus.localVideoEnabled.publish({ enabled: value, track: this });\n    (this.stream as HMSLocalStream).trackUpdate(this);\n  }\n\n  /**\n   * verify if the track id being passed is of this track for correlating server messages like degradation\n   */\n  isPublishedTrackId(trackId: string) {\n    return this.publishedTrackId === trackId;\n  }\n\n  /**\n   * @see HMSVideoTrack#addSink()\n   */\n  addSink(videoElement: HTMLVideoElement) {\n    this.addSinkInternal(videoElement, this.processedTrack || this.nativeTrack);\n  }\n\n  /**\n   * This function can be used to set media track settings. Frequent options -\n   * deviceID: can be used to change to different input source\n   * width, height - can be used to change capture dimensions\n   * maxFramerate - can be used to control the capture framerate\n   * @param settings\n   */\n  async setSettings(settings: Partial<IHMSVideoTrackSettings>, internal = false) {\n    const newSettings = this.buildNewSettings(settings);\n    await this.handleDeviceChange(newSettings, internal);\n    if (!this.enabled) {\n      // if track is muted, we just cache the settings for when it is unmuted\n      this.settings = newSettings;\n      return;\n    }\n    await this.handleSettingsChange(newSettings);\n    this.settings = newSettings;\n  }\n\n  /**\n   * @see HMSVideoPlugin\n   */\n  getPlugins(): string[] {\n    return this.pluginsManager.getPlugins();\n  }\n\n  /**\n   * @see HMSVideoPlugin\n   */\n  async addPlugin(plugin: HMSVideoPlugin, pluginFrameRate?: number): Promise<void> {\n    return this.pluginsManager.addPlugin(plugin, pluginFrameRate);\n  }\n\n  /**\n   * @see HMSVideoPlugin\n   */\n  async removePlugin(plugin: HMSVideoPlugin): Promise<void> {\n    return this.pluginsManager.removePlugin(plugin);\n  }\n\n  /**\n   * @see HMSVideoPlugin\n   */\n  validatePlugin(plugin: HMSVideoPlugin): HMSPluginSupportResult {\n    return this.pluginsManager.validatePlugin(plugin);\n  }\n\n  /**\n   * @internal\n   */\n  async cleanup() {\n    super.cleanup();\n    await this.pluginsManager.cleanup();\n    this.processedTrack?.stop();\n    this.isPublished = false;\n  }\n\n  /**\n   * only for screenshare track to crop to a cropTarget\n   * @internal\n   */\n  async cropTo(cropTarget?: object) {\n    if (!cropTarget) {\n      return;\n    }\n    if (this.source !== 'screen') {\n      return;\n    }\n    try {\n      // @ts-ignore\n      if (this.nativeTrack.cropTo) {\n        // @ts-ignore\n        await this.nativeTrack.cropTo(cropTarget);\n      }\n    } catch (err) {\n      HMSLogger.e(this.TAG, 'failed to crop screenshare capture - ', err);\n      throw ErrorFactory.TracksErrors.GenericTrack(HMSAction.TRACK, 'failed to crop screenshare capture');\n    }\n  }\n\n  /**\n   * only for screenshare track to get the captureHandle\n   * TODO: add an API for capturehandlechange event\n   * @internal\n   */\n  getCaptureHandle(): ScreenCaptureHandle | undefined {\n    // @ts-ignore\n    if (this.nativeTrack.getCaptureHandle) {\n      // @ts-ignore\n      return this.nativeTrack.getCaptureHandle();\n    }\n    return undefined;\n  }\n\n  /**\n   * once the plugin manager has done its processing it can set or remove processed track via this method\n   * note that replacing sender track only makes sense if the native track is enabled. if it's disabled there is\n   * no point in replacing it. We'll update the processed track variable though so next time unmute happens\n   * it's set properly.\n   * @internal\n   */\n  async setProcessedTrack(processedTrack?: MediaStreamTrack) {\n    // required replacement will happen when video is unmuted\n    if (!this.nativeTrack.enabled) {\n      this.processedTrack = processedTrack;\n      return;\n    }\n    // if all plugins are removed reset everything back to native track\n    if (!processedTrack) {\n      if (this.processedTrack) {\n        // remove, reset back to the native track\n        await (this.stream as HMSLocalStream).replaceSenderTrack(this.processedTrack, this.nativeTrack);\n      }\n      this.processedTrack = undefined;\n      return;\n    }\n    if (processedTrack !== this.processedTrack) {\n      if (this.processedTrack) {\n        // replace previous processed track with new one\n        await (this.stream as HMSLocalStream).replaceSenderTrack(this.processedTrack, processedTrack);\n      } else {\n        // there is no prev processed track, replace native with new one\n        await (this.stream as HMSLocalStream).replaceSenderTrack(this.nativeTrack, processedTrack);\n      }\n      this.processedTrack = processedTrack;\n    }\n  }\n\n  /**\n   * @internal\n   * sent track id will be different in case there was some processing done using plugins.\n   * replace track is used to, start sending data from a new track without un publishing the prior one. There\n   * are thus two track ids - the one which was initially published and should be unpublished when required.\n   * The one whose data is currently being sent, which will be used when removing from connection senders.\n   */\n  getTrackIDBeingSent() {\n    return this.getTrackBeingSent().id;\n  }\n\n  getTrackBeingSent() {\n    return this.enabled ? this.processedTrack || this.nativeTrack : this.nativeTrack;\n  }\n\n  /**\n   * called when the video is unmuted\n   * @private\n   */\n  private async replaceTrackWith(settings: HMSVideoTrackSettings) {\n    const prevTrack = this.nativeTrack;\n    const newTrack = await getVideoTrack(settings);\n    /*\n     * stop the previous only after acquiring the new track otherwise this can lead to\n     * no video(black tile) when the above getAudioTrack throws an error. ex: DeviceInUse error\n     */\n    prevTrack?.stop();\n    HMSLogger.d(this.TAG, 'replaceTrack, Previous track stopped', prevTrack, 'newTrack', newTrack);\n    // Replace deviceId with actual deviceId when it is default\n    if (this.settings.deviceId === 'default') {\n      this.settings = this.buildNewSettings({ deviceId: this.nativeTrack.getSettings().deviceId });\n    }\n    return newTrack;\n  }\n\n  /**\n   * called when the video is muted. A blank track is used to replace the original track. This is in order to\n   * turn off the camera light and keep the bytes flowing to avoid av sync, timestamp issues.\n   * @private\n   */\n  private async replaceTrackWithBlank() {\n    const prevTrack = this.nativeTrack;\n    const newTrack = LocalTrackManager.getEmptyVideoTrack(prevTrack);\n    prevTrack?.stop();\n    HMSLogger.d(this.TAG, 'replaceTrackWithBlank, Previous track stopped', prevTrack, 'newTrack', newTrack);\n    return newTrack;\n  }\n\n  private async replaceSender(newTrack: MediaStreamTrack, enabled: boolean) {\n    const localStream = this.stream as HMSLocalStream;\n    if (enabled) {\n      await localStream.replaceSenderTrack(this.nativeTrack, this.processedTrack || newTrack);\n    } else {\n      await localStream.replaceSenderTrack(this.processedTrack || this.nativeTrack, newTrack);\n    }\n    await localStream.replaceStreamTrack(this.nativeTrack, newTrack);\n  }\n\n  private buildNewSettings = (settings: Partial<HMSVideoTrackSettings>) => {\n    const { width, height, codec, maxFramerate, maxBitrate, deviceId, advanced } = { ...this.settings, ...settings };\n    const newSettings = new HMSVideoTrackSettings(width, height, codec, maxFramerate, deviceId, advanced, maxBitrate);\n    return newSettings;\n  };\n\n  private handleSettingsChange = async (settings: HMSVideoTrackSettings) => {\n    const stream = this.stream as HMSLocalStream;\n    const hasPropertyChanged = generateHasPropertyChanged(settings, this.settings);\n    if (hasPropertyChanged('maxBitrate') && settings.maxBitrate) {\n      await stream.setMaxBitrateAndFramerate(this);\n    }\n\n    if (hasPropertyChanged('width') || hasPropertyChanged('height') || hasPropertyChanged('advanced')) {\n      await this.nativeTrack.applyConstraints(settings.toConstraints());\n    }\n  };\n\n  /**\n   * Replace video track with new track on device change\n   * @param settings - VideoSettings Object constructed with new settings\n   * @param internal - whether the change was because of internal sdk call or external client call\n   */\n  private handleDeviceChange = async (settings: HMSVideoTrackSettings, internal = false) => {\n    const hasPropertyChanged = generateHasPropertyChanged(settings, this.settings);\n\n    if (hasPropertyChanged('deviceId') && this.source === 'regular') {\n      if (this.enabled) {\n        const track = await this.replaceTrackWith(settings);\n        await this.replaceSender(track, this.enabled);\n        this.nativeTrack = track;\n      }\n      if (!internal) {\n        DeviceStorageManager.updateSelection('videoInput', {\n          deviceId: settings.deviceId,\n          groupId: this.nativeTrack.getSettings().groupId,\n        });\n      }\n    }\n  };\n}\n", "export const RENEGOTIATION_CALLBACK_ID = 'renegotiation-callback-id';\nexport const API_DATA_CHANNEL = 'ion-sfu';\nexport const ANALYTICS_BUFFER_SIZE = 100;\n\n/**\n * Maximum number of retries that transport-layer will try\n * before giving up on the connection and returning a failure\n *\n * Refer https://100ms.atlassian.net/browse/HMS-2369\n */\nexport const MAX_TRANSPORT_RETRIES = 5;\nexport const MAX_TRANSPORT_RETRY_DELAY = 60;\n\nexport const DEFAULT_SIGNAL_PING_TIMEOUT = 12000;\nexport const DEFAULT_SIGNAL_PING_INTERVAL = 1000;\nexport const PONG_RESPONSE_TIMES_SIZE = 5;\n\nexport const SUBSCRIBE_ICE_CONNECTION_CALLBACK_ID = 'SUBSCRIBE_ICE_CONNECTION_CALLBACK_ID';\nexport const SUBSCRIBE_TIMEOUT = 60000;\n\nexport const ICE_DISCONNECTION_TIMEOUT = 5000;\n\nexport const RTC_STATS_MONITOR_INTERVAL = 1000;\n\nexport const MAINTAIN_TRACK_HISTORY = false;\n\nexport const CLIENT_ANAYLTICS_PROD_ENDPOINT = 'https://event.100ms.live/v2/client/report';\nexport const CLIENT_ANAYLTICS_QA_ENDPOINT = 'https://event-nonprod.100ms.live/v2/client/report';\nexport const CLIENT_ANAYLTICS_STORAGE_LIMIT = 100;\n\nexport const HMSEvents = {\n  DEVICE_CHANGE: 'device-change',\n  LOCAL_AUDIO_ENABLED: 'local-audio-enabled',\n  LOCAL_VIDEO_ENABLED: 'local-video-enabled',\n  STATS_UPDATE: 'stats-update', // emitted by HMSWebrtcInternals\n  RTC_STATS_UPDATE: 'rtc-stats-update', // emitted by RTCStatsMonitor\n  TRACK_DEGRADED: 'track-degraded',\n  TRACK_RESTORED: 'track-restored',\n  TRACK_AUDIO_LEVEL_UPDATE: 'track-audio-level-update',\n  LOCAL_AUDIO_SILENCE: 'local-audio-silence',\n  ANALYTICS: 'analytics',\n  AUDIO_PLUGIN_FAILED: 'audio-plugin-failed',\n  POLICY_CHANGE: 'policy-change',\n  LOCAL_ROLE_UPDATE: 'local-role-update',\n  AUDIO_TRACK_UPDATE: 'audio-track-update',\n  AUDIO_TRACK_ADDED: 'audio-track-added',\n  AUDIO_TRACK_REMOVED: 'audio-track-removed',\n  AUTOPLAY_ERROR: 'autoplay-error',\n  LEAVE: 'leave',\n};\n", "import { HMSVideoTrack } from './HMSVideoTrack';\nimport { VideoTrackLayerUpdate } from '../../connection/channel-messages';\nimport {\n  HMSPreferredSimulcastLayer,\n  HMSSimulcastLayer,\n  HMSSimulcastLayerDefinition,\n} from '../../interfaces/simulcast-layers';\nimport { MAINTAIN_TRACK_HISTORY } from '../../utils/constants';\nimport HMSLogger from '../../utils/logger';\nimport HMSRemoteStream from '../streams/HMSRemoteStream';\n\nexport class HMSRemoteVideoTrack extends HMSVideoTrack {\n  private _degraded = false;\n  private _degradedAt: Date | null = null;\n  private _layerDefinitions: HMSSimulcastLayerDefinition[] = [];\n  private history = new TrackHistory();\n  private preferredLayer: HMSPreferredSimulcastLayer = HMSSimulcastLayer.HIGH;\n\n  public get degraded() {\n    return this._degraded;\n  }\n\n  public get degradedAt() {\n    return this._degradedAt;\n  }\n\n  async setEnabled(value: boolean): Promise<void> {\n    if (value === this.enabled) {\n      return;\n    }\n\n    await super.setEnabled(value);\n  }\n\n  async setPreferredLayer(layer: HMSPreferredSimulcastLayer) {\n    //@ts-ignore\n    if (layer === HMSSimulcastLayer.NONE) {\n      HMSLogger.w(`layer ${HMSSimulcastLayer.NONE} will be ignored`);\n      return;\n    }\n    this.preferredLayer = layer;\n    if (!this.shouldSendVideoLayer(layer, 'preferLayer')) {\n      return;\n    }\n    if (!this.hasSinks()) {\n      HMSLogger.d(\n        `[Remote Track] ${this.logIdentifier}`,\n        `Track does not have any sink, saving ${layer}, source=${this.source}`,\n      );\n      return;\n    }\n    await this.requestLayer(layer, 'preferLayer');\n    this.pushInHistory(`uiPreferLayer-${layer}`);\n  }\n\n  /**\n   * @deprecated\n   * @returns {HMSSimulcastLayer}\n   */\n  getSimulcastLayer() {\n    return (this.stream as HMSRemoteStream).getSimulcastLayer();\n  }\n\n  getLayer() {\n    return (this.stream as HMSRemoteStream).getVideoLayer();\n  }\n\n  getPreferredLayer() {\n    return this.preferredLayer;\n  }\n\n  async addSink(videoElement: HTMLVideoElement) {\n    super.addSink(videoElement);\n    await this.updateLayer('addSink');\n    this.pushInHistory(`uiSetLayer-high`);\n  }\n\n  async removeSink(videoElement: HTMLVideoElement) {\n    super.removeSink(videoElement);\n    await this.updateLayer('removeSink');\n    this._degraded = false;\n    this.pushInHistory('uiSetLayer-none');\n  }\n\n  /**\n   * Method to get available simulcast definitions for the track\n   * @returns {HMSSimulcastLayerDefinition[]}\n   */\n  getSimulcastDefinitions() {\n    // send a clone to store as it will freeze the object from further updates\n    return [...this._layerDefinitions];\n  }\n\n  /** @internal */\n  setSimulcastDefinitons(definitions: HMSSimulcastLayerDefinition[]) {\n    this._layerDefinitions = definitions;\n  }\n\n  /**\n   * @internal\n   * SFU will change track's layer(degrade or restore) and tell the sdk to update\n   * it locally.\n   * @returns {boolean} isDegraded - returns true if degraded\n   * */\n  setLayerFromServer(layerUpdate: VideoTrackLayerUpdate) {\n    this._degraded =\n      (layerUpdate.publisher_degraded || layerUpdate.subscriber_degraded) &&\n      layerUpdate.current_layer === HMSSimulcastLayer.NONE;\n    this._degradedAt = this._degraded ? new Date() : this._degradedAt;\n    const currentLayer = layerUpdate.current_layer;\n    HMSLogger.d(\n      `[Remote Track] ${this.logIdentifier} ${this.stream.id} - layer update from sfu`,\n      `currLayer=${layerUpdate.current_layer}, preferredLayer=${layerUpdate.expected_layer}`,\n      `sub_degraded=${layerUpdate.subscriber_degraded}`,\n      `pub_degraded=${layerUpdate.publisher_degraded}`,\n      `isDegraded=${this._degraded}`,\n    );\n    // No need to send preferLayer update, as server has done it already\n    (this.stream as HMSRemoteStream).setVideoLayerLocally(currentLayer, this.logIdentifier, 'setLayerFromServer');\n    this.pushInHistory(`sfuLayerUpdate-${currentLayer}`);\n    return this._degraded;\n  }\n\n  /**\n   * @internal\n   * If degradation is being managed by sdk, sdk will let the track know of status\n   * post which it'll set it as well and send prefer layer message to SFU.\n   * */\n  setDegradedFromSdk(value: boolean) {\n    this._degraded = value;\n    this._degradedAt = value ? new Date() : this._degradedAt;\n    this.updateLayer('sdkDegradation');\n    this.pushInHistory(value ? 'sdkDegraded-none' : 'sdkRecovered-high');\n  }\n\n  private async updateLayer(source: string) {\n    const newLayer = this.degraded || !this.hasSinks() ? HMSSimulcastLayer.NONE : this.preferredLayer;\n    if (!this.shouldSendVideoLayer(newLayer, source)) {\n      return;\n    }\n    await this.requestLayer(newLayer, source);\n  }\n\n  private pushInHistory(action: string) {\n    if (MAINTAIN_TRACK_HISTORY) {\n      this.history.push({ name: action, layer: this.getLayer(), degraded: this.degraded });\n    }\n  }\n\n  private async requestLayer(layer: HMSSimulcastLayer, source: string) {\n    try {\n      const response = await (this.stream as HMSRemoteStream).setVideoLayer(\n        layer,\n        this.trackId,\n        this.logIdentifier,\n        source,\n      );\n      HMSLogger.d(`[Remote Track] ${this.logIdentifier}`, `Requested layer ${layer}, source=${this.source}`);\n      return response;\n    } catch (error) {\n      HMSLogger.d(\n        `[Remote Track] ${this.logIdentifier}`,\n        `Failed to set layer ${layer}, source=${this.source}, ${(error as Error).message}`,\n      );\n      throw error;\n    }\n  }\n\n  /**\n   * given the new layer, figure out if the update should be sent to server or not.\n   * It won't be sent if the track is already on the targetLayer. If the track is\n   * degraded though and the target layer is none, update will be sent.\n   * If there are tracks degraded on a page and user paginates away to other page,\n   * it's necessary to send the layer none message to SFU so it knows that the app\n   * is no longer interested in the track and doesn't recover degraded tracks on non\n   * visible pages.\n   *\n   * TODO: if track is degraded, send the update if target layer is lower than current layer\n   * @private\n   */\n  private shouldSendVideoLayer(targetLayer: HMSSimulcastLayer, source: string) {\n    const currLayer = this.getLayer();\n    if (this.degraded && targetLayer === HMSSimulcastLayer.NONE) {\n      return true;\n    }\n    if (currLayer === targetLayer) {\n      HMSLogger.d(\n        `[Remote Track] ${this.logIdentifier}`,\n        `Not sending update, already on layer ${targetLayer}, source=${source}`,\n      );\n      return false;\n    }\n    return true;\n  }\n}\n\n/**\n * to store history of everything that happened to a remote track which decides\n * it's current layer and degraded status.\n */\nclass TrackHistory {\n  history: Record<string, any>[] = [];\n\n  push(action: Record<string, any>) {\n    action.time = new Date().toISOString().split('T')[1];\n    this.history.push(action);\n  }\n}\n", "import HMSMediaStream from './HMSMediaStream';\nimport HMSPublishConnection from '../../connection/publish/publishConnection';\nimport { SimulcastLayer } from '../../interfaces';\nimport HMSLogger from '../../utils/logger';\nimport { isNode } from '../../utils/support';\nimport { HMSLocalTrack, HMSLocalVideoTrack } from '../tracks';\n\nexport default class HMSLocalStream extends HMSMediaStream {\n  /** Connection set when publish is called for the first track */\n  private readonly TAG = '[HMSLocalStream]';\n  private connection: HMSPublishConnection | null = null;\n\n  setConnection(connection: HMSPublishConnection) {\n    this.connection = connection;\n  }\n\n  addTransceiver(track: HMSLocalTrack, simulcastLayers: SimulcastLayer[]) {\n    const trackEncodings: RTCRtpEncodingParameters[] = [];\n    if (track instanceof HMSLocalVideoTrack) {\n      if (simulcastLayers.length > 0) {\n        HMSLogger.v(this.TAG, 'Simulcast enabled with layers', simulcastLayers);\n        trackEncodings.push(...simulcastLayers);\n      } else {\n        const encodings: RTCRtpEncodingParameters = { active: this.nativeStream.active };\n        if (track.settings.maxBitrate && !isNode) {\n          encodings.maxBitrate = track.settings.maxBitrate;\n        }\n        trackEncodings.push(encodings);\n      }\n    }\n\n    const transceiver = this.connection!.addTransceiver(track.getTrackBeingSent(), {\n      streams: [this.nativeStream],\n      direction: 'sendonly',\n      sendEncodings: trackEncodings,\n    });\n    this.setPreferredCodec(transceiver, track.nativeTrack.kind);\n    return transceiver;\n  }\n\n  async setMaxBitrateAndFramerate(track: HMSLocalTrack): Promise<void> {\n    await this.connection?.setMaxBitrateAndFramerate(track);\n  }\n\n  // @ts-ignore\n  setPreferredCodec(_transceiver: RTCRtpTransceiver, _kind: string) {\n    // TODO: Some browsers don't support setCodecPreferences, resort to SDPMunging?\n  }\n\n  /**\n   * On mute and unmute of video tracks as well as for changing cameras, we replace the track using replaceTrack api\n   * so as to avoid a renegotiation with the backend and reflect changes faster.\n   * @param track - the current track\n   * @param withTrack - the track to replace it with\n   */\n  async replaceTrack(track: MediaStreamTrack, withTrack: MediaStreamTrack) {\n    await this.replaceSenderTrack(track, withTrack);\n    track.stop(); // If the track is already stopped, this does not throw any error. \uD83D\uDE09\n    this.replaceStreamTrack(track, withTrack);\n  }\n\n  replaceStreamTrack(track: MediaStreamTrack, withTrack: MediaStreamTrack) {\n    this.nativeStream.addTrack(withTrack);\n    this.nativeStream.removeTrack(track);\n  }\n\n  /**\n   * In case of video plugins we need to replace the track sent to remote without stopping the original one. As\n   * if the original is stopped, plugin would stop getting input frames to process. So only the track in the\n   * sender needs to be replaced.\n   */\n  async replaceSenderTrack(track: MediaStreamTrack, withTrack: MediaStreamTrack) {\n    const sender = this.connection?.getSenders().find(sender => sender.track && sender.track.id === track.id);\n\n    if (sender === undefined) {\n      HMSLogger.w(this.TAG, `No sender found for trackId=${track.id}`);\n      return;\n    }\n    await sender.replaceTrack(withTrack);\n  }\n\n  removeSender(track: HMSLocalTrack) {\n    let removedSenderCount = 0;\n    this.connection?.getSenders().forEach(sender => {\n      if (sender.track?.id === track.trackId || sender.track?.id === track.getTrackIDBeingSent()) {\n        this.connection!.removeTrack(sender);\n        removedSenderCount += 1;\n\n        // Remove the local reference as well\n        const toRemoveLocalTrackIdx = this.tracks.indexOf(track);\n        if (toRemoveLocalTrackIdx !== -1) {\n          this.tracks.splice(toRemoveLocalTrackIdx, 1);\n        } else {\n          HMSLogger.e(this.TAG, `Cannot find ${track.trackId} in locally stored tracks`);\n        }\n      }\n    });\n    if (removedSenderCount !== 1) {\n      HMSLogger.e(this.TAG, `Removed ${removedSenderCount} sender's, expected to remove 1`);\n    }\n  }\n\n  hasSender(track: HMSLocalTrack): boolean {\n    return !!this.connection\n      ?.getSenders()\n      .find(sender => sender.track?.id === track.trackId || sender.track?.id === track.getTrackIDBeingSent());\n  }\n\n  trackUpdate(track: HMSLocalTrack) {\n    this.connection?.trackUpdate(track);\n  }\n}\n", "import AnalyticsEventFactory from '../analytics/AnalyticsEventFactory';\nimport { EventBus } from '../events/EventBus';\nimport { HMSUpdateListener } from '../interfaces';\nimport { NetworkHealth, ScoreMap } from '../signal/init/models';\nimport HMSLogger from '../utils/logger';\nimport { sleep } from '../utils/timer-utils';\n\nexport class NetworkTestManager {\n  private readonly TAG = '[NetworkTestManager]';\n  private controller = new AbortController();\n  private score?: number;\n  constructor(private eventBus: EventBus, private listener?: HMSUpdateListener) {}\n\n  start = async (networkHealth: NetworkHealth) => {\n    if (!networkHealth) {\n      return;\n    }\n    const { url, timeout, scoreMap } = networkHealth;\n    const signal = this.controller.signal;\n\n    const startTime = Date.now();\n    let downloadedSize = 0;\n    const timeoutPromise = sleep(timeout).then(() => {\n      this.controller.abort();\n    });\n    try {\n      const res = await fetch(`${url}?${Date.now()}`, { signal });\n      const reader = res.body?.getReader();\n      if (!reader) {\n        throw Error('unable to process request');\n      }\n      const readData = async () => {\n        if (!reader) {\n          return;\n        }\n        try {\n          let completed = false;\n          while (!completed) {\n            const { value, done } = await reader.read();\n            completed = done;\n            if (value) {\n              downloadedSize += value.byteLength;\n              this.sendScore({ scoreMap, downloadedSize, startTime });\n            }\n          }\n        } catch (error) {\n          if ((error as Error).name !== 'AbortError') {\n            HMSLogger.e(this.TAG, error);\n          }\n        }\n      };\n\n      return Promise.race([readData(), timeoutPromise])\n        .then(() => {\n          this.sendScore({ scoreMap, downloadedSize, startTime, finished: true });\n        })\n        .catch(error => {\n          HMSLogger.e(this.TAG, error);\n          this.updateScoreToListener(0);\n          this.eventBus.analytics.publish(\n            AnalyticsEventFactory.previewNetworkQuality({ error: (error as Error).message }),\n          );\n        });\n    } catch (error) {\n      if ((error as Error).name !== 'AbortError') {\n        HMSLogger.e(this.TAG, error);\n        this.updateScoreToListener(0);\n        this.eventBus.analytics.publish(\n          AnalyticsEventFactory.previewNetworkQuality({ error: (error as Error).message }),\n        );\n      } else {\n        HMSLogger.d(this.TAG, error);\n      }\n    }\n  };\n\n  stop = () => {\n    if (!this.controller.signal.aborted) {\n      this.controller.abort();\n    }\n  };\n\n  private sendScore = ({\n    scoreMap,\n    downloadedSize,\n    startTime,\n    finished = false,\n  }: {\n    scoreMap: ScoreMap;\n    downloadedSize: number;\n    startTime: number;\n    finished?: boolean;\n  }) => {\n    const totalTimeInSecs = (Date.now() - startTime) / 1000;\n    const sizeInKB = downloadedSize / 1024;\n    const bitrate = (sizeInKB / totalTimeInSecs) * 8;\n    let calculatedScore = -1;\n    for (const score in scoreMap) {\n      const thresholds = scoreMap[score];\n      if (bitrate >= thresholds.low && (!thresholds.high || bitrate <= thresholds.high)) {\n        calculatedScore = Number(score);\n      }\n    }\n    this.updateScoreToListener(calculatedScore);\n    if (finished) {\n      this.eventBus.analytics.publish(\n        AnalyticsEventFactory.previewNetworkQuality({ score: calculatedScore, downLink: bitrate.toFixed(2) }),\n      );\n    }\n  };\n\n  private updateScoreToListener(newQualityScore: number) {\n    if (newQualityScore === this.score) {\n      return;\n    }\n    this.score = newQualityScore;\n    this.listener?.onNetworkQuality?.(newQualityScore);\n  }\n}\n", "import { IStore } from './store';\nimport { HMSRole } from '../interfaces';\nimport InitialSettings from '../interfaces/settings';\nimport { SimulcastLayers } from '../interfaces/simulcast-layers';\nimport { HMSPeerUpdate, HMSTrackUpdate, HMSUpdateListener } from '../interfaces/update-listener';\nimport { HMSLocalTrack } from '../media/tracks';\nimport ITransport from '../transport/ITransport';\n\nexport default class RoleChangeManager {\n  constructor(\n    private store: IStore,\n    private transport: ITransport,\n    private publish: (settings: InitialSettings) => Promise<void>,\n    private removeAuxiliaryTrack: (trackId: string) => void,\n    private listener?: HMSUpdateListener,\n  ) {}\n\n  handleLocalPeerRoleUpdate = async ({ oldRole, newRole }: { oldRole: HMSRole; newRole: HMSRole }) => {\n    const localPeer = this.store.getLocalPeer();\n\n    if (!localPeer) {\n      return;\n    }\n\n    await this.diffRolesAndPublishTracks({ oldRole, newRole });\n    this.listener?.onPeerUpdate(HMSPeerUpdate.ROLE_UPDATED, localPeer);\n  };\n\n  diffRolesAndPublishTracks = async ({ oldRole, newRole }: { oldRole: HMSRole; newRole: HMSRole }) => {\n    const wasPublishing = new Set(oldRole.publishParams.allowed);\n    const isPublishing = new Set(newRole.publishParams.allowed);\n\n    const removeVideo = this.removeTrack(wasPublishing, isPublishing, 'video');\n    const videoHasSimulcastDifference = this.hasSimulcastDifference(\n      oldRole.publishParams.simulcast?.video,\n      newRole.publishParams.simulcast?.video,\n    );\n    const removeAudio = this.removeTrack(wasPublishing, isPublishing, 'audio');\n    const removeScreen = this.removeTrack(wasPublishing, isPublishing, 'screen');\n    const screenHasSimulcastDifference = this.hasSimulcastDifference(\n      oldRole.publishParams.simulcast?.screen,\n      newRole.publishParams.simulcast?.screen,\n    );\n    await this.removeAudioTrack(removeAudio);\n    await this.removeVideoTracks(removeVideo || videoHasSimulcastDifference);\n    await this.removeScreenTracks(removeScreen || screenHasSimulcastDifference);\n\n    const initialSettings = this.store.getConfig()?.settings || {\n      isAudioMuted: true,\n      isVideoMuted: true,\n      audioInputDeviceId: 'default',\n      videoDeviceId: 'default',\n      audioOutputDeviceId: 'default',\n    };\n    // call publish with new settings, local track manager will diff policies\n    await this.publish({ ...initialSettings, isAudioMuted: true, isVideoMuted: true });\n  };\n\n  private async removeVideoTracks(removeVideo: boolean) {\n    if (!removeVideo) {\n      return;\n    }\n    const localPeer = this.store.getLocalPeer();\n    // TODO check auxillary tracks for regular audio and video too\n    if (localPeer?.videoTrack) {\n      // TODO: stop processed track and cleanup plugins loop non async\n      // vb can throw change role off otherwise\n      if (localPeer.videoTrack.isPublished) {\n        await this.transport.unpublish([localPeer.videoTrack]);\n      } else {\n        await localPeer.videoTrack.cleanup();\n      }\n      this.listener?.onTrackUpdate(HMSTrackUpdate.TRACK_REMOVED, localPeer.videoTrack, localPeer);\n      localPeer.videoTrack = undefined;\n    }\n    await this.removeAuxTracks(track => track.source !== 'screen' && track.type === 'video');\n  }\n\n  private async removeAudioTrack(removeAudio: boolean) {\n    if (!removeAudio) {\n      return;\n    }\n    const localPeer = this.store.getLocalPeer();\n    if (localPeer?.audioTrack) {\n      if (localPeer.audioTrack.isPublished) {\n        await this.transport.unpublish([localPeer.audioTrack]);\n      } else {\n        await localPeer.audioTrack.cleanup();\n      }\n      this.listener?.onTrackUpdate(HMSTrackUpdate.TRACK_REMOVED, localPeer.audioTrack, localPeer);\n      localPeer.audioTrack = undefined;\n    }\n    await this.removeAuxTracks(track => track.source !== 'screen' && track.type === 'audio');\n  }\n\n  private async removeScreenTracks(removeScreen: boolean) {\n    if (!removeScreen) {\n      return;\n    }\n    await this.removeAuxTracks(track => track.source === 'screen');\n  }\n\n  private async removeAuxTracks(predicate: (track: HMSLocalTrack) => boolean) {\n    const localPeer = this.store.getLocalPeer();\n    if (localPeer?.auxiliaryTracks) {\n      const localAuxTracks = [...localPeer.auxiliaryTracks];\n      for (const track of localAuxTracks) {\n        if (predicate(track)) {\n          await this.removeAuxiliaryTrack(track.trackId);\n        }\n      }\n    }\n  }\n\n  private removeTrack(wasPublishing: Set<string>, isPublishing: Set<string>, type: string) {\n    return wasPublishing.has(type) && !isPublishing.has(type);\n  }\n\n  private hasSimulcastDifference(oldLayers?: SimulcastLayers, newLayers?: SimulcastLayers) {\n    if (!oldLayers && !newLayers) {\n      return false;\n    }\n    if (oldLayers?.layers?.length !== newLayers?.layers?.length) {\n      return true;\n    }\n    return false;\n  }\n}\n", "import AnalyticsEvent from './AnalyticsEvent';\nimport { IAnalyticsTransportProvider } from './IAnalyticsTransportProvider';\nimport {\n  CLIENT_ANAYLTICS_PROD_ENDPOINT,\n  CLIENT_ANAYLTICS_QA_ENDPOINT,\n  CLIENT_ANAYLTICS_STORAGE_LIMIT,\n} from '../utils/constants';\nimport { LocalStorage } from '../utils/local-storage';\nimport HMSLogger from '../utils/logger';\nimport { ENV } from '../utils/support';\n\ninterface ClientEventBody {\n  event: string;\n  event_id: string;\n  peer: {\n    peer_id?: string;\n    role?: string;\n    joined_at?: number;\n    left_at?: number;\n    room_id?: string;\n    room_name?: string;\n    session_started_at?: number;\n    user_data?: string;\n    user_name?: string;\n    template_id?: string;\n    session_id?: string;\n  };\n  timestamp: number;\n  cluster: {\n    websocket_url: string;\n  };\n  payload: Record<string, any>;\n  device_id: string;\n}\n\nclass ClientAnalyticsTransport implements IAnalyticsTransportProvider {\n  readonly TAG = '[HTTPAnalyticsTransport]';\n  private failedEvents = new LocalStorage<AnalyticsEvent[]>('client-events');\n  isConnected = true;\n  private env: null | ENV = null;\n  private websocketURL = '';\n\n  setEnv(env: ENV) {\n    this.env = env;\n    this.flushFailedEvents();\n  }\n\n  setWebsocketEndpoint(ws: string) {\n    this.websocketURL = ws;\n  }\n\n  sendEvent(event: AnalyticsEvent) {\n    if (!this.env || !this.websocketURL) {\n      this.addEventToStorage(event);\n      return;\n    }\n    const requestBody: ClientEventBody = {\n      event: event.name,\n      payload: event.properties,\n      event_id: String(event.timestamp),\n      peer: event.metadata.peer,\n      timestamp: event.timestamp,\n      device_id: event.device_id,\n      cluster: {\n        websocket_url: this.websocketURL,\n      },\n    };\n    const url = this.env === ENV.PROD ? CLIENT_ANAYLTICS_PROD_ENDPOINT : CLIENT_ANAYLTICS_QA_ENDPOINT;\n    fetch(url, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n        Authorization: `Bearer ${event.metadata.token}`,\n        user_agent_v2: event.metadata.userAgent,\n      },\n      body: JSON.stringify(requestBody),\n    })\n      .then(response => {\n        // Ignore invalid token or expired token messages\n        if (response.status === 401) {\n          this.removeFromStorage(event);\n          return;\n        }\n        if (response.status !== 200) {\n          throw Error(response.statusText);\n        }\n        this.removeFromStorage(event);\n      })\n      .catch(error => {\n        HMSLogger.v(this.TAG, 'Failed to send event', error, event);\n        this.addEventToStorage(event);\n      });\n  }\n  flushFailedEvents() {\n    const events = this.failedEvents.get();\n    events?.forEach(event => this.sendEvent(event));\n  }\n\n  private addEventToStorage(event: AnalyticsEvent): void {\n    const existingEvents = this.failedEvents.get() || [];\n    if (!existingEvents.find(existingEvent => existingEvent.timestamp === event.timestamp)) {\n      if (existingEvents.length === CLIENT_ANAYLTICS_STORAGE_LIMIT) {\n        existingEvents.shift();\n      }\n      existingEvents.push(event);\n      this.failedEvents.set(existingEvents);\n    }\n  }\n\n  private removeFromStorage(event: AnalyticsEvent): void {\n    const events = this.failedEvents.get() || [];\n    const index = events.findIndex(storageEvent => storageEvent.timestamp === event.timestamp);\n    if (index > -1) {\n      events.splice(index, 1);\n      this.failedEvents.set(events);\n    }\n  }\n}\n\nexport const HTTPAnalyticsTransport = new ClientAnalyticsTransport();\n", "import { IStore, KnownRoles, TrackStateEntry } from './IStore';\nimport { HTTPAnalyticsTransport } from '../../analytics/HTTPAnalyticsTransport';\nimport { SelectedDevices } from '../../device-manager';\nimport { DeviceStorageManager } from '../../device-manager/DeviceStorage';\nimport { ErrorFactory, HMSAction } from '../../error/ErrorFactory';\nimport { HMSConfig, HMSFrameworkInfo, HMSSpeaker } from '../../interfaces';\nimport { IErrorListener } from '../../interfaces/error-listener';\nimport {\n  HMSSimulcastLayerDefinition,\n  RID,\n  SimulcastLayer,\n  SimulcastLayers,\n  simulcastMapping,\n} from '../../interfaces/simulcast-layers';\nimport {\n  HMSAudioTrack,\n  HMSLocalTrack,\n  HMSRemoteVideoTrack,\n  HMSTrack,\n  HMSTrackSource,\n  HMSTrackType,\n  HMSVideoTrack,\n} from '../../media/tracks';\nimport { PolicyParams } from '../../notification-manager';\nimport { ENV } from '../../utils/support';\nimport { createUserAgent } from '../../utils/user-agent';\nimport HMSRoom from '../models/HMSRoom';\nimport { HMSLocalPeer, HMSPeer, HMSRemotePeer } from '../models/peer';\n\nclass Store implements IStore {\n  private room?: HMSRoom;\n  private knownRoles: KnownRoles = {};\n  private localPeerId?: string;\n  private peers: Record<string, HMSPeer> = {};\n  private tracks: Record<string, HMSTrack> = {};\n  // Not used currently. Will be used exclusively for preview tracks.\n  // private previewTracks: Record<string, HMSTrack> = {};\n  private peerTrackStates: Record<string, TrackStateEntry> = {};\n  private speakers: HMSSpeaker[] = [];\n  private videoLayers?: SimulcastLayers;\n  // private screenshareLayers?: SimulcastLayers;\n  private config?: HMSConfig;\n  private errorListener?: IErrorListener;\n  private roleDetailsArrived = false;\n  private env: ENV = ENV.PROD;\n  private simulcastEnabled = false;\n  private userAgent: string = createUserAgent(this.env);\n\n  getConfig() {\n    return this.config;\n  }\n\n  setSimulcastEnabled(enabled: boolean) {\n    this.simulcastEnabled = enabled;\n  }\n\n  getEnv() {\n    return this.env;\n  }\n\n  getPublishParams() {\n    const peer = this.getLocalPeer();\n    const role = peer?.asRole || peer?.role;\n    return role?.publishParams;\n  }\n\n  getRoom() {\n    return this.room!;\n  }\n\n  getPolicyForRole(role: string) {\n    return this.knownRoles[role];\n  }\n\n  getKnownRoles() {\n    return this.knownRoles;\n  }\n\n  getLocalPeer() {\n    if (this.localPeerId && this.peers[this.localPeerId]) {\n      return this.peers[this.localPeerId] as HMSLocalPeer;\n    }\n    return undefined;\n  }\n\n  getRemotePeers() {\n    return Object.values(this.peers).filter(peer => !peer.isLocal) as HMSRemotePeer[];\n  }\n\n  getPeers(): HMSPeer[] {\n    return Object.values(this.peers);\n  }\n\n  getPeerById(peerId: string) {\n    if (this.peers[peerId]) {\n      return this.peers[peerId];\n    }\n    return undefined;\n  }\n\n  getTracksMap() {\n    return this.tracks;\n  }\n\n  getTracks() {\n    return Object.values(this.tracks);\n  }\n\n  getVideoTracks() {\n    return this.getTracks().filter(track => track.type === HMSTrackType.VIDEO) as HMSVideoTrack[];\n  }\n\n  getRemoteVideoTracks() {\n    return this.getTracks().filter(track => track instanceof HMSRemoteVideoTrack) as HMSRemoteVideoTrack[];\n  }\n\n  getAudioTracks() {\n    return this.getTracks().filter(track => track.type === HMSTrackType.AUDIO) as HMSAudioTrack[];\n  }\n\n  getPeerTracks(peerId?: string) {\n    const peer = peerId ? this.peers[peerId] : undefined;\n    const tracks: HMSTrack[] = [];\n    peer?.videoTrack && tracks.push(peer.videoTrack);\n    peer?.audioTrack && tracks.push(peer.audioTrack);\n    return tracks.concat(peer?.auxiliaryTracks || []);\n  }\n\n  getLocalPeerTracks() {\n    return this.getPeerTracks(this.localPeerId) as HMSLocalTrack[];\n  }\n\n  getTrackById(trackId: string) {\n    const track = this.tracks[trackId];\n    if (track) {\n      return track;\n    }\n    const localPeer = this.getLocalPeer();\n    /**\n     * handle case of audio level coming from server for local peer's track where local peer\n     * didn't initially gave audio permission. So track.firstTrackId is that of dummy track and\n     * this.tracks[trackId] doesn't exist.\n     * Example repro which this solves -\n     * - call preview with audio muted, unmute audio in preview then join the room, now initial\n     * track id is that from dummy track but the track id which server knows will be different\n     */\n    if (localPeer) {\n      if (localPeer.audioTrack?.isPublishedTrackId(trackId)) {\n        return localPeer.audioTrack;\n      } else if (localPeer.videoTrack?.isPublishedTrackId(trackId)) {\n        return localPeer.videoTrack;\n      }\n    }\n    return undefined;\n  }\n\n  getPeerByTrackId(trackId: string) {\n    const track = this.tracks[trackId];\n    return track.peerId ? this.peers[track.peerId] : undefined;\n  }\n\n  getSpeakers() {\n    return this.speakers;\n  }\n\n  getSpeakerPeers() {\n    return this.speakers.map(speaker => speaker.peer);\n  }\n\n  getUserAgent() {\n    return this.userAgent;\n  }\n\n  createAndSetUserAgent(frameworkInfo?: HMSFrameworkInfo) {\n    this.userAgent = createUserAgent(this.env, frameworkInfo);\n  }\n\n  setRoom(room: HMSRoom) {\n    this.room = room;\n  }\n\n  setKnownRoles(params: PolicyParams) {\n    this.knownRoles = params.known_roles;\n    this.roleDetailsArrived = true;\n    if (!this.simulcastEnabled) {\n      return;\n    }\n    const publishParams = this.knownRoles[params.name]?.publishParams;\n    this.videoLayers = this.convertSimulcastLayers(publishParams.simulcast?.video);\n    // this.screenshareLayers = this.convertSimulcastLayers(publishParams.simulcast?.screen);\n    this.updatePeersPolicy();\n  }\n\n  hasRoleDetailsArrived(): boolean {\n    return this.roleDetailsArrived;\n  }\n\n  // eslint-disable-next-line complexity\n  setConfig(config: HMSConfig) {\n    DeviceStorageManager.rememberDevices(Boolean(config.rememberDeviceSelection));\n    if (config.rememberDeviceSelection) {\n      const devices: SelectedDevices | undefined = DeviceStorageManager.getSelection();\n      if (devices) {\n        if (!config.settings) {\n          config.settings = {};\n        }\n        if (devices.audioInput?.deviceId) {\n          config.settings.audioInputDeviceId = config.settings.audioInputDeviceId || devices.audioInput.deviceId;\n        }\n        if (devices.audioOutput?.deviceId) {\n          config.settings.audioOutputDeviceId = config.settings.audioOutputDeviceId || devices.audioOutput.deviceId;\n        }\n        if (devices.videoInput?.deviceId) {\n          config.settings.videoDeviceId = config.settings.videoDeviceId || devices.videoInput.deviceId;\n        }\n      }\n    }\n    this.config = config;\n    this.setEnv();\n  }\n\n  addPeer(peer: HMSPeer) {\n    this.peers[peer.peerId] = peer;\n    if (peer.isLocal) {\n      this.localPeerId = peer.peerId;\n    }\n  }\n\n  /**\n   * @param {HMSTrack} track the published track that has to be added\n   *\n   * Note: Only use this method to add published tracks not preview traks\n   */\n  addTrack(track: HMSTrack) {\n    this.tracks[track.trackId] = track;\n  }\n\n  getTrackState(trackId: string) {\n    return this.peerTrackStates[trackId];\n  }\n\n  setTrackState(trackStateEntry: TrackStateEntry) {\n    this.peerTrackStates[trackStateEntry.trackInfo.track_id] = trackStateEntry;\n  }\n\n  removePeer(peerId: string) {\n    if (this.localPeerId === peerId) {\n      this.localPeerId = undefined;\n    }\n    delete this.peers[peerId];\n  }\n\n  removeTrack(trackId: string) {\n    delete this.tracks[trackId];\n  }\n\n  updateSpeakers(speakers: HMSSpeaker[]) {\n    this.speakers = speakers;\n  }\n\n  async updateAudioOutputVolume(value: number) {\n    for (const track of this.getAudioTracks()) {\n      await track.setVolume(value);\n    }\n  }\n\n  async updateAudioOutputDevice(device: MediaDeviceInfo) {\n    const promises: Promise<void>[] = [];\n    this.getAudioTracks().forEach(track => {\n      promises.push(track.setOutputDevice(device));\n    });\n    await Promise.all(promises);\n  }\n\n  getSimulcastLayers(source: HMSTrackSource): SimulcastLayer[] {\n    if (!this.simulcastEnabled) {\n      return [];\n    }\n    if (source === 'screen') {\n      return []; //this.screenshareLayers?.layers || []; uncomment this when screenshare simulcast supported\n    }\n    return this.videoLayers?.layers || [];\n  }\n\n  /**\n   * Convert maxBitrate from kbps to bps\n   * @internal\n   * @param simulcastLayers\n   * @returns {SimulcastLayers}\n   */\n  private convertSimulcastLayers(simulcastLayers?: SimulcastLayers) {\n    if (!simulcastLayers) {\n      return;\n    }\n    return {\n      ...simulcastLayers,\n      layers: (simulcastLayers.layers || []).map(layer => {\n        return {\n          ...layer,\n          maxBitrate: layer.maxBitrate * 1000,\n        };\n      }),\n    };\n  }\n\n  getSimulcastDefinitionsForPeer(peer: HMSPeer, source: HMSTrackSource) {\n    // TODO: remove screen check when screenshare simulcast is supported\n    if ([!peer || !peer.role, source === 'screen', !this.simulcastEnabled].some(value => !!value)) {\n      return [];\n    }\n\n    const publishParams = this.getPolicyForRole(peer.role!.name).publishParams;\n    let simulcastLayers: SimulcastLayers | undefined;\n    let width: number;\n    let height: number;\n    if (source === 'regular') {\n      simulcastLayers = publishParams.simulcast?.video;\n      width = publishParams.video.width;\n      height = publishParams.video.height;\n    } else if (source === 'screen') {\n      simulcastLayers = publishParams.simulcast?.screen;\n      width = publishParams.screen.width;\n      height = publishParams.screen.height;\n    }\n    return (\n      simulcastLayers?.layers?.map(value => {\n        const layer = simulcastMapping[value.rid as RID];\n        const resolution = {\n          width: width / value.scaleResolutionDownBy,\n          height: height / value.scaleResolutionDownBy,\n        };\n        return {\n          layer,\n          resolution,\n        } as HMSSimulcastLayerDefinition;\n      }) || []\n    );\n  }\n\n  getErrorListener() {\n    return this.errorListener;\n  }\n\n  cleanUp() {\n    const tracks = this.getTracks();\n    for (const track of tracks) {\n      track.cleanup();\n    }\n    this.room = undefined;\n    this.config = undefined;\n    this.localPeerId = undefined;\n    this.roleDetailsArrived = false;\n  }\n\n  setErrorListener(listener: IErrorListener) {\n    this.errorListener = listener;\n  }\n\n  private updatePeersPolicy() {\n    this.getPeers().forEach(peer => {\n      if (!peer.role) {\n        this.errorListener?.onError(ErrorFactory.GenericErrors.InvalidRole(HMSAction.VALIDATION, ''));\n        return;\n      }\n      peer.role = this.getPolicyForRole(peer.role.name);\n    });\n  }\n\n  private setEnv() {\n    const endPoint = this.config?.initEndpoint!;\n    const url = endPoint.split('https://')[1];\n    let env: ENV = ENV.PROD;\n    if (url.startsWith(ENV.PROD)) {\n      env = ENV.PROD;\n    } else if (url.startsWith(ENV.QA)) {\n      env = ENV.QA;\n    } else if (url.startsWith(ENV.DEV)) {\n      env = ENV.DEV;\n    }\n    this.env = env;\n    HTTPAnalyticsTransport.setEnv(env);\n  }\n}\n\nexport { Store };\n", "import AnalyticsEvent from './AnalyticsEvent';\nimport { HMSAnalyticsLevel } from './AnalyticsEventLevel';\nimport { AnalyticsTransport } from './AnalyticsTransport';\nimport { HTTPAnalyticsTransport } from './HTTPAnalyticsTransport';\nimport { IStore } from '../sdk/store';\nimport { ANALYTICS_BUFFER_SIZE } from '../utils/constants';\nimport HMSLogger from '../utils/logger';\n\nexport class AnalyticsEventsService {\n  private bufferSize = ANALYTICS_BUFFER_SIZE;\n  private readonly TAG = '[AnalyticsEventsService]';\n\n  private transport: AnalyticsTransport | null = null;\n  private pendingEvents: AnalyticsEvent[] = [];\n\n  level: HMSAnalyticsLevel = HMSAnalyticsLevel.INFO;\n\n  constructor(private store: IStore) {}\n\n  setTransport(transport: AnalyticsTransport) {\n    this.transport = transport;\n  }\n\n  reset() {\n    this.transport = null;\n    this.pendingEvents = [];\n  }\n\n  queue(event: AnalyticsEvent) {\n    if (event.level >= this.level) {\n      this.pendingEvents.push(event);\n\n      if (this.pendingEvents.length > this.bufferSize) {\n        const removedEvent = this.pendingEvents.shift();\n        HMSLogger.d(this.TAG, 'Max buffer size reached', 'Removed event to accommodate new events', removedEvent);\n      }\n    }\n    return this;\n  }\n\n  flushFailedClientEvents() {\n    HTTPAnalyticsTransport.flushFailedEvents();\n  }\n\n  flush() {\n    try {\n      while (this.pendingEvents.length > 0) {\n        const event = this.pendingEvents.shift();\n        if (event) {\n          event.metadata.peer.peer_id = this.store.getLocalPeer()?.peerId;\n          event.metadata.userAgent = this.store.getUserAgent();\n          if (this.transport && this.transport.transportProvider.isConnected) {\n            this.transport.sendEvent(event);\n          } else {\n            this.sendClientEventOnHTTP(event);\n          }\n        }\n      }\n    } catch (error) {\n      HMSLogger.w(this.TAG, 'Flush Failed', error);\n    }\n  }\n\n  private sendClientEventOnHTTP(event: AnalyticsEvent) {\n    const room = this.store.getRoom();\n    const localPeer = this.store.getLocalPeer();\n    event.metadata.token = this.store.getConfig()?.authToken;\n    event.metadata.peer = {\n      session_id: room.sessionId,\n      room_id: room.id,\n      room_name: room.name,\n      template_id: room.templateId,\n      joined_at: room.joinedAt?.getTime(),\n      session_started_at: room.startedAt?.getTime(),\n      role: localPeer?.role?.name,\n      user_name: localPeer?.name,\n      user_data: localPeer?.metadata,\n    };\n    HTTPAnalyticsTransport.sendEvent(event);\n  }\n}\n", "import { v4 as uuid } from 'uuid';\nimport AnalyticsEventFactory from '../analytics/AnalyticsEventFactory';\nimport { DeviceManager } from '../device-manager';\nimport { ErrorFactory, HMSAction } from '../error/ErrorFactory';\nimport { EventBus } from '../events/EventBus';\nimport { HMSDeviceChangeEvent, HMSTrackUpdate, HMSUpdateListener } from '../interfaces';\nimport { HMSRemoteAudioTrack } from '../media/tracks';\nimport { HMSRemotePeer } from '../sdk/models/peer';\nimport { IStore } from '../sdk/store';\nimport HMSLogger from '../utils/logger';\nimport { isMobile } from '../utils/support';\nimport { sleep } from '../utils/timer-utils';\n\n/**\n * Following are the errors thrown when autoplay is blocked in different browsers\n * Firefox - DOMException: The play method is not allowed by the user agent or the platform in the current context, possibly because the user denied permission.\n * Safari - NotAllowedError: The request is not allowed by the user agent or the platform in the current context, possibly because the user denied permission.\n * Chrome - DOMException: play() failed because the user didn't interact with the document first.\n * Brave - DOMException: play() can only be initiated by a user gesture.\n */\ntype AudioSinkState = {\n  autoplayFailed?: boolean;\n  initialized: boolean;\n  // this promise will be set for the first track. remaining tracks will be processed once it's know whether\n  // autoplay is allowed or not\n  autoplayCheckPromise?: Promise<void>;\n};\n\nconst INITIAL_STATE: AudioSinkState = {\n  autoplayFailed: undefined,\n  initialized: false,\n  autoplayCheckPromise: undefined,\n};\n\nconst TRACK_PLAYBACK_RETRIES = 3;\n\nexport class AudioSinkManager {\n  private audioSink?: HTMLElement;\n  private autoPausedTracks: Set<HMSRemoteAudioTrack> = new Set();\n  private readonly TAG = '[AudioSinkManager]:';\n  private volume = 100;\n  private state = { ...INITIAL_STATE };\n  private listener?: HMSUpdateListener;\n  private retryCountMapping = new Map<string, number>();\n\n  constructor(private store: IStore, private deviceManager: DeviceManager, private eventBus: EventBus) {\n    this.eventBus.audioTrackAdded.subscribe(this.handleTrackAdd);\n    this.eventBus.audioTrackRemoved.subscribe(this.handleTrackRemove);\n    this.eventBus.audioTrackUpdate.subscribe(this.handleTrackUpdate);\n    this.eventBus.deviceChange.subscribe(this.handleAudioDeviceChange);\n  }\n\n  setListener(listener?: HMSUpdateListener) {\n    this.listener = listener;\n  }\n\n  private get outputDevice() {\n    return this.deviceManager.outputDevice;\n  }\n\n  getVolume() {\n    return this.volume;\n  }\n\n  async setVolume(value: number) {\n    await this.store.updateAudioOutputVolume(value);\n    this.volume = value;\n  }\n\n  /**\n   *  This function is to be called only on user interaction when\n   *  autoplay error is received.\n   */\n  async unblockAutoplay() {\n    if (this.autoPausedTracks.size > 0) {\n      this.unpauseAudioTracks();\n    }\n  }\n\n  init(elementId?: string) {\n    if (this.state.initialized) {\n      return;\n    }\n    this.state.initialized = true;\n    const audioSink = document.createElement('div');\n    audioSink.id = `HMS-SDK-audio-sink-${uuid()}`;\n    const userElement = elementId && document.getElementById(elementId);\n    const audioSinkParent = userElement || document.body;\n    audioSinkParent.append(audioSink);\n\n    this.audioSink = audioSink;\n  }\n\n  cleanUp() {\n    this.audioSink?.remove();\n    this.audioSink = undefined;\n    this.retryCountMapping.clear();\n    this.eventBus.audioTrackAdded.unsubscribe(this.handleTrackAdd);\n    this.eventBus.audioTrackRemoved.unsubscribe(this.handleTrackRemove);\n    this.eventBus.audioTrackUpdate.unsubscribe(this.handleTrackUpdate);\n    this.eventBus.deviceChange.unsubscribe(this.handleAudioDeviceChange);\n    this.autoPausedTracks = new Set();\n    this.state = { ...INITIAL_STATE };\n  }\n\n  private handleAudioPaused = async (event: any) => {\n    const audioEl = event.target as HTMLAudioElement;\n    //@ts-ignore\n    const track = audioEl.srcObject?.getAudioTracks()[0];\n    if (!track?.enabled) {\n      // No need to play if already disabled\n      return;\n    }\n    // this means the audio paused because of external factors(headset removal)\n    HMSLogger.d(this.TAG, 'Audio Paused', event.target.id);\n    const audioTrack = this.store.getTrackById(event.target.id);\n    if (audioTrack) {\n      if (isMobile()) {\n        // Play after a delay since mobile devices don't call onDevice change event\n        await sleep(500);\n        this.playAudioFor(audioTrack as HMSRemoteAudioTrack);\n      } else {\n        this.autoPausedTracks.add(audioTrack as HMSRemoteAudioTrack);\n      }\n    }\n  };\n\n  private handleTrackUpdate = ({ track }: { track: HMSRemoteAudioTrack; enabled: boolean }) => {\n    HMSLogger.d(this.TAG, 'Track updated', `${track}`);\n  };\n\n  private handleTrackAdd = async ({\n    track,\n    peer,\n    callListener = true,\n  }: {\n    track: HMSRemoteAudioTrack;\n    peer: HMSRemotePeer;\n    callListener?: boolean;\n  }) => {\n    if (this.retryCountMapping.get(track.trackId) ?? 0 > TRACK_PLAYBACK_RETRIES) {\n      return;\n    }\n    const audioEl = document.createElement('audio');\n    audioEl.style.display = 'none';\n    audioEl.id = track.trackId;\n    audioEl.addEventListener('pause', this.handleAudioPaused);\n\n    audioEl.onerror = () => {\n      HMSLogger.e(this.TAG, 'error on audio element', audioEl.error);\n      const ex = ErrorFactory.TracksErrors.AudioPlaybackError(`Audio playback error for track - ${track.trackId}`);\n      this.eventBus.analytics.publish(AnalyticsEventFactory.audioPlaybackError(ex));\n      if (audioEl?.error?.code === MediaError.MEDIA_ERR_DECODE) {\n        this.removeAudioElement(audioEl, track);\n        this.retryCountMapping.set(track.trackId, (this.retryCountMapping.get(track.trackId) ?? 0) + 1);\n        this.handleTrackAdd({ track, peer, callListener: false });\n      }\n    };\n\n    track.setAudioElement(audioEl);\n    track.setVolume(this.volume);\n    HMSLogger.d(this.TAG, 'Audio track added', `${track}`);\n    await this.init(); // call to create sink element if not already created\n    this.audioSink?.append(audioEl);\n    this.outputDevice && (await track.setOutputDevice(this.outputDevice));\n    audioEl.srcObject = new MediaStream([track.nativeTrack]);\n    callListener && this.listener?.onTrackUpdate(HMSTrackUpdate.TRACK_ADDED, track, peer);\n    await this.handleAutoplayError(track);\n  };\n\n  private handleAutoplayError = async (track: HMSRemoteAudioTrack) => {\n    /**\n     * if it's not known whether autoplay will succeed, wait for it to be known\n     */\n    if (this.state.autoplayFailed === undefined) {\n      if (!this.state.autoplayCheckPromise) {\n        // it's the first track, try to play it, that'll tell us whether autoplay is allowed\n        this.state.autoplayCheckPromise = new Promise<void>(resolve => {\n          this.playAudioFor(track).then(resolve);\n        });\n      }\n      // and wait for the result to be known\n      await this.state.autoplayCheckPromise;\n    }\n    /**\n     * Don't play the track if autoplay failed, add to paused list\n     */\n    if (this.state.autoplayFailed) {\n      this.autoPausedTracks.add(track);\n      return;\n    }\n    await this.playAudioFor(track);\n  };\n\n  private handleAudioDeviceChange = (event: HMSDeviceChangeEvent) => {\n    // if there is no selection that means this is an init request. No need to do anything\n    if (event.error || !event.selection || event.type === 'video') {\n      return;\n    }\n    this.unpauseAudioTracks();\n  };\n\n  /**\n   * try to play audio for the passed in track, assume autoplay error happened if play fails\n   * @param track\n   * @private\n   */\n  private async playAudioFor(track: HMSRemoteAudioTrack) {\n    const audioEl = track.getAudioElement();\n    if (!audioEl) {\n      HMSLogger.w(this.TAG, 'No audio element found on track', track.trackId);\n      return;\n    }\n    try {\n      await audioEl.play();\n      this.state.autoplayFailed = false;\n      this.autoPausedTracks.delete(track);\n      HMSLogger.d(this.TAG, 'Played track', `${track}`);\n    } catch (err) {\n      this.autoPausedTracks.add(track);\n      HMSLogger.e(this.TAG, 'Failed to play track', `${track}`, err as Error);\n      const error = err as Error;\n      if (!this.state.autoplayFailed && error.name === 'NotAllowedError') {\n        this.state.autoplayFailed = true;\n        const ex = ErrorFactory.TracksErrors.AutoplayBlocked(HMSAction.AUTOPLAY, '');\n        ex.addNativeError(error);\n        this.eventBus.analytics.publish(AnalyticsEventFactory.autoplayError());\n        this.eventBus.autoplayError.publish(ex);\n      }\n    }\n  }\n\n  private handleTrackRemove = (track: HMSRemoteAudioTrack) => {\n    this.autoPausedTracks.delete(track);\n    const audioEl = document.getElementById(track.trackId) as HTMLAudioElement;\n    if (audioEl) {\n      this.removeAudioElement(audioEl, track);\n    }\n    // Reset autoplay error thrown because if all tracks are removed and a new track is added\n    // Autoplay error is thrown in safari\n    if (this.audioSink && this.audioSink.childElementCount === 0) {\n      this.state.autoplayCheckPromise = undefined;\n      this.state.autoplayFailed = undefined;\n    }\n    HMSLogger.d(this.TAG, 'Audio track removed', `${track}`);\n  };\n\n  private unpauseAudioTracks = async () => {\n    const promises: Promise<void>[] = [];\n    this.autoPausedTracks.forEach(track => {\n      promises.push(this.playAudioFor(track));\n    });\n    // Return after all pending tracks are played\n    await Promise.all(promises);\n  };\n\n  private removeAudioElement = (audioEl: HTMLAudioElement, track: HMSRemoteAudioTrack) => {\n    if (audioEl) {\n      audioEl.removeEventListener('pause', this.handleAudioPaused);\n      audioEl.srcObject = null;\n      audioEl.remove();\n      track.setAudioElement(null);\n    }\n  };\n}\n", "import { DeviceStorageManager } from './DeviceStorage';\nimport AnalyticsEventFactory from '../analytics/AnalyticsEventFactory';\nimport { HMSException } from '../error/HMSException';\nimport { EventBus } from '../events/EventBus';\nimport { DeviceMap, DeviceType, HMSDeviceChangeEvent } from '../interfaces';\nimport { HMSAudioTrackSettingsBuilder, HMSVideoTrackSettingsBuilder } from '../media/settings';\nimport { HMSLocalAudioTrack, HMSLocalTrack, HMSLocalVideoTrack } from '../media/tracks';\nimport { IStore } from '../sdk/store';\nimport HMSLogger from '../utils/logger';\nimport { debounce } from '../utils/timer-utils';\n\nexport type SelectedDevices = {\n  [DeviceType.audioInput]?: MediaDeviceInfo;\n  [DeviceType.videoInput]?: MediaDeviceInfo;\n  [DeviceType.audioOutput]?: MediaDeviceInfo;\n};\n\ntype DeviceAndGroup = Partial<MediaTrackSettings>;\n\ninterface HMSDeviceManager extends DeviceMap {\n  outputDevice?: MediaDeviceInfo;\n  hasWebcamPermission: boolean;\n  hasMicrophonePermission: boolean;\n}\n\nexport class DeviceManager implements HMSDeviceManager {\n  audioInput: MediaDeviceInfo[] = [];\n  audioOutput: MediaDeviceInfo[] = [];\n  videoInput: MediaDeviceInfo[] = [];\n  outputDevice?: MediaDeviceInfo;\n  // true if user has allowed the permission\n  // false if user has denied the permission or prompt was never shown or ignored\n  // or if the camera/mic is not available in the device\n  hasWebcamPermission = false;\n  hasMicrophonePermission = false;\n\n  private readonly TAG = '[Device Manager]:';\n  private initialized = false;\n  private videoInputChanged = false;\n  private audioInputChanged = false;\n\n  constructor(private store: IStore, private eventBus: EventBus) {\n    const isLocalTrackEnabled = ({ enabled, track }: { enabled: boolean; track: HMSLocalTrack }) =>\n      enabled && track.source === 'regular';\n    this.eventBus.localVideoEnabled.waitFor(isLocalTrackEnabled).then(async () => {\n      await this.enumerateDevices();\n      if (this.videoInputChanged) {\n        this.eventBus.deviceChange.publish({ devices: this.getDevices() } as HMSDeviceChangeEvent);\n      }\n    });\n    this.eventBus.localAudioEnabled.waitFor(isLocalTrackEnabled).then(async () => {\n      await this.enumerateDevices();\n      if (this.audioInputChanged) {\n        this.eventBus.deviceChange.publish({ devices: this.getDevices() } as HMSDeviceChangeEvent);\n      }\n    });\n  }\n\n  updateOutputDevice = async (deviceId?: string) => {\n    const newDevice = this.audioOutput.find(device => device.deviceId === deviceId);\n    if (newDevice) {\n      this.outputDevice = newDevice;\n      await this.store.updateAudioOutputDevice(newDevice);\n      DeviceStorageManager.updateSelection('audioOutput', { deviceId: newDevice.deviceId, groupId: newDevice.groupId });\n    }\n    return newDevice;\n  };\n\n  async init(force = false) {\n    if (this.initialized && !force) {\n      return;\n    }\n    !this.initialized && navigator.mediaDevices.addEventListener('devicechange', this.handleDeviceChange);\n    this.initialized = true;\n    await this.enumerateDevices();\n    this.logDevices('Init');\n    await this.setOutputDevice();\n    this.eventBus.deviceChange.publish({\n      devices: this.getDevices(),\n    } as HMSDeviceChangeEvent);\n    this.eventBus.analytics.publish(\n      AnalyticsEventFactory.deviceChange({\n        selection: this.getCurrentSelection(),\n        type: 'list',\n        devices: this.getDevices(),\n      }),\n    );\n  }\n\n  getDevices(): DeviceMap {\n    return {\n      audioInput: this.audioInput,\n      audioOutput: this.audioOutput,\n      videoInput: this.videoInput,\n    };\n  }\n\n  cleanUp() {\n    this.initialized = false;\n    this.audioInput = [];\n    this.audioOutput = [];\n    this.videoInput = [];\n    this.outputDevice = undefined;\n    navigator.mediaDevices.removeEventListener('devicechange', this.handleDeviceChange);\n  }\n\n  getCurrentSelection = (): SelectedDevices => {\n    const localPeer = this.store.getLocalPeer();\n    const audioDevice = this.createIdentifier(localPeer?.audioTrack?.getMediaTrackSettings());\n    const videoDevice = this.createIdentifier(localPeer?.videoTrack?.getMediaTrackSettings());\n    const audioSelection = this.audioInput.find(device => {\n      const id = this.createIdentifier(device);\n      return id === audioDevice;\n    });\n    const videoSelection = this.videoInput.find(device => this.createIdentifier(device) === videoDevice);\n    return {\n      audioInput: audioSelection,\n      videoInput: videoSelection,\n      audioOutput: this.outputDevice,\n    };\n  };\n\n  private createIdentifier(deviceInfo?: DeviceAndGroup) {\n    if (!deviceInfo) {\n      return '';\n    }\n    return `${deviceInfo.deviceId}${deviceInfo.groupId}`;\n  }\n\n  private computeChange = (prevDevices: string[], currentDevices: MediaDeviceInfo[]) => {\n    if (prevDevices.length !== currentDevices.length) {\n      return true;\n    }\n    return currentDevices.some(device => !prevDevices.includes(this.createIdentifier(device)));\n  };\n\n  private enumerateDevices = async () => {\n    try {\n      const devices = await navigator.mediaDevices.enumerateDevices();\n      const prevVideoInput = this.videoInput.map(this.createIdentifier);\n      const prevAudioInput = this.audioInput.map(this.createIdentifier);\n      this.audioInput = [];\n      this.audioOutput = [];\n      this.videoInput = [];\n      devices.forEach(device => {\n        if (device.kind === 'audioinput' && device.label) {\n          this.hasMicrophonePermission = true;\n          this.audioInput.push(device as MediaDeviceInfo);\n        } else if (device.kind === 'audiooutput') {\n          this.audioOutput.push(device);\n        } else if (device.kind === 'videoinput' && device.label) {\n          this.hasWebcamPermission = true;\n          this.videoInput.push(device as MediaDeviceInfo);\n        }\n      });\n      this.videoInputChanged = this.computeChange(prevVideoInput, this.videoInput);\n      this.audioInputChanged = this.computeChange(prevAudioInput, this.audioInput);\n      DeviceStorageManager.setDevices({\n        videoInput: [...this.videoInput],\n        audioInput: [...this.audioInput],\n        audioOutput: [...this.audioOutput],\n      });\n      this.logDevices('Enumerate Devices');\n    } catch (error) {\n      HMSLogger.e(this.TAG, 'Failed enumerating devices', error);\n    }\n  };\n\n  private handleDeviceChange = debounce(async () => {\n    await this.enumerateDevices();\n    this.logDevices('After Device Change');\n    const localPeer = this.store.getLocalPeer();\n    await this.setOutputDevice(true);\n    await this.handleAudioInputDeviceChange(localPeer?.audioTrack);\n    await this.handleVideoInputDeviceChange(localPeer?.videoTrack);\n    this.eventBus.analytics.publish(\n      AnalyticsEventFactory.deviceChange({\n        selection: this.getCurrentSelection(),\n        type: 'change',\n        devices: this.getDevices(),\n      }),\n    );\n  }, 500).bind(this);\n\n  /**\n   * Function to get the device after device change\n   * Chrome and Edge provide a default device from which we select the actual device\n   * Firefox and safari give 0th device as system default\n   * @returns {MediaDeviceInfo}\n   */\n  getNewAudioInputDevice() {\n    const defaultDevice = this.audioInput.find(device => device.deviceId === 'default');\n    if (defaultDevice) {\n      // Selecting a non-default device so that the deviceId comparision does not give\n      // false positives when device is removed, because the other available device\n      // get's the deviceId as default once this device is removed\n      const nextDevice = this.audioInput.find(device => {\n        return device.deviceId !== 'default' && defaultDevice.label.includes(device.label);\n      });\n      return nextDevice;\n    }\n    return this.audioInput[0];\n  }\n\n  /**\n   * This method is to select the input/output from same group\n   * same group meaning both input/output are of same device\n   * This method might override the default coming from browser and system so as to select options from same\n   * device type. This is required in certain cases where browser's default is not correct.\n   * Algo:\n   * 1. find the non default input device if selected one is default by matching device label\n   * 2. find the corresponding output device which has the same group id or same label\n   * 3. select the previous selected device if nothing was found\n   * 4. select the default one if no matching device was found and previous device doesn't exist anymore\n   * 5. select the first option if there is no default\n   */\n  async setOutputDevice(deviceChange = false) {\n    const inputDevice = this.getNewAudioInputDevice();\n    const prevSelection = this.createIdentifier(this.outputDevice);\n    this.outputDevice = this.getAudioOutputDeviceMatchingInput(inputDevice);\n    if (!this.outputDevice) {\n      // there is no matching device, let's revert back to the prev selected device\n      this.outputDevice = this.audioOutput.find(device => this.createIdentifier(device) === prevSelection);\n      if (!this.outputDevice) {\n        // prev device doesn't exist as well, select default deviceId device if available, otherwise select 0th device\n        this.outputDevice = this.audioOutput.find(device => device.deviceId === 'default') || this.audioOutput[0];\n      }\n    }\n    await this.store.updateAudioOutputDevice(this.outputDevice);\n    // send event only on device change and device is not same as previous\n    if (deviceChange && prevSelection !== this.createIdentifier(this.outputDevice)) {\n      this.eventBus.analytics.publish(\n        AnalyticsEventFactory.deviceChange({\n          selection: { audioOutput: this.outputDevice },\n          devices: this.getDevices(),\n          type: 'audioOutput',\n        }),\n      );\n      this.eventBus.deviceChange.publish({\n        selection: this.outputDevice,\n        type: 'audioOutput',\n        devices: this.getDevices(),\n      } as HMSDeviceChangeEvent);\n    }\n  }\n\n  private handleAudioInputDeviceChange = async (audioTrack?: HMSLocalAudioTrack) => {\n    if (!audioTrack) {\n      HMSLogger.d(this.TAG, 'No Audio track on local peer');\n      return;\n    }\n    // no need to proceed further if input has not changed\n    if (!this.audioInputChanged) {\n      HMSLogger.d(this.TAG, 'No Change in AudioInput Device');\n      return;\n    }\n    const newSelection = this.getNewAudioInputDevice();\n    if (!newSelection || !newSelection.deviceId) {\n      this.eventBus.analytics.publish(\n        AnalyticsEventFactory.deviceChange({\n          selection: { audioInput: newSelection },\n          error: new Error('Audio device not found') as HMSException,\n          devices: this.getDevices(),\n          type: 'audioInput',\n        }),\n      );\n      HMSLogger.w(this.TAG, 'Audio device not found');\n      return;\n    }\n    const { settings } = audioTrack;\n    const newAudioTrackSettings = new HMSAudioTrackSettingsBuilder()\n      .codec(settings.codec)\n      .maxBitrate(settings.maxBitrate)\n      .deviceId(newSelection.deviceId)\n      .build();\n    try {\n      await audioTrack.setSettings(newAudioTrackSettings, true);\n      this.eventBus.deviceChange.publish({\n        devices: this.getDevices(),\n        selection: newSelection,\n        type: 'audioInput',\n      } as HMSDeviceChangeEvent);\n      this.logDevices('Audio Device Change Success');\n    } catch (error) {\n      HMSLogger.e(this.TAG, '[Audio Device Change]', error);\n      this.eventBus.analytics.publish(\n        AnalyticsEventFactory.deviceChange({\n          selection: { audioInput: newSelection },\n          devices: this.getDevices(),\n          type: 'audioInput',\n          error: error as HMSException,\n        }),\n      );\n      this.eventBus.deviceChange.publish({\n        error,\n        selection: newSelection,\n        type: 'audioInput',\n        devices: this.getDevices(),\n      } as HMSDeviceChangeEvent);\n    }\n  };\n\n  private handleVideoInputDeviceChange = async (videoTrack?: HMSLocalVideoTrack) => {\n    if (!videoTrack) {\n      HMSLogger.d(this.TAG, 'No video track on local peer');\n      return;\n    }\n    // no need to proceed further if input has not changed\n    if (!this.videoInputChanged) {\n      HMSLogger.d(this.TAG, 'No Change in VideoInput Device');\n      return;\n    }\n    const newSelection = this.videoInput[0];\n    if (!newSelection || !newSelection.deviceId) {\n      this.eventBus.analytics.publish(\n        AnalyticsEventFactory.deviceChange({\n          selection: { videoInput: newSelection },\n          error: new Error('Video device not found') as HMSException,\n          devices: this.getDevices(),\n          type: 'video',\n        }),\n      );\n      HMSLogger.w(this.TAG, 'Video device not found');\n      return;\n    }\n    const { settings } = videoTrack;\n    const newVideoTrackSettings = new HMSVideoTrackSettingsBuilder()\n      .codec(settings.codec)\n      .maxBitrate(settings.maxBitrate)\n      .maxFramerate(settings.maxFramerate)\n      .setWidth(settings.width)\n      .setHeight(settings.height)\n      .deviceId(newSelection.deviceId)\n      .build();\n    try {\n      await (videoTrack as HMSLocalVideoTrack).setSettings(newVideoTrackSettings, true);\n      // On replace track, enabled will be true. Need to be set to previous state\n      // videoTrack.setEnabled(enabled); // TODO: remove this once verified on qa.\n      this.eventBus.deviceChange.publish({\n        devices: this.getDevices(),\n        selection: newSelection,\n        type: 'video',\n      } as HMSDeviceChangeEvent);\n      this.logDevices('Video Device Change Success');\n    } catch (error) {\n      HMSLogger.e(this.TAG, '[Video Device Change]', error);\n      this.eventBus.analytics.publish(\n        AnalyticsEventFactory.deviceChange({\n          selection: { videoInput: newSelection },\n          devices: this.getDevices(),\n          type: 'video',\n          error: error as HMSException,\n        }),\n      );\n      this.eventBus.deviceChange.publish({\n        error: error as Error,\n        type: 'video',\n        selection: newSelection,\n        devices: this.getDevices(),\n      } as HMSDeviceChangeEvent);\n    }\n  };\n\n  private getAudioOutputDeviceMatchingInput(inputDevice?: MediaDeviceInfo) {\n    const blacklist = this.store.getConfig()?.settings?.speakerAutoSelectionBlacklist || [];\n    if (blacklist === 'all') {\n      return;\n    }\n\n    const inputLabel = inputDevice?.label.toLowerCase() || '';\n    if (blacklist.some(label => inputLabel.includes(label.toLowerCase()))) {\n      return;\n    }\n\n    if (inputDevice?.groupId) {\n      // only check for label because if groupId check is added it will select speaker\n      // when an external earphone without microphone is added\n      return this.audioOutput.find(device => inputDevice.deviceId !== 'default' && device.label === inputDevice.label);\n    }\n\n    return;\n  }\n\n  private logDevices(label = '') {\n    HMSLogger.d(\n      this.TAG,\n      label,\n      JSON.stringify(\n        {\n          videoInput: [...this.videoInput],\n          audioInput: [...this.audioInput],\n          audioOutput: [...this.audioOutput],\n          selected: this.getCurrentSelection(),\n        },\n        null,\n        4,\n      ),\n    );\n  }\n}\n", "import { DeviceManager } from '.';\nimport { AudioSinkManager } from '../audio-sink-manager';\nimport { HMSAudioContextHandler } from '../utils/media';\n\nexport interface IAudioOutputManager {\n  getDevice(): MediaDeviceInfo | undefined;\n  setDevice(deviceId: string): Promise<MediaDeviceInfo | undefined>;\n  getVolume(): number;\n  setVolume(value: number): void;\n}\n\nexport class AudioOutputManager implements IAudioOutputManager {\n  constructor(private deviceManager: DeviceManager, private audioSinkManager: AudioSinkManager) {}\n\n  getVolume() {\n    return this.audioSinkManager.getVolume();\n  }\n\n  setVolume(value: number) {\n    if (value < 0 || value > 100) {\n      throw Error('Please pass a valid number between 0-100');\n    }\n    this.audioSinkManager.setVolume(value);\n  }\n\n  getDevice() {\n    return this.deviceManager.outputDevice;\n  }\n\n  setDevice(deviceId?: string) {\n    return this.deviceManager.updateOutputDevice(deviceId);\n  }\n\n  async unblockAutoplay() {\n    await this.audioSinkManager.unblockAutoplay();\n    /**\n     * similar to autoplay error when there's no user interaction,\n     * audio context is paused due to which empty audio tracks do not send any data and therefore it doesn't reach SFU.\n     * resume audio context on user interaction to enable empty audio tracks to send data and be forwarded to remote peers\n     */\n    await HMSAudioContextHandler.resumeContext();\n  }\n}\n", "import { EventEmitter2 as EventEmitter } from 'eventemitter2';\nimport { HMSInternalEvent } from './HMSInternalEvent';\nimport AnalyticsEvent from '../analytics/AnalyticsEvent';\nimport { HMSException } from '../error/HMSException';\nimport { HMSDeviceChangeEvent, HMSRole } from '../interfaces';\nimport { HMSLocalAudioTrack, HMSLocalVideoTrack, HMSRemoteAudioTrack, HMSRemoteVideoTrack } from '../media/tracks';\nimport { PolicyParams } from '../notification-manager';\nimport { HMSWebrtcStats } from '../rtc-stats';\nimport { HMSRemotePeer } from '../sdk/models/peer';\nimport { HMSEvents } from '../utils/constants';\nimport { ITrackAudioLevelUpdate } from '../utils/track-audio-level-monitor';\n\nexport class EventBus {\n  private eventEmitter: EventEmitter = new EventEmitter();\n  readonly deviceChange = new HMSInternalEvent<HMSDeviceChangeEvent>(HMSEvents.DEVICE_CHANGE, this.eventEmitter);\n  readonly localAudioEnabled = new HMSInternalEvent<{ enabled: boolean; track: HMSLocalAudioTrack }>(\n    HMSEvents.LOCAL_AUDIO_ENABLED,\n    this.eventEmitter,\n  );\n  readonly localVideoEnabled = new HMSInternalEvent<{ enabled: boolean; track: HMSLocalVideoTrack }>(\n    HMSEvents.LOCAL_VIDEO_ENABLED,\n    this.eventEmitter,\n  );\n\n  /**\n   * Emitter which processes raw RTC stats from rtcStatsUpdate and calls client callback\n   */\n  readonly statsUpdate = new HMSInternalEvent<HMSWebrtcStats>(HMSEvents.STATS_UPDATE, this.eventEmitter);\n\n  readonly trackDegraded = new HMSInternalEvent<HMSRemoteVideoTrack>(HMSEvents.TRACK_DEGRADED, this.eventEmitter);\n  readonly trackRestored = new HMSInternalEvent<HMSRemoteVideoTrack>(HMSEvents.TRACK_RESTORED, this.eventEmitter);\n\n  /**\n   * Emits audio level updates for audio tracks(used with local track in preview)\n   */\n  readonly trackAudioLevelUpdate = new HMSInternalEvent<ITrackAudioLevelUpdate>(\n    HMSEvents.TRACK_AUDIO_LEVEL_UPDATE,\n    this.eventEmitter,\n  );\n\n  readonly audioPluginFailed = new HMSInternalEvent<HMSException>(HMSEvents.AUDIO_PLUGIN_FAILED, this.eventEmitter);\n\n  readonly localAudioSilence = new HMSInternalEvent<{ track: HMSLocalAudioTrack }>(\n    HMSEvents.LOCAL_AUDIO_SILENCE,\n    this.eventEmitter,\n  );\n\n  readonly analytics = new HMSInternalEvent<AnalyticsEvent>(HMSEvents.ANALYTICS, this.eventEmitter);\n\n  readonly policyChange = new HMSInternalEvent<PolicyParams>(HMSEvents.POLICY_CHANGE, this.eventEmitter);\n\n  readonly localRoleUpdate = new HMSInternalEvent<{ oldRole: HMSRole; newRole: HMSRole }>(\n    HMSEvents.LOCAL_ROLE_UPDATE,\n    this.eventEmitter,\n  );\n\n  readonly audioTrackUpdate = new HMSInternalEvent<{ track: HMSRemoteAudioTrack; enabled: boolean }>(\n    HMSEvents.AUDIO_TRACK_UPDATE,\n    this.eventEmitter,\n  );\n\n  readonly audioTrackAdded = new HMSInternalEvent<{ track: HMSRemoteAudioTrack; peer: HMSRemotePeer }>(\n    HMSEvents.AUDIO_TRACK_ADDED,\n    this.eventEmitter,\n  );\n\n  readonly audioTrackRemoved = new HMSInternalEvent<HMSRemoteAudioTrack>(\n    HMSEvents.AUDIO_TRACK_REMOVED,\n    this.eventEmitter,\n  );\n\n  readonly autoplayError = new HMSInternalEvent<HMSException>(HMSEvents.AUTOPLAY_ERROR, this.eventEmitter);\n\n  readonly leave = new HMSInternalEvent<HMSException | undefined>(HMSEvents.LEAVE, this.eventEmitter);\n}\n", "import type { WaitForFilter, WaitForOptions } from 'eventemitter2';\nimport { EventEmitter2 as EventEmitter } from 'eventemitter2';\n\nexport class HMSInternalEvent<T> {\n  constructor(private eventName: string, private eventEmitter: EventEmitter) {}\n\n  publish = (event?: T) => {\n    this.eventEmitter.emit(this.eventName, event);\n  };\n  subscribe = (fn: (event: T) => void | Promise<void>) => {\n    this.eventEmitter.on(this.eventName, fn);\n  };\n  subscribeOnce = (fn: (event: T) => void | Promise<void>) => {\n    this.eventEmitter.once(this.eventName, fn);\n  };\n  unsubscribe = (fn: (event: T) => void | Promise<void>) => {\n    this.eventEmitter.off(this.eventName, fn);\n  };\n  waitFor = (predicate: WaitForFilter) => {\n    return this.eventEmitter.waitFor(this.eventName, {\n      filter: predicate,\n    } as WaitForOptions);\n  };\n  removeAllListeners = () => {\n    this.eventEmitter.removeAllListeners(this.eventName);\n  };\n}\n", "import { HMSAudioListener, HMSPeerUpdate, HMSSpeaker, HMSUpdateListener } from '../../interfaces';\nimport { HMSAudioTrack } from '../../media/tracks';\nimport { IStore } from '../../sdk/store';\nimport { SpeakerList } from '../HMSNotifications';\n\nexport class ActiveSpeakerManager {\n  constructor(private store: IStore, public listener?: HMSUpdateListener, public audioListener?: HMSAudioListener) {}\n\n  handleActiveSpeakers(speakerList: SpeakerList) {\n    const speakers = speakerList['speaker-list'];\n    const hmsSpeakers: HMSSpeaker[] = speakers.map(speaker => ({\n      audioLevel: speaker.level,\n      peer: this.store.getPeerById(speaker.peer_id)!,\n      track: this.store.getTrackById(speaker.track_id) as HMSAudioTrack,\n    }));\n\n    this.audioListener?.onAudioLevelUpdate(hmsSpeakers);\n    this.store.updateSpeakers(hmsSpeakers);\n    const dominantSpeaker = speakers[0];\n\n    if (dominantSpeaker) {\n      const dominantSpeakerPeer = this.store.getPeerById(dominantSpeaker.peer_id);\n      this.listener?.onPeerUpdate(HMSPeerUpdate.BECAME_DOMINANT_SPEAKER, dominantSpeakerPeer!);\n    } else {\n      this.listener?.onPeerUpdate(HMSPeerUpdate.RESIGNED_DOMINANT_SPEAKER, null);\n    }\n  }\n}\n", "/**\n * Method names for incoming RPC messages from BIZ Signal through Websocket.\n * Used to call the corresponding handler/manager in NotificationManager\n * which will call the corresponding HMSUpdateListener callbacks.\n */\n\nexport enum HMSNotificationMethod {\n  ROOM_STATE = 'room-state',\n  PEER_JOIN = 'on-peer-join',\n  PEER_LEAVE = 'on-peer-leave',\n  PEER_LIST = 'peer-list',\n  TRACK_METADATA_ADD = 'on-track-add',\n  TRACK_UPDATE = 'on-track-update',\n  CHANGE_TRACK_MUTE_STATE_UPDATE = 'on-change-track-mute-state-request',\n  ACTIVE_SPEAKERS = 'active-speakers',\n  CONNECTION_QUALITY = 'on-connection-quality-update',\n  SFU_STATS = 'sfu-stats',\n  ON_SFU_TRACK_LAYER_UPDATE = 'on-track-layer-update',\n  BROADCAST = 'on-broadcast',\n  ROLE_CHANGE = 'on-role-change',\n  POLICY_CHANGE = 'on-policy-change',\n  ROLE_CHANGE_REQUEST = 'on-role-change-request',\n  TRACK_UPDATE_REQUEST = 'on-track-update-request',\n  PEER_UPDATE = 'on-peer-update',\n  PEER_LEAVE_REQUEST = 'on-peer-leave-request',\n  UNSUPPORTED = 'unsupported',\n  RTMP_START = 'on-rtmp-start',\n  RTMP_STOP = 'on-rtmp-stop',\n  RECORDING_START = 'on-record-start',\n  RECORDING_STOP = 'on-record-stop',\n  HLS_START = 'on-hls-start',\n  HLS_STOP = 'on-hls-stop',\n}\n", "import { HMSUpdateListener } from '../../interfaces';\nimport Message from '../../sdk/models/HMSMessage';\nimport { HMSPeer } from '../../sdk/models/peer';\nimport { IStore } from '../../sdk/store';\nimport HMSLogger from '../../utils/logger';\nimport { HMSNotificationMethod } from '../HMSNotificationMethod';\nimport { MessageNotification } from '../HMSNotifications';\n\nexport class BroadcastManager {\n  private readonly TAG = '[BroadcastManager]';\n  constructor(private store: IStore, public listener?: HMSUpdateListener) {}\n\n  handleNotification(method: string, notification: any) {\n    if (method !== HMSNotificationMethod.BROADCAST) {\n      return;\n    }\n    this.handleBroadcast(notification);\n  }\n\n  private handleBroadcast(messageNotification: MessageNotification) {\n    const notifPeer = messageNotification.peer;\n    const notifMessage = messageNotification.info;\n    const notifRoles = messageNotification.roles;\n\n    const sender = this.getSender(notifPeer);\n    const recipientPeer = messageNotification.private ? this.store.getLocalPeer() : undefined;\n    const recipientRoles = [];\n\n    if (notifRoles?.length) {\n      const knownRoles = this.store.getKnownRoles();\n      for (const role of notifRoles) {\n        knownRoles[role] && recipientRoles.push(knownRoles[role]);\n      }\n    }\n\n    const hmsMessage = new Message({\n      ...notifMessage,\n      sender,\n      recipientRoles,\n      recipientPeer,\n      time: new Date(messageNotification.timestamp),\n    });\n    HMSLogger.d(this.TAG, `Received Message from sender=${notifPeer?.peer_id}: ${hmsMessage}`);\n    this.listener?.onMessageReceived(hmsMessage);\n  }\n\n  private getSender(notifPeer?: MessageNotification['peer']) {\n    // If sender peerId is available in store, use that peer.\n    let sender = notifPeer ? this.store.getPeerById(notifPeer.peer_id) : undefined;\n    // If not available in store, use peer data from received broadcast message from Biz\n    // notifPeer can be undefined when message is sent via api\n    if (!sender && notifPeer) {\n      sender = new HMSPeer({\n        peerId: notifPeer.peer_id,\n        name: notifPeer.info.name,\n        isLocal: false,\n        customerUserId: notifPeer.info.user_id,\n        metadata: notifPeer.info.data,\n      });\n    }\n    return sender;\n  }\n}\n", "import { HMSConnectionQuality, HMSConnectionQualityListener } from '../../interfaces';\nimport { ConnectionQualityList } from '../HMSNotifications';\n\nexport class ConnectionQualityManager {\n  constructor(public listener?: HMSConnectionQualityListener) {}\n\n  handleQualityUpdate(qualityList: ConnectionQualityList) {\n    const peers = qualityList.peers;\n    const hmsPeers: HMSConnectionQuality[] = peers.map(peer => {\n      return {\n        peerID: peer.peer_id,\n        downlinkQuality: peer.downlink_score,\n      };\n    });\n    this.listener?.onConnectionQualityUpdate(hmsPeers);\n  }\n}\n", "import { PeerManager } from './PeerManager';\nimport { TrackManager } from './TrackManager';\nimport { HMSUpdateListener } from '../..';\nimport { HMSTrackUpdate } from '../../interfaces';\nimport { HMSPeer } from '../../sdk/models/peer';\nimport { IStore } from '../../sdk/store';\nimport HMSLogger from '../../utils/logger';\nimport { HMSNotificationMethod } from '../HMSNotificationMethod';\nimport { PeerListNotification, PeerNotification, PeriodicRoomState } from '../HMSNotifications';\n\n/**\n * Handles:\n * - Initial Peer List - get peer and track meta-data for peers who are already in the room when you join\n * - Reconnect Peer List - Handle peer and track changes in the room missed out due to reconnection\n *\n * Cases to handle in reconnect peer list:\n * - Add additional peers as peer join\n * - Remove missing peers as peer leave\n * - For existing peers:\n *    - Add new tracks as track add\n *    - Remove missing tracks as track remove\n *    - Track state change(enabled) as track update\n */\nexport class PeerListManager {\n  private readonly TAG = '[PeerListManager]';\n  constructor(\n    private store: IStore,\n    private peerManager: PeerManager,\n    private trackManager: TrackManager,\n    public listener?: HMSUpdateListener,\n  ) {}\n\n  handleNotification(method: string, notification: any, isReconnecting: boolean) {\n    if (method === HMSNotificationMethod.PEER_LIST) {\n      const peerList = notification as PeerListNotification;\n      if (isReconnecting) {\n        HMSLogger.d(this.TAG, `RECONNECT_PEER_LIST event`, JSON.stringify(peerList, null, 2));\n        this.handleReconnectPeerList(peerList);\n      } else {\n        // TODO: Don't call initial peerlist if atleast 1room state had happen\n        HMSLogger.d(this.TAG, `PEER_LIST event`, JSON.stringify(peerList, null, 2));\n        this.handleInitialPeerList(peerList);\n      }\n    } else if (method === HMSNotificationMethod.ROOM_STATE) {\n      const roomState = notification as PeriodicRoomState;\n      this.handlePreviewRoomState(roomState);\n    }\n  }\n\n  private handleInitialPeerList = (peerList: PeerListNotification) => {\n    const peers = Object.values(peerList.peers);\n    this.peerManager.handlePeerList(peers);\n  };\n\n  private handleReconnectPeerList = (peerList: PeerListNotification) => {\n    this.handleRepeatedPeerList(peerList.peers);\n  };\n\n  private handlePreviewRoomState = (roomState: PeriodicRoomState) => {\n    if (!this.store.hasRoleDetailsArrived()) {\n      // we can't process the peers yet we don't know enough about them(role info)\n      return;\n    }\n    const roomPeers = roomState.peers;\n    if (roomPeers === null || roomPeers === undefined) {\n      // in this case, room state doesn't say anything about the peers,\n      // there can be optimisations in place to not send this field when it's unchanged from previously sent value.\n      // If there are no peers either roomState.peers will be empty object\n      // or peer_count will be 0(handled below)\n      if (roomState.peer_count === 0) {\n        this.handleRepeatedPeerList({});\n      }\n      return;\n    }\n    // we don't get tracks inside the peer object in room state, we're adding\n    // an empty value here so rest of the code flow can ignore this change, the below\n    // can be changed when tracks will be sent as a separate object in future\n    Object.keys(roomPeers).forEach(peer => {\n      roomPeers[peer].tracks = {};\n      roomPeers[peer].is_from_room_state = true;\n    });\n    this.handleRepeatedPeerList(roomPeers);\n  };\n\n  private handleRepeatedPeerList = (peersMap: Record<string, PeerNotification>) => {\n    const currentPeerList = this.store.getRemotePeers();\n    const peers = Object.values(peersMap);\n    const peersToRemove = currentPeerList.filter(hmsPeer => !peersMap[hmsPeer.peerId]);\n    if (peersToRemove.length > 0) {\n      HMSLogger.d(this.TAG, `${peersToRemove}`);\n    }\n\n    // Send peer-leave updates to all the missing peers\n    peersToRemove.forEach(peer => {\n      const peerNotification: PeerNotification = {\n        peer_id: peer.peerId,\n        role: peer.role?.name || '',\n        info: {\n          name: peer.name,\n          data: peer.metadata || '',\n          user_id: peer.customerUserId || '',\n        },\n        tracks: {},\n      };\n\n      this.peerManager.handlePeerLeave(peerNotification);\n    });\n\n    // Check for any tracks which are added/removed\n    peers.forEach(newPeerNotification => {\n      const oldPeer = this.store.getPeerById(newPeerNotification.peer_id);\n      const newPeerTrackStates = Object.values(newPeerNotification.tracks);\n\n      if (oldPeer) {\n        // Peer already present in room, we take diff between the tracks\n        const tracks = this.store.getPeerTracks(oldPeer.peerId);\n\n        // Remove all the tracks which are not present in the peer.tracks\n        tracks.forEach(track => {\n          if (!newPeerNotification.tracks[track.trackId]) {\n            this.removePeerTrack(oldPeer, track.trackId);\n            this.listener?.onTrackUpdate(HMSTrackUpdate.TRACK_REMOVED, track, oldPeer);\n          }\n        });\n\n        // Add track-metadata for all the new tracks\n        newPeerTrackStates.forEach(trackData => {\n          if (!this.store.getTrackById(trackData.track_id)) {\n            // NOTE: We assume that, once the connection is re-established,\n            //  transport layer will send a native onTrackAdd\n            this.store.setTrackState({\n              peerId: oldPeer.peerId,\n              trackInfo: trackData,\n            });\n          }\n        });\n\n        // Handle RTC track add and track state change.\n        this.trackManager.handleTrackUpdate({\n          peer: { info: newPeerNotification.info, peer_id: newPeerNotification.peer_id },\n          tracks: newPeerNotification.tracks,\n        });\n\n        // Update peer's role locally, new role is received from the reconnect peer-list\n        this.peerManager.handlePeerUpdate(newPeerNotification);\n      } else {\n        // New peer joined while reconnecting\n        this.peerManager.handlePeerJoin(newPeerNotification);\n      }\n    });\n  };\n\n  private removePeerTrack(peer: HMSPeer, trackId: string) {\n    HMSLogger.d(this.TAG, `removing track - ${trackId} from ${peer}`);\n    if (peer.audioTrack?.trackId === trackId) {\n      peer.audioTrack = undefined;\n    } else if (peer.videoTrack?.trackId === trackId) {\n      peer.videoTrack = undefined;\n    } else {\n      const trackIndex = peer.auxiliaryTracks.findIndex(track => track.trackId === trackId);\n      trackIndex >= 0 && peer.auxiliaryTracks.splice(trackIndex, 1);\n    }\n  }\n}\n", "export const convertDateNumToDate = (dateNum?: number): Date | undefined => {\n  return dateNum ? new Date(dateNum) : undefined;\n};\n", "import { TrackManager } from './TrackManager';\nimport { HMSPeer, HMSPeerUpdate, HMSTrackUpdate, HMSUpdateListener } from '../../interfaces';\nimport { HMSRemotePeer } from '../../sdk/models/peer';\nimport { IStore } from '../../sdk/store';\nimport { convertDateNumToDate } from '../../utils/date';\nimport HMSLogger from '../../utils/logger';\nimport { HMSNotificationMethod } from '../HMSNotificationMethod';\nimport { PeerNotification } from '../HMSNotifications';\n\n/**\n * Handles:\n * - New peer join\n * - Peer Leave\n * - Role update for peer\n *\n * Notes:\n * - Peer join comes with track meta-data,\n * we add it to the store and call TrackManager to process it when RTC Track comes in.\n */\nexport class PeerManager {\n  private readonly TAG = '[PeerManager]';\n  constructor(private store: IStore, private trackManager: TrackManager, public listener?: HMSUpdateListener) {}\n\n  handleNotification(method: string, notification: any) {\n    switch (method) {\n      case HMSNotificationMethod.PEER_JOIN: {\n        const peer = notification as PeerNotification;\n        this.handlePeerJoin(peer);\n        break;\n      }\n\n      case HMSNotificationMethod.PEER_LEAVE: {\n        const peer = notification as PeerNotification;\n        this.handlePeerLeave(peer);\n        break;\n      }\n      case HMSNotificationMethod.PEER_UPDATE:\n        this.handlePeerUpdate(notification as PeerNotification);\n        break;\n      default:\n        break;\n    }\n  }\n\n  handlePeerList = (peers: PeerNotification[]) => {\n    if (peers.length === 0) {\n      this.listener?.onPeerUpdate(HMSPeerUpdate.PEER_LIST, []);\n      return;\n    }\n    const hmsPeers: HMSRemotePeer[] = [];\n    const newPeers = new Set(peers.map(peer => peer.peer_id));\n    this.store.getRemotePeers().forEach(({ peerId, fromRoomState }) => {\n      /**\n       * Remove only if the peer join happened from preview roomstate update. This will prevent the peer joined\n       * from peer-join event post join from being removed from the store.\n       */\n      if (!newPeers.has(peerId) && fromRoomState) {\n        this.store.removePeer(peerId);\n      }\n    });\n    for (const peer of peers) {\n      hmsPeers.push(this.makePeer(peer));\n    }\n    this.listener?.onPeerUpdate(HMSPeerUpdate.PEER_LIST, hmsPeers);\n    this.trackManager.processPendingTracks();\n  };\n\n  handlePeerJoin = (peer: PeerNotification) => {\n    const hmsPeer = this.makePeer(peer);\n\n    this.listener?.onPeerUpdate(HMSPeerUpdate.PEER_JOINED, hmsPeer);\n    this.trackManager.processPendingTracks();\n  };\n\n  handlePeerLeave = (peer: PeerNotification) => {\n    const hmsPeer = this.store.getPeerById(peer.peer_id);\n    this.store.removePeer(peer.peer_id);\n    HMSLogger.d(this.TAG, `PEER_LEAVE`, peer.peer_id, `remainingPeers=${this.store.getPeers().length}`);\n\n    if (!hmsPeer) {\n      return;\n    }\n\n    if (hmsPeer.audioTrack) {\n      this.listener?.onTrackUpdate(HMSTrackUpdate.TRACK_REMOVED, hmsPeer.audioTrack, hmsPeer);\n    }\n\n    if (hmsPeer.videoTrack) {\n      this.listener?.onTrackUpdate(HMSTrackUpdate.TRACK_REMOVED, hmsPeer.videoTrack, hmsPeer);\n    }\n\n    hmsPeer.auxiliaryTracks?.forEach(track => {\n      this.listener?.onTrackUpdate(HMSTrackUpdate.TRACK_REMOVED, track, hmsPeer);\n    });\n\n    this.listener?.onPeerUpdate(HMSPeerUpdate.PEER_LEFT, hmsPeer);\n  };\n\n  handlePeerUpdate(notification: PeerNotification) {\n    const peer = this.store.getPeerById(notification.peer_id);\n\n    if (!peer) {\n      return;\n    }\n\n    if (peer.role && peer.role.name !== notification.role) {\n      const newRole = this.store.getPolicyForRole(notification.role);\n      peer.updateRole(newRole);\n      this.listener?.onPeerUpdate(HMSPeerUpdate.ROLE_UPDATED, peer);\n    }\n    this.handlePeerInfoUpdate({ peer, ...notification.info });\n  }\n\n  handlePeerInfoUpdate({ peer, name, data }: { peer?: HMSPeer; name?: string; data?: string }) {\n    if (!peer) {\n      return;\n    }\n    if (name && peer.name !== name) {\n      peer.updateName(name);\n      this.listener?.onPeerUpdate(HMSPeerUpdate.NAME_UPDATED, peer);\n    }\n    if (data && peer.metadata !== data) {\n      peer.updateMetadata(data);\n      this.listener?.onPeerUpdate(HMSPeerUpdate.METADATA_UPDATED, peer);\n    }\n  }\n\n  private makePeer(peer: PeerNotification) {\n    let hmsPeer = this.store.getPeerById(peer.peer_id) as HMSRemotePeer;\n    if (!hmsPeer) {\n      hmsPeer = new HMSRemotePeer({\n        peerId: peer.peer_id,\n        name: peer.info.name,\n        customerUserId: peer.info.user_id,\n        metadata: peer.info.data,\n        role: this.store.getPolicyForRole(peer.role),\n        joinedAt: convertDateNumToDate(peer.joined_at),\n        fromRoomState: !!peer.is_from_room_state,\n      });\n      this.store.addPeer(hmsPeer);\n      HMSLogger.d(this.TAG, `adding to the peerList`, `${hmsPeer}`);\n    }\n\n    for (const trackId in peer.tracks) {\n      this.store.setTrackState({\n        peerId: peer.peer_id,\n        trackInfo: peer.tracks[trackId],\n      });\n    }\n    return hmsPeer;\n  }\n}\n", "import { EventBus } from '../../events/EventBus';\nimport { IStore } from '../../sdk/store';\nimport { PolicyParams } from '../HMSNotifications';\n\n/**\n * Handles:\n * - Set policy with publishParams, simulcast layers to store\n * - Emit 'local-peer-role-update' to trigger RoleChangeManager to publish/unpublish local tracks\n * - Emit 'policy-change' to finish preview before calling listener.onPreview\n */\nexport class PolicyChangeManager {\n  constructor(private store: IStore, private eventBus: EventBus) {}\n\n  handlePolicyChange(params: PolicyParams) {\n    const localPeer = this.store.getLocalPeer();\n\n    if (localPeer && !localPeer.role) {\n      const newRole = params.known_roles[params.name];\n      localPeer.updateRole(newRole);\n    }\n\n    this.store.setKnownRoles(params);\n    this.store.getRoom().templateId = params.template_id;\n    // handle when role is not present in known_roles\n    // const publishParams = params.known_roles[params.name]?.publishParams;\n    // this.store.setPublishParams(publishParams);\n\n    if (localPeer?.role && localPeer.role.name !== params.name) {\n      const newRole = this.store.getPolicyForRole(params.name);\n      const oldRole = localPeer.role;\n      localPeer.updateRole(newRole);\n      this.eventBus.localRoleUpdate.publish({ oldRole, newRole });\n    }\n    this.eventBus.policyChange.publish(params);\n  }\n}\n", "import { HMSRemotePeer, HMSRoleChangeRequest, HMSUpdateListener } from '../../interfaces';\nimport { HMSLocalTrack, HMSTrackSource } from '../../media/tracks';\nimport { IStore } from '../../sdk/store';\nimport { HMSNotificationMethod } from '../HMSNotificationMethod';\nimport {\n  ChangeTrackMuteStateNotification,\n  RoleChangeRequestParams,\n  TrackUpdateRequestNotification,\n} from '../HMSNotifications';\n\n/**\n * Handles request from remote peers to change something on the local side. For eg. role change, track mute/unmute.\n */\nexport class RequestManager {\n  constructor(private store: IStore, public listener?: HMSUpdateListener) {}\n\n  handleNotification(method: string, notification: any) {\n    switch (method) {\n      case HMSNotificationMethod.ROLE_CHANGE_REQUEST:\n        this.handleRoleChangeRequest(notification as RoleChangeRequestParams);\n        break;\n\n      case HMSNotificationMethod.TRACK_UPDATE_REQUEST:\n        this.handleTrackUpdateRequest(notification as TrackUpdateRequestNotification);\n        break;\n\n      case HMSNotificationMethod.CHANGE_TRACK_MUTE_STATE_UPDATE:\n        this.handleChangeTrackStateRequest(notification as ChangeTrackMuteStateNotification);\n        break;\n      default:\n        return;\n    }\n  }\n\n  private handleRoleChangeRequest(notification: RoleChangeRequestParams) {\n    const request: HMSRoleChangeRequest = {\n      requestedBy: notification.requested_by\n        ? (this.store.getPeerById(notification.requested_by) as HMSRemotePeer)\n        : undefined,\n      role: this.store.getPolicyForRole(notification.role),\n      token: notification.token,\n    };\n\n    this.listener?.onRoleChangeRequest(request);\n  }\n\n  // eslint-disable-next-line complexity\n  private handleTrackUpdateRequest(trackUpdateRequest: TrackUpdateRequestNotification) {\n    const { requested_by, track_id, mute } = trackUpdateRequest;\n    const peer = requested_by ? this.store.getPeerById(requested_by) : undefined;\n    const track = this.store.getLocalPeerTracks().find(track => track.publishedTrackId === track_id);\n\n    if (!track) {\n      return;\n    }\n\n    const sendNotification = () => {\n      this.listener?.onChangeTrackStateRequest({ requestedBy: peer as HMSRemotePeer, track, enabled: !mute });\n    };\n\n    if (mute) {\n      // if track is already in the same state as change state, do nothing\n      if (track.enabled === !mute) {\n        return;\n      }\n      /**\n       * Directly mute track when request arrives\n       */\n      track.setEnabled(!mute).then(sendNotification);\n    } else {\n      /**\n       * Notify UI to unmute for requesting consent\n       */\n      sendNotification();\n    }\n  }\n\n  private handleChangeTrackStateRequest(request: ChangeTrackMuteStateNotification) {\n    const { type, source, value, requested_by } = request;\n    const peer = requested_by ? this.store.getPeerById(requested_by) : undefined;\n\n    // value true means the track has to be muted\n    const enabled = !value;\n    const tracksToBeUpdated = this.getTracksToBeUpdated({ type, source, enabled });\n    //Do nothing if all tracks are already in same state as the request\n    if (tracksToBeUpdated.length === 0) {\n      return;\n    }\n    // if track is to be muted, mute and send the notification, otherwise send notification\n    if (!enabled) {\n      const promises: Promise<void>[] = [];\n\n      for (const track of tracksToBeUpdated) {\n        promises.push(track.setEnabled(false));\n      }\n      Promise.all(promises).then(() => {\n        this.listener?.onChangeMultiTrackStateRequest({\n          requestedBy: peer as HMSRemotePeer,\n          tracks: tracksToBeUpdated,\n          enabled: false,\n        });\n      });\n    } else {\n      this.listener?.onChangeMultiTrackStateRequest({\n        requestedBy: peer as HMSRemotePeer,\n        tracks: tracksToBeUpdated,\n        type,\n        source,\n        enabled: true,\n      });\n    }\n  }\n\n  /**\n   * Filter the local tracks based on type, source and enabled state\n   * @returns {HMSLocalTrack[]}\n   */\n  private getTracksToBeUpdated({\n    type,\n    source,\n    enabled,\n  }: {\n    type?: 'audio' | 'video';\n    source?: HMSTrackSource;\n    enabled: boolean;\n  }) {\n    const localPeerTracks = this.store.getLocalPeerTracks();\n    let tracks: HMSLocalTrack[] = localPeerTracks;\n    if (type) {\n      tracks = tracks.filter(track => track.type === type);\n    }\n    if (source) {\n      tracks = tracks.filter(track => track.source === source);\n    }\n    // filter out tracks which are already in the desired state\n    return tracks.filter(track => track.enabled !== enabled);\n  }\n}\n", "import { HMSAction } from '../../error/ErrorFactory';\nimport { HMSException } from '../../error/HMSException';\nimport { HMSHLS, HMSHLSRecording, HMSRoomUpdate, HMSUpdateListener } from '../../interfaces';\nimport { ServerError } from '../../interfaces/internal';\nimport { IStore } from '../../sdk/store';\nimport { convertDateNumToDate } from '../../utils/date';\nimport HMSLogger from '../../utils/logger';\nimport { HMSNotificationMethod } from '../HMSNotificationMethod';\nimport {\n  HLSNotification,\n  PeerListNotification,\n  PeriodicRoomState,\n  RecordingNotification,\n  RoomState,\n  RTMPNotification,\n} from '../HMSNotifications';\n\nexport class RoomUpdateManager {\n  private readonly TAG = '[RoomUpdateManager]';\n\n  constructor(private store: IStore, public listener?: HMSUpdateListener) {}\n\n  // eslint-disable-next-line complexity\n  handleNotification(method: HMSNotificationMethod, notification: any) {\n    switch (method) {\n      case HMSNotificationMethod.PEER_LIST:\n        this.onRoomState((notification as PeerListNotification).room);\n        break;\n      case HMSNotificationMethod.RTMP_START:\n        this.onRTMPStart(notification as RTMPNotification);\n        break;\n      case HMSNotificationMethod.RTMP_STOP:\n        this.onRTMPStop(notification as RTMPNotification);\n        break;\n      case HMSNotificationMethod.RECORDING_START:\n        this.onRecordingStart(notification as RecordingNotification);\n        break;\n      case HMSNotificationMethod.RECORDING_STOP:\n        this.onRecordingStop(notification as RecordingNotification);\n        break;\n      case HMSNotificationMethod.ROOM_STATE:\n        this.handlePreviewRoomState(notification as PeriodicRoomState);\n        break;\n      default:\n        this.onHLS(method, notification as HLSNotification);\n        break;\n    }\n  }\n\n  private handlePreviewRoomState(notification: PeriodicRoomState) {\n    const { room } = notification;\n    this.onRoomState(room, notification.peer_count);\n  }\n\n  private onRoomState(roomNotification: RoomState, peerCount?: number) {\n    const { recording, streaming, session_id, started_at, name } = roomNotification;\n    const room = this.store.getRoom();\n    room.peerCount = peerCount;\n    room.name = name;\n    room.recording.server.running = !!recording?.sfu.enabled;\n    room.recording.browser.running = !!recording?.browser.enabled;\n    room.rtmp.running = !!streaming?.rtmp?.enabled;\n    room.rtmp.startedAt = convertDateNumToDate(streaming?.rtmp?.started_at);\n    room.recording.server.startedAt = convertDateNumToDate(recording?.sfu.started_at);\n    room.recording.browser.startedAt = convertDateNumToDate(recording?.browser.started_at);\n    room.recording.hls = this.getPeerListHLSRecording(recording);\n    room.hls = this.convertHls(streaming?.hls);\n    room.sessionId = session_id;\n    room.startedAt = convertDateNumToDate(started_at);\n    this.listener?.onRoomUpdate(HMSRoomUpdate.RECORDING_STATE_UPDATED, room);\n  }\n\n  private onRTMPStart(notification: RTMPNotification) {\n    this.setRTMPStatus(!notification.error?.code, notification);\n  }\n\n  private onRTMPStop(notification: RTMPNotification) {\n    this.setRTMPStatus(false, notification);\n  }\n\n  private onRecordingStart(notification: RecordingNotification) {\n    this.setRecordingStatus(!notification.error?.code, notification);\n  }\n\n  private onRecordingStop(notification: RecordingNotification) {\n    this.setRecordingStatus(false, notification);\n  }\n\n  private onHLS(method: string, notification: HLSNotification) {\n    if (![HMSNotificationMethod.HLS_START, HMSNotificationMethod.HLS_STOP].includes(method as HMSNotificationMethod)) {\n      return;\n    }\n    const room = this.store.getRoom();\n    notification.enabled = method === HMSNotificationMethod.HLS_START && !notification.error?.code;\n    room.hls = this.convertHls(notification);\n    room.recording.hls = this.getHLSRecording(notification);\n    this.listener?.onRoomUpdate(HMSRoomUpdate.HLS_STREAMING_STATE_UPDATED, room);\n  }\n\n  private convertHls(hlsNotification?: HLSNotification) {\n    const hls: HMSHLS = {\n      running: !!hlsNotification?.enabled,\n      variants: [],\n      error: this.toSdkError(hlsNotification?.error),\n    };\n    hlsNotification?.variants?.forEach(variant => {\n      hls.variants.push({\n        meetingURL: variant.meeting_url,\n        url: variant.url,\n        metadata: variant.metadata,\n        startedAt: convertDateNumToDate(variant.started_at),\n      });\n    });\n    return hls;\n  }\n\n  private getHLSRecording(hlsNotification?: HLSNotification): HMSHLSRecording {\n    let hlsRecording: HMSHLSRecording = { running: false };\n    if (hlsNotification?.hls_recording) {\n      hlsRecording = {\n        running: !!hlsNotification?.enabled,\n        singleFilePerLayer: !!hlsNotification.hls_recording?.single_file_per_layer,\n        hlsVod: !!hlsNotification.hls_recording?.hls_vod,\n        startedAt: convertDateNumToDate(hlsNotification?.variants?.[0].started_at),\n        error: this.toSdkError(hlsNotification.error),\n      };\n    }\n    return hlsRecording;\n  }\n\n  private getPeerListHLSRecording(recording?: RoomState['recording']): HMSHLSRecording {\n    const hlsNotification = recording?.hls;\n    return {\n      running: !!hlsNotification?.enabled,\n      startedAt: convertDateNumToDate(hlsNotification?.started_at),\n      singleFilePerLayer: !!hlsNotification?.config?.single_file_per_layer,\n      hlsVod: !!hlsNotification?.config?.hls_vod,\n    };\n  }\n\n  private setRecordingStatus(running: boolean, notification: RecordingNotification) {\n    const room = this.store.getRoom();\n    let action: HMSRoomUpdate;\n    if (notification.type === 'sfu') {\n      room.recording.server = {\n        running,\n        startedAt: running ? convertDateNumToDate(notification.started_at) : undefined,\n        error: this.toSdkError(notification.error),\n      };\n      action = HMSRoomUpdate.SERVER_RECORDING_STATE_UPDATED;\n    } else {\n      room.recording.browser = {\n        running,\n        startedAt: running ? convertDateNumToDate(notification.started_at) : undefined,\n        error: this.toSdkError(notification.error),\n      };\n      action = HMSRoomUpdate.BROWSER_RECORDING_STATE_UPDATED;\n    }\n    this.listener?.onRoomUpdate(action, room);\n  }\n\n  private setRTMPStatus(running: boolean, notification: RTMPNotification) {\n    const room = this.store.getRoom();\n    room.rtmp = {\n      running,\n      startedAt: running ? convertDateNumToDate(notification.started_at) : undefined,\n      error: this.toSdkError(notification.error),\n    };\n    this.listener?.onRoomUpdate(HMSRoomUpdate.RTMP_STREAMING_STATE_UPDATED, room);\n  }\n\n  private toSdkError(error?: ServerError): HMSException | undefined {\n    if (!error?.code) {\n      return undefined;\n    }\n    const errMsg = error.message || 'error in streaming/recording';\n    const sdkError = new HMSException(error.code, 'ServerErrors', HMSAction.NONE, errMsg, errMsg);\n    HMSLogger.e(this.TAG, 'error in streaming/recording', sdkError);\n    return sdkError;\n  }\n}\n", "import { VideoTrackLayerUpdate } from '../../connection/channel-messages';\nimport { EventBus } from '../../events/EventBus';\nimport { HMSPeer, HMSTrackUpdate, HMSUpdateListener } from '../../interfaces';\nimport { HMSRemoteAudioTrack, HMSRemoteTrack, HMSRemoteVideoTrack, HMSTrackType } from '../../media/tracks';\nimport { HMSRemotePeer } from '../../sdk/models/peer';\nimport { IStore } from '../../sdk/store';\nimport HMSLogger from '../../utils/logger';\nimport { OnTrackLayerUpdateNotification, TrackState, TrackStateNotification } from '../HMSNotifications';\n\n/**\n * Handles:\n * - Incoming track meta-data from BIZ(signal) to match a track to a peer.\n * - Incoming MediaStreamTracks(wrapped in HMSTracks) from RTCMediaChannel.\n * - Mute/unmute track meta-data updates from BIZ.\n *\n * Since track meta-data and RTC tracks come in asynchronously,\n * we store the track meta-data(TrackState) in SDK Store and tracks temporarily here in tracksToProcess.\n *\n * Once we have both TrackState and track,\n * we add it to peer, send listener.onTrackUpdate and remove it from tracksToProcess.\n *\n * Gotchas:\n * - TRACK_UPDATE comes before TRACK_ADD -> update state, process pending tracks when TRACK_ADD arrives.\n */\nexport class TrackManager {\n  private readonly TAG = '[TrackManager]';\n  private tracksToProcess: Map<string, HMSRemoteTrack> = new Map();\n\n  constructor(private store: IStore, private eventBus: EventBus, public listener?: HMSUpdateListener) {}\n\n  handleTrackMetadataAdd(params: TrackStateNotification) {\n    HMSLogger.d(this.TAG, `TRACK_METADATA_ADD`, JSON.stringify(params, null, 2));\n\n    for (const trackId in params.tracks) {\n      this.store.setTrackState({\n        peerId: params.peer.peer_id,\n        trackInfo: params.tracks[trackId],\n      });\n    }\n\n    this.processPendingTracks();\n  }\n\n  /**\n   * Sets the tracks to peer and returns the peer\n   */\n  handleTrackAdd = (track: HMSRemoteTrack) => {\n    HMSLogger.d(this.TAG, `ONTRACKADD`, `${track}`);\n    this.store.addTrack(track);\n    this.tracksToProcess.set(track.trackId, track);\n    this.processPendingTracks();\n  };\n\n  /**\n   * Sets the track of corresponding peer to null and returns the peer\n   */\n  handleTrackRemove = (track: HMSRemoteTrack) => {\n    HMSLogger.d(this.TAG, `ONTRACKREMOVE`, `${track}`);\n    const trackStateEntry = this.store.getTrackState(track.trackId);\n\n    if (!trackStateEntry) {\n      return;\n    }\n\n    // emit this event here as peer will already be removed(if left the room) by the time this event is received\n    track.type === HMSTrackType.AUDIO && this.eventBus.audioTrackRemoved.publish(track as HMSRemoteAudioTrack);\n    this.store.removeTrack(track.trackId);\n    const hmsPeer = this.store.getPeerById(trackStateEntry.peerId);\n    if (!hmsPeer) {\n      return;\n    }\n    this.removePeerTracks(hmsPeer, track);\n    this.listener?.onTrackUpdate(HMSTrackUpdate.TRACK_REMOVED, track, hmsPeer);\n  };\n\n  handleTrackLayerUpdate = (params: OnTrackLayerUpdateNotification) => {\n    for (const trackId in params.tracks) {\n      const trackEntry = params.tracks[trackId];\n      const track = this.store.getTrackById(trackId);\n      if (!track) {\n        continue;\n      }\n\n      const peer = this.store.getPeerByTrackId(trackId)!;\n      if (!peer) {\n        continue;\n      }\n\n      if (track instanceof HMSRemoteVideoTrack) {\n        this.setLayer(track, trackEntry);\n      }\n    }\n  };\n\n  handleTrackUpdate = (params: TrackStateNotification) => {\n    const hmsPeer = this.store.getPeerById(params.peer.peer_id);\n    if (!hmsPeer) {\n      HMSLogger.d(this.TAG, 'Track Update ignored - Peer not added to store');\n      return;\n    }\n\n    for (const trackId in params.tracks) {\n      const currentTrackStateInfo = Object.assign({}, this.store.getTrackState(trackId)?.trackInfo);\n\n      const trackEntry = params.tracks[trackId];\n      const track = this.store.getTrackById(trackId);\n\n      this.store.setTrackState({\n        peerId: params.peer.peer_id,\n        trackInfo: { ...currentTrackStateInfo, ...trackEntry },\n      });\n\n      // TRACK_UPDATE came before TRACK_ADD -> update state, process pending tracks when TRACK_ADD arrives.\n      if (!track || this.tracksToProcess.has(trackId)) {\n        this.processPendingTracks();\n      } else {\n        track.setEnabled(!trackEntry.mute);\n        const eventType = this.processTrackUpdate(track as HMSRemoteTrack, currentTrackStateInfo, trackEntry);\n        if (eventType) {\n          this.listener?.onTrackUpdate(eventType, track, hmsPeer);\n        }\n      }\n    }\n  };\n\n  processPendingTracks() {\n    const tracksCopy = new Map(this.tracksToProcess);\n    tracksCopy.forEach(track => {\n      const state = this.store.getTrackState(track.trackId);\n      if (!state) {\n        HMSLogger.d(this.TAG, 'TrackState not added to store', `peerId - ${track.peerId}`, `trackId -${track.trackId}`);\n        return;\n      }\n\n      const hmsPeer = this.store.getPeerById(state.peerId);\n      if (!hmsPeer) {\n        HMSLogger.d(this.TAG, 'Peer not added to store, peerId', state.peerId);\n        return;\n      }\n\n      track.source = state.trackInfo.source;\n      track.peerId = hmsPeer.peerId;\n      // set log identifier to initial name of the peer\n      track.logIdentifier = hmsPeer.name;\n      track.setEnabled(!state.trackInfo.mute);\n      this.addAudioTrack(hmsPeer, track);\n      this.addVideoTrack(hmsPeer, track);\n      /**\n       * Don't call onTrackUpdate for audio elements immediately because the operations(eg: setVolume) performed\n       * on onTrackUpdate can be overriden in AudioSinkManager when audio element is created\n       **/\n      track.type === HMSTrackType.AUDIO\n        ? this.eventBus.audioTrackAdded.publish({ track: track as HMSRemoteAudioTrack, peer: hmsPeer as HMSRemotePeer })\n        : this.listener?.onTrackUpdate(HMSTrackUpdate.TRACK_ADDED, track, hmsPeer);\n      this.tracksToProcess.delete(track.trackId);\n    });\n  }\n\n  private setLayer(track: HMSRemoteVideoTrack, layerUpdate: VideoTrackLayerUpdate) {\n    const peer = this.store.getPeerByTrackId(track.trackId)!;\n    if (!peer) {\n      return;\n    }\n    const isDegraded = track.setLayerFromServer(layerUpdate);\n    if (isDegraded) {\n      this.listener?.onTrackUpdate(HMSTrackUpdate.TRACK_DEGRADED, track, peer);\n    } else {\n      this.listener?.onTrackUpdate(HMSTrackUpdate.TRACK_RESTORED, track, peer);\n    }\n  }\n\n  private removePeerTracks(hmsPeer: HMSPeer, track: HMSRemoteTrack) {\n    const auxiliaryTrackIndex = hmsPeer.auxiliaryTracks.indexOf(track);\n    if (auxiliaryTrackIndex > -1) {\n      hmsPeer.auxiliaryTracks.splice(auxiliaryTrackIndex, 1);\n    } else {\n      if (track.type === HMSTrackType.AUDIO && hmsPeer.audioTrack?.trackId === track.trackId) {\n        hmsPeer.audioTrack = undefined;\n      } else if (track.type === HMSTrackType.VIDEO && hmsPeer.videoTrack?.trackId === track.trackId) {\n        hmsPeer.videoTrack = undefined;\n      }\n    }\n  }\n\n  private addAudioTrack(hmsPeer: HMSPeer, track: HMSRemoteTrack) {\n    if (track.type !== HMSTrackType.AUDIO) {\n      return;\n    }\n    if (!hmsPeer.audioTrack && track.source === 'regular') {\n      hmsPeer.audioTrack = track as HMSRemoteAudioTrack;\n    } else {\n      hmsPeer.auxiliaryTracks.push(track);\n    }\n  }\n\n  private addVideoTrack(hmsPeer: HMSPeer, track: HMSRemoteTrack) {\n    if (track.type !== HMSTrackType.VIDEO) {\n      return;\n    }\n    const remoteTrack = track as HMSRemoteVideoTrack;\n    const simulcastDefinitions = this.store.getSimulcastDefinitionsForPeer(hmsPeer, remoteTrack.source!);\n    remoteTrack.setSimulcastDefinitons(simulcastDefinitions);\n    if (!hmsPeer.videoTrack && track.source === 'regular') {\n      hmsPeer.videoTrack = remoteTrack;\n    } else {\n      hmsPeer.auxiliaryTracks.push(remoteTrack);\n    }\n  }\n\n  private processTrackUpdate(track: HMSRemoteTrack, currentTrackState: TrackState, trackState: TrackState) {\n    let eventType;\n    if (currentTrackState.mute !== trackState.mute) {\n      eventType = trackState.mute ? HMSTrackUpdate.TRACK_MUTED : HMSTrackUpdate.TRACK_UNMUTED;\n      track.type === HMSTrackType.AUDIO &&\n        this.eventBus.audioTrackUpdate.publish({ track: track as HMSRemoteAudioTrack, enabled: !trackState.mute });\n    } else if (currentTrackState.description !== trackState.description) {\n      eventType = HMSTrackUpdate.TRACK_DESCRIPTION_CHANGED;\n    }\n    return eventType;\n  }\n}\n", "import { ActiveSpeakerManager } from './managers/ActiveSpeakerManager';\nimport { BroadcastManager } from './managers/BroadcastManager';\nimport { ConnectionQualityManager } from './managers/ConnectionQualityManager';\nimport { PeerListManager } from './managers/PeerListManager';\nimport { PeerManager } from './managers/PeerManager';\nimport { PolicyChangeManager } from './managers/PolicyChangeManager';\nimport { RequestManager } from './managers/RequestManager';\nimport { RoomUpdateManager } from './managers/RoomUpdateManager';\nimport { TrackManager } from './managers/TrackManager';\nimport { HMSNotificationMethod } from './HMSNotificationMethod';\nimport {\n  ConnectionQualityList,\n  OnTrackLayerUpdateNotification,\n  PolicyParams,\n  SpeakerList,\n  TrackStateNotification,\n} from './HMSNotifications';\nimport { EventBus } from '../events/EventBus';\nimport { HMSAudioListener, HMSConnectionQualityListener, HMSUpdateListener } from '../interfaces';\nimport { HMSRemoteTrack } from '../media/tracks';\nimport { IStore } from '../sdk/store';\nimport HMSLogger from '../utils/logger';\n\nexport class NotificationManager {\n  private readonly TAG = '[HMSNotificationManager]';\n  private trackManager: TrackManager;\n  private peerManager: PeerManager;\n  private peerListManager: PeerListManager;\n  private activeSpeakerManager: ActiveSpeakerManager;\n  private connectionQualityManager: ConnectionQualityManager;\n  private broadcastManager: BroadcastManager;\n  private policyChangeManager: PolicyChangeManager;\n  private requestManager: RequestManager;\n  private roomUpdateManager: RoomUpdateManager;\n  /**\n   * room state can be sent before join in preview stage as well but that is outdated, based on\n   * eventual consistency and doesn't have all data. If we get at least one consistent room update\n   * from that point onwards we can rely on live server updates and ignore periodic room state messages\n   */\n  private hasConsistentRoomStateArrived = false;\n\n  constructor(\n    private store: IStore,\n    eventBus: EventBus,\n    private listener?: HMSUpdateListener,\n    private audioListener?: HMSAudioListener,\n    private connectionQualityListener?: HMSConnectionQualityListener,\n  ) {\n    this.trackManager = new TrackManager(this.store, eventBus, this.listener);\n    this.peerManager = new PeerManager(this.store, this.trackManager, this.listener);\n    this.peerListManager = new PeerListManager(this.store, this.peerManager, this.trackManager, this.listener);\n    this.broadcastManager = new BroadcastManager(this.store, this.listener);\n    this.policyChangeManager = new PolicyChangeManager(this.store, eventBus);\n    this.requestManager = new RequestManager(this.store, this.listener);\n    this.activeSpeakerManager = new ActiveSpeakerManager(this.store, this.listener, this.audioListener);\n    this.connectionQualityManager = new ConnectionQualityManager(this.connectionQualityListener);\n    this.roomUpdateManager = new RoomUpdateManager(this.store, this.listener);\n  }\n\n  setListener(listener?: HMSUpdateListener) {\n    this.listener = listener;\n    this.trackManager.listener = listener;\n    this.peerManager.listener = listener;\n    this.peerListManager.listener = listener;\n    this.broadcastManager.listener = listener;\n    this.requestManager.listener = listener;\n    this.activeSpeakerManager.listener = listener;\n    this.roomUpdateManager.listener = listener;\n  }\n\n  setAudioListener(audioListener?: HMSAudioListener) {\n    this.audioListener = audioListener;\n    this.activeSpeakerManager.audioListener = audioListener;\n  }\n\n  setConnectionQualityListener(qualityListener?: HMSConnectionQualityListener) {\n    this.connectionQualityListener = qualityListener;\n    this.connectionQualityManager.listener = qualityListener;\n  }\n\n  handleNotification(message: { method: string; params: any }, isReconnecting = false) {\n    const method = message.method as HMSNotificationMethod;\n    const notification = message.params;\n\n    if (\n      ![\n        HMSNotificationMethod.ACTIVE_SPEAKERS,\n        HMSNotificationMethod.SFU_STATS,\n        HMSNotificationMethod.CONNECTION_QUALITY,\n        undefined, // this is is to ignore notifications without any method\n      ].includes(method)\n    ) {\n      HMSLogger.d(this.TAG, `Received notification - ${method}`, { notification });\n    }\n    if (method === HMSNotificationMethod.SFU_STATS) {\n      if (window.HMS?.ON_SFU_STATS && typeof window.HMS?.ON_SFU_STATS === 'function') {\n        window.HMS.ON_SFU_STATS(message.params);\n      }\n    }\n\n    if (this.ignoreNotification(method)) {\n      return;\n    }\n\n    this.roomUpdateManager.handleNotification(method, notification);\n    this.peerManager.handleNotification(method, notification);\n    this.requestManager.handleNotification(method, notification);\n    this.peerListManager.handleNotification(method, notification, isReconnecting);\n    this.broadcastManager.handleNotification(method, notification);\n    this.handleIsolatedMethods(method, notification);\n  }\n\n  // eslint-disable-next-line complexity\n  handleIsolatedMethods(method: string, notification: any) {\n    switch (method) {\n      case HMSNotificationMethod.TRACK_METADATA_ADD: {\n        this.trackManager.handleTrackMetadataAdd(notification as TrackStateNotification);\n        break;\n      }\n      case HMSNotificationMethod.TRACK_UPDATE: {\n        this.trackManager.handleTrackUpdate(notification as TrackStateNotification);\n        break;\n      }\n      case HMSNotificationMethod.ON_SFU_TRACK_LAYER_UPDATE: {\n        this.trackManager.handleTrackLayerUpdate(notification as OnTrackLayerUpdateNotification);\n        break;\n      }\n      case HMSNotificationMethod.ACTIVE_SPEAKERS:\n        this.activeSpeakerManager.handleActiveSpeakers(notification as SpeakerList);\n        break;\n\n      case HMSNotificationMethod.CONNECTION_QUALITY:\n        this.connectionQualityManager.handleQualityUpdate(notification as ConnectionQualityList);\n        break;\n\n      case HMSNotificationMethod.POLICY_CHANGE:\n        this.policyChangeManager.handlePolicyChange(notification as PolicyParams);\n        break;\n\n      default:\n        break;\n    }\n  }\n\n  ignoreNotification = (method: string): boolean => {\n    if (method === HMSNotificationMethod.PEER_LIST) {\n      this.hasConsistentRoomStateArrived = true;\n    } else if (method === HMSNotificationMethod.ROOM_STATE) {\n      // ignore periodic inconsistent room state if consistent one has arrived at least once\n      return this.hasConsistentRoomStateArrived;\n    }\n    return false;\n  };\n\n  handleTrackAdd = (track: HMSRemoteTrack) => {\n    this.trackManager.handleTrackAdd(track);\n  };\n\n  handleTrackRemove = (track: HMSRemoteTrack) => {\n    this.trackManager.handleTrackRemove(track);\n  };\n\n  updateLocalPeer = ({ name, metadata }: { name?: string; metadata?: string }) => {\n    const peer = this.store.getLocalPeer();\n    this.peerManager.handlePeerInfoUpdate({ peer, name, data: metadata });\n  };\n}\n", "import { VideoTrackLayerUpdate } from '../connection/channel-messages';\nimport { HMSRole } from '../interfaces/role';\nimport { HMSLocalTrack } from '../media/tracks';\nimport { HMSTrack, HMSTrackSource } from '../media/tracks/HMSTrack';\nimport { Track } from '../signal/interfaces';\n\n/**\n * Interfaces for message received from BIZ Signal through Websocket.\n * These messages are handled by NotificationManager\n * which will call the corresponding HMSUpdateListener callbacks.\n */\n\nexport interface ServerError {\n  code: number;\n  message?: string;\n}\n\nexport interface TrackStateNotification {\n  tracks: {\n    [track_id: string]: TrackState;\n  };\n  peer: PeerNotificationInfo;\n}\n\nexport interface OnTrackLayerUpdateNotification {\n  tracks: {\n    [track_id: string]: VideoTrackLayerUpdate;\n  };\n}\n\nexport interface PeerNotificationInfo {\n  peer_id: string;\n  info: Info;\n}\n\nexport interface Info {\n  name: string;\n  data: string;\n  user_id: string;\n}\n\nexport interface PolicyParams {\n  name: string;\n  known_roles: {\n    [role: string]: HMSRole;\n  };\n  template_id: string;\n}\n\n/**\n * This is in a format biz sends/received the track metadata\n */\nexport class TrackState implements Track {\n  mute: boolean;\n  type: 'audio' | 'video';\n  source: HMSTrackSource;\n  description: string;\n  track_id: string;\n  stream_id: string;\n\n  constructor(track: HMSLocalTrack | Track) {\n    this.type = track.type;\n    this.source = track.source || 'regular';\n    this.description = '';\n    if (track instanceof HMSTrack) {\n      this.mute = !track.enabled;\n      this.track_id = track.publishedTrackId!;\n      this.stream_id = track.stream.id;\n    } else {\n      this.mute = track.mute;\n      this.track_id = track.track_id;\n      this.stream_id = track.stream_id;\n    }\n  }\n}\n\nexport interface PeerNotification {\n  peer_id: string;\n  info: Info;\n  role: string;\n  joined_at?: number;\n  tracks: {\n    [track_id: string]: TrackState;\n  };\n  is_from_room_state?: boolean;\n}\n\nexport interface RoomState {\n  name: string;\n  session_id?: string;\n  started_at?: number;\n  recording?: {\n    sfu: {\n      started_at?: number;\n      enabled: boolean;\n    };\n    browser: {\n      started_at?: number;\n      enabled: boolean;\n    };\n    hls: {\n      started_at?: number;\n      enabled: boolean;\n      config?: {\n        hls_vod: boolean;\n        single_file_per_layer: boolean;\n      };\n    };\n  };\n  streaming?: {\n    enabled: boolean;\n    rtmp: { enabled: boolean; started_at?: number };\n    hls: HLSNotification;\n  };\n}\n\nexport interface PeerListNotification {\n  peers: {\n    [peer_id: string]: PeerNotification;\n  };\n  room: RoomState;\n}\n\nexport interface PeriodicRoomState {\n  peer_count: number;\n  room: RoomState;\n  peers?: {\n    [peer_id: string]: PeerNotification;\n  };\n}\n\ninterface Speaker {\n  peer_id: string;\n  track_id: string;\n  level: number;\n}\n\nexport interface SpeakerList {\n  'speaker-list': Speaker[];\n}\n\ninterface ConnectionQuality {\n  peer_id: string;\n  downlink_score: number;\n}\n\nexport interface ConnectionQualityList {\n  peers: ConnectionQuality[];\n}\n\n/**\n * Represents the role change request received from the server\n */\nexport interface RoleChangeRequestParams {\n  requested_by?: string;\n  role: string;\n  token: string;\n}\n\nexport interface TrackUpdateRequestNotification {\n  requested_by?: string;\n  track_id: string;\n  stream_id: string;\n  mute: boolean;\n}\n\nexport interface ChangeTrackMuteStateNotification {\n  requested_by?: string;\n  roles?: string[];\n  type?: 'audio' | 'video';\n  source?: HMSTrackSource;\n  value: boolean;\n}\n\nexport interface PeerLeaveRequestNotification {\n  requested_by?: string;\n  reason: string;\n  room_end: boolean;\n}\n\nexport interface MessageNotification {\n  peer?: {\n    peer_id: string;\n    info: {\n      name: string;\n      data: any;\n      user_id: string;\n    };\n  };\n  roles?: string[];\n  private: boolean;\n  timestamp: number;\n  info: MessageNotificationInfo;\n}\n\nexport interface SendMessage {\n  info: MessageNotificationInfo;\n  roles?: string[];\n  peer_id?: string;\n}\n\nexport interface MessageNotificationInfo {\n  message: any;\n  type: string;\n}\n\nexport interface RecordingNotification {\n  type: 'sfu' | 'Browser';\n  started_at?: number;\n  peer?: PeerNotificationInfo;\n  error?: ServerError;\n}\n\nexport interface RTMPNotification {\n  peer?: PeerNotificationInfo;\n  started_at?: number;\n  error?: ServerError;\n}\n\nexport interface HLSNotification {\n  enabled: boolean;\n  variants?: Array<HLSVariantInfo>;\n  error?: ServerError;\n  hls_recording?: {\n    hls_vod: boolean;\n    single_file_per_layer: boolean;\n  };\n}\n\nexport interface HLSVariantInfo {\n  url: string;\n  meeting_url?: string;\n  metadata?: string;\n  started_at?: number;\n}\n", "import HMSLogger from '../utils/logger';\n\nexport class AudioContextManager {\n  private audioContext: AudioContext;\n  private destinationNode?: MediaStreamAudioDestinationNode;\n  private source: MediaElementAudioSourceNode;\n  private readonly TAG = '[AudioContextManager]';\n\n  constructor(element: HTMLMediaElement) {\n    this.audioContext = new AudioContext();\n    this.source = this.audioContext.createMediaElementSource(element);\n    this.source.connect(this.audioContext.destination);\n  }\n\n  /**\n   * Resume AudioContext if it is suspended\n   * Note: when the browser tab is muted by default, AudioContext will be in suspended state\n   * It has to be resumed for the video/audio to be played.\n   */\n  resumeContext() {\n    if (this.audioContext.state === 'suspended') {\n      HMSLogger.d(this.TAG, 'AudioContext is resumed');\n      this.audioContext.resume();\n    }\n  }\n\n  getAudioTrack() {\n    // Always create a destinationNode to get new audio track id\n    if (this.destinationNode) {\n      this.source.disconnect(this.destinationNode);\n    }\n    this.destinationNode = this.audioContext.createMediaStreamDestination();\n    this.source.connect(this.destinationNode);\n    return this.destinationNode.stream.getAudioTracks()[0];\n  }\n\n  cleanup() {\n    if (this.audioContext.state !== 'closed') {\n      this.audioContext.close();\n    }\n  }\n}\n", "import { EventEmitter2 as EventEmitter } from 'eventemitter2';\n\n/**\n * Typed Event Emitter Reference:\n * https://rjzaworski.com/2019/10/event-emitters-in-typescript#a-typescript-event-emitter-interface\n */\n\nexport type EventMap = Record<string, any>;\n\nexport type EventKey<T extends EventMap> = string & keyof T;\nexport type EventReceiver<T> = (params: T) => void;\n\n// interface Emitter<T extends EventMap> {\n//   on<K extends EventKey<T>>(eventName: K, fn: EventReceiver<T[K]>): void;\n//   off<K extends EventKey<T>>(eventName: K, fn: EventReceiver<T[K]>): void;\n//   emit<K extends EventKey<T>>(eventName: K, params: T[K]): void;\n// }\n\nexport abstract class TypedEventEmitter<T extends EventMap> extends EventEmitter {\n  on<K extends EventKey<T>>(eventName: K, fn: EventReceiver<T[K]>) {\n    return super.on(eventName, fn);\n  }\n\n  off<K extends EventKey<T>>(eventName: K, fn: EventReceiver<T[K]>) {\n    return super.off(eventName, fn);\n  }\n\n  emit<K extends EventKey<T>>(eventName: K, params: T[K]) {\n    return super.emit(eventName, params);\n  }\n\n  listeners<K extends EventKey<T>>(eventName: K): EventReceiver<T[K]>[] {\n    return super.listeners(eventName) as EventReceiver<T[K]>[];\n  }\n}\n", "import { AudioContextManager } from './AudioContextManager';\nimport HMSLogger from '../utils/logger';\nimport { TypedEventEmitter } from '../utils/typed-event-emitter';\n\n/**\n * This class handles audio playlist management\n * - An audio element and audio context which processes audio from audio element is created\n *   in the constructor\n * It handles playback in the following steps\n *  - set's the url on the audio element created in the constructor\n *  - oncanplaythrough event of the audio element\n *    - resume the audio context if it is suspended\n *    - play the audio element\n *    - Get audio track from the audio context manager\n *    - The track is passed to playlist manager to publish\n */\nexport class PlaylistAudioManager extends TypedEventEmitter<{ ended: null; progress: Event }> {\n  private audioElement: HTMLAudioElement | null = null;\n  private track?: MediaStreamTrack;\n  private audioContextManager!: AudioContextManager;\n  private readonly TAG = '[PlaylistAudioManager]';\n  // This is to handle audio playing when seekTo is called when audio is paused\n  private seeked = false;\n\n  async play(url: string) {\n    this.audioElement = this.getAudioElement();\n    return new Promise<MediaStreamTrack[]>((resolve, reject) => {\n      this.audioElement = this.getAudioElement();\n      this.audioElement.src = url;\n      this.seeked = false;\n      this.audioElement.onerror = () => {\n        const error = `Error loading ${url}`;\n        HMSLogger.e(this.TAG, error);\n        this.stop();\n        reject(error);\n      };\n      // oncanplaythrough is called when enough media is loaded for play to be possible in two cases -\n      //    * when play is called for the first time\n      //    * when user seeks jumps to any mid track timestamp\n      this.audioElement.oncanplaythrough = async () => {\n        try {\n          if (!this.audioElement) {\n            return;\n          }\n          this.audioContextManager.resumeContext();\n          // Create audio track only once and reuse, it will be updated with current content\n          if (!this.track) {\n            await this.audioElement.play();\n            const audioTrack = this.audioContextManager.getAudioTrack();\n            this.track = audioTrack;\n            resolve([audioTrack]);\n          } else {\n            if (!this.seeked) {\n              // if this was called in response to a play call\n              await this.audioElement.play();\n              resolve([this.track]);\n            } else {\n              // if seek happened, there is no play call/promise to be resolved, just reset seeked\n              this.seeked = false;\n            }\n          }\n        } catch (err) {\n          HMSLogger.e(this.TAG, 'Error playing audio', url, (err as ErrorEvent).message);\n          reject(err);\n        }\n      };\n      this.audioElement.onseeked = () => {\n        this.seeked = true;\n      };\n    });\n  }\n\n  getTracks() {\n    return this.track ? [this.track.id] : [];\n  }\n\n  getElement() {\n    return this.audioElement;\n  }\n\n  stop() {\n    this.audioElement?.pause();\n    this.audioElement?.removeAttribute('src');\n    this.audioElement = null;\n    this.audioContextManager?.cleanup();\n    this.track = undefined;\n  }\n\n  private getAudioElement() {\n    if (this.audioElement) {\n      return this.audioElement;\n    }\n    const audioElement = document.createElement('audio');\n    audioElement.crossOrigin = 'anonymous';\n    audioElement.addEventListener('timeupdate', event => this.emit('progress', event));\n    audioElement.addEventListener('ended', () => {\n      this.emit('ended', null);\n    });\n    this.audioContextManager = new AudioContextManager(audioElement);\n    return audioElement;\n  }\n}\n", "import { AudioContextManager } from './AudioContextManager';\nimport HMSLogger from '../utils/logger';\nimport { TypedEventEmitter } from '../utils/typed-event-emitter';\n\n/**\n * This class handles video playlist management\n * - An video element, canvas and audio context which processes audio from video element is created\n *   in the constructor\n * It handles playback in the following steps\n *  - set's the url on the video element created in the constructor\n *  - oncanplaythrough event of the video element\n *    - resume the audio context if it is suspended\n *    - set width/height on canvas\n *    - captureStream on canvas element if not already captured\n *    - play the video element\n *    - on video element is played, it is drawn to canvas\n *    - Get audio track from the audio context manager\n *    - add audioTrack to canvas stream\n *    - The audio and video tracks are passed to playlist manager to publish\n */\nexport class PlaylistVideoManager extends TypedEventEmitter<{ ended: null; progress: Event }> {\n  private readonly TAG = '[PlaylistVideoManager]';\n  private videoElement: HTMLVideoElement | null = null;\n  private canvasContext: CanvasRenderingContext2D | null = null;\n  private canvas!: HTMLCanvasElement;\n  private timer: any;\n  private tracks: MediaStreamTrack[] = [];\n  private audioContextManager!: AudioContextManager;\n  private DEFAUL_FPS = 24;\n  // This is to handle video playing when seekTo is called when video is paused\n  private seeked = false;\n\n  play(url: string) {\n    this.videoElement = this.getVideoElement();\n    this.createCanvas();\n    return new Promise<MediaStreamTrack[]>((resolve, reject) => {\n      this.videoElement = this.getVideoElement();\n      this.videoElement.src = url;\n      this.seeked = false;\n      this.videoElement.onerror = () => {\n        const error = `Error loading ${url}`;\n        HMSLogger.e(this.TAG, error);\n        this.stop();\n        reject(error);\n      };\n      // oncanplaythrough is called when enough media is loaded for play to be possible in two cases -\n      //    * when play is called for the first time\n      //    * when user jumps to any mid track timestamp using seekTo\n      this.videoElement.oncanplaythrough = async () => {\n        try {\n          if (!this.videoElement) {\n            return;\n          }\n          this.canvas.width = this.videoElement.videoWidth;\n          this.canvas.height = this.videoElement.videoHeight;\n          // Capture stream only once and reuse the same tracks. it will be autoupdated with the selected video\n          if (this.tracks.length === 0) {\n            this.clearCanvasAndTracks();\n            //@ts-ignore\n            const stream = this.canvas.captureStream();\n            if (!stream) {\n              HMSLogger.e(this.TAG, 'Browser does not support captureStream');\n              return;\n            }\n            this.videoElement.onplay = this.drawImage;\n            this.audioContextManager.resumeContext();\n            await this.videoElement.play();\n            const audioTrack = this.audioContextManager.getAudioTrack();\n            stream.addTrack(audioTrack);\n            stream.getTracks().forEach((track: MediaStreamTrack) => {\n              this.tracks.push(track);\n            });\n            resolve(this.tracks);\n          } else {\n            // No need to capture canvas stream/get audio track. They wull be auto updated\n            if (!this.seeked) {\n              // if this was called in response to a play call\n              await this.videoElement.play();\n              resolve(this.tracks);\n            } else {\n              // if seek happened, there is no play call/promise to be resolved, just reset seeked\n              this.seeked = false;\n              // This event will be called on seekTo when paused. Just draw the one frame on canvas.\n              this.canvasContext?.drawImage(this.videoElement, 0, 0, this.canvas?.width, this.canvas?.height);\n            }\n          }\n        } catch (err) {\n          HMSLogger.e(this.TAG, 'Error playing video', url, (err as ErrorEvent).message);\n          reject(err);\n        }\n      };\n      this.videoElement.onseeked = () => {\n        this.seeked = true;\n      };\n    });\n  }\n\n  getTracks() {\n    return this.tracks.map(track => track.id);\n  }\n\n  getElement() {\n    return this.videoElement;\n  }\n\n  stop() {\n    this.videoElement?.pause();\n    this.videoElement?.removeAttribute('src');\n    this.videoElement = null;\n    this.audioContextManager?.cleanup();\n    this.clearCanvasAndTracks();\n  }\n\n  private clearCanvasAndTracks() {\n    this.tracks = [];\n    // clear canvas before playing new video\n    this.canvasContext?.clearRect(0, 0, this.canvas.width, this.canvas.height);\n    clearTimeout(this.timer);\n  }\n\n  private drawImage = () => {\n    if (this.videoElement && !this.videoElement.paused && !this.videoElement.ended) {\n      this.canvasContext?.drawImage(this.videoElement, 0, 0, this.canvas?.width, this.canvas?.height);\n      this.timer = setTimeout(() => {\n        this.drawImage();\n      }, 1000 / this.DEFAUL_FPS);\n    }\n  };\n\n  private getVideoElement() {\n    if (this.videoElement) {\n      return this.videoElement;\n    }\n    const videoElement = document.createElement('video');\n    videoElement.crossOrigin = 'anonymous';\n    videoElement.addEventListener('timeupdate', event => this.emit('progress', event));\n    videoElement.addEventListener('ended', () => {\n      this.emit('ended', null);\n    });\n    this.audioContextManager = new AudioContextManager(videoElement);\n    return videoElement;\n  }\n\n  private createCanvas() {\n    if (!this.canvas) {\n      this.canvas = document.createElement('canvas');\n      this.canvasContext = this.canvas.getContext('2d');\n    }\n  }\n}\n", "import { PlaylistAudioManager } from './PlaylistAudioManager';\nimport { PlaylistVideoManager } from './PlaylistVideoManager';\nimport { ErrorFactory, HMSAction } from '../error/ErrorFactory';\nimport { EventBus } from '../events/EventBus';\nimport { HMSPlaylistItem, HMSPlaylistManager, HMSPlaylistProgressEvent, HMSPlaylistType } from '../interfaces';\nimport { HMSLocalTrack } from '../media/tracks';\nimport { HMSSdk } from '../sdk';\nimport { stringifyMediaStreamTrack } from '../utils/json';\nimport HMSLogger from '../utils/logger';\nimport { TypedEventEmitter } from '../utils/typed-event-emitter';\n\ntype PlaylistManagerState<T> = {\n  audio: {\n    list: HMSPlaylistItem<T>[];\n    currentIndex: number;\n    isAutoplayOn: boolean;\n  };\n  video: {\n    list: HMSPlaylistItem<T>[];\n    currentIndex: number;\n    isAutoplayOn: boolean;\n  };\n};\n\nconst INITIAL_STATE: PlaylistManagerState<any> = {\n  audio: {\n    list: [],\n    currentIndex: -1,\n    isAutoplayOn: true,\n  },\n  video: {\n    list: [],\n    currentIndex: -1,\n    isAutoplayOn: true,\n  },\n};\n\nexport class PlaylistManager\n  extends TypedEventEmitter<{\n    newTrackStart: HMSPlaylistItem<any>;\n    playlistEnded: HMSPlaylistType;\n    currentTrackEnded: HMSPlaylistItem<any>;\n  }>\n  implements HMSPlaylistManager\n{\n  private state = { audio: { ...INITIAL_STATE.audio }, video: { ...INITIAL_STATE.video } };\n  private audioManager: PlaylistAudioManager;\n  private videoManager: PlaylistVideoManager;\n  private readonly TAG = '[PlaylistManager]';\n\n  constructor(private sdk: HMSSdk, private eventBus: EventBus) {\n    super();\n    this.audioManager = new PlaylistAudioManager();\n    this.videoManager = new PlaylistVideoManager();\n    this.addListeners();\n  }\n\n  getList<T>(type: HMSPlaylistType = HMSPlaylistType.audio): HMSPlaylistItem<T>[] {\n    return this.state[type].list;\n  }\n\n  setList<T>(list: HMSPlaylistItem<T>[]): void {\n    if (!list || list.length === 0) {\n      HMSLogger.w(this.TAG, `Please pass in a list of HMSPlaylistItem's`);\n      return;\n    }\n    list.forEach((item: HMSPlaylistItem<T>) => {\n      if (!this.state[item.type].list.includes(item)) {\n        this.state[item.type].list.push(item);\n      }\n    });\n  }\n\n  async clearList(type: HMSPlaylistType): Promise<void> {\n    if (this.isPlaying(type)) {\n      await this.stop(type);\n    }\n    this.state[type].list = [];\n  }\n\n  async removeItem(id: string, type: HMSPlaylistType): Promise<boolean> {\n    const { list, currentIndex } = this.state[type];\n    const index = list.findIndex(playItem => id === playItem.id);\n    if (index > -1) {\n      // stop if the item is playing\n      if (currentIndex === index && this.isPlaying(type)) {\n        await this.stop(type);\n      }\n      list.splice(index, 1);\n      return true;\n    }\n    return false;\n  }\n\n  seek(value: number, type: HMSPlaylistType = HMSPlaylistType.audio): void {\n    const { currentIndex } = this.state[type];\n    if (currentIndex === -1) {\n      throw ErrorFactory.PlaylistErrors.NoEntryToPlay(HMSAction.PLAYLIST, 'No item is currently playing');\n    }\n    const element = this.getElement(type);\n    if (element) {\n      const updatedValue = Math.max(element.currentTime + value, 0);\n      element.currentTime = Math.min(updatedValue, element.duration);\n    }\n  }\n\n  seekTo(value: number, type: HMSPlaylistType = HMSPlaylistType.audio): void {\n    const { currentIndex } = this.state[type];\n    if (currentIndex === -1) {\n      throw ErrorFactory.PlaylistErrors.NoEntryToPlay(HMSAction.PLAYLIST, 'No item is currently playing');\n    }\n    if (value < 0) {\n      throw Error('value cannot be negative');\n    }\n    const element = this.getElement(type);\n    if (element) {\n      element.currentTime = Math.min(value, element.duration);\n    }\n  }\n\n  setVolume(value: number, type: HMSPlaylistType = HMSPlaylistType.audio): void {\n    if (value < 0 || value > 100) {\n      throw Error('Please pass a valid number between 0-100');\n    }\n    const element = this.getElement(type);\n    if (element) {\n      element.volume = value * 0.01;\n    }\n  }\n\n  getVolume(type: HMSPlaylistType = HMSPlaylistType.audio): number {\n    const element = this.getElement(type);\n    if (element) {\n      return element.volume * 100;\n    }\n    return 0;\n  }\n\n  getCurrentTime(type: HMSPlaylistType = HMSPlaylistType.audio) {\n    const element = this.getElement(type);\n    return element?.currentTime || 0;\n  }\n\n  getCurrentIndex(type: HMSPlaylistType = HMSPlaylistType.audio) {\n    return this.state[type].currentIndex;\n  }\n\n  getCurrentProgress(type: HMSPlaylistType = HMSPlaylistType.audio) {\n    const { list, currentIndex } = this.state[type];\n    const activeUrl = list[currentIndex]?.url;\n    const element = this.getElement(type);\n    if (!activeUrl || !element) {\n      return 0;\n    }\n    return Math.floor(100 * (element.currentTime / element.duration));\n  }\n\n  getCurrentSelection(type: HMSPlaylistType = HMSPlaylistType.audio) {\n    const { list, currentIndex } = this.state[type];\n    if (currentIndex === -1) {\n      return undefined;\n    }\n    return list[currentIndex];\n  }\n\n  isPlaying(type: HMSPlaylistType = HMSPlaylistType.audio) {\n    const element = this.getElement(type);\n    return !!element && !element.paused;\n  }\n\n  setIsAutoplayOn(type: HMSPlaylistType = HMSPlaylistType.audio, autoplay: boolean) {\n    this.state[type].isAutoplayOn = autoplay;\n  }\n\n  getPlaybackRate(type: HMSPlaylistType = HMSPlaylistType.audio) {\n    const element = this.getElement(type);\n    return element ? element.playbackRate : 1.0;\n  }\n\n  setPlaybackRate(type: HMSPlaylistType = HMSPlaylistType.audio, value: number) {\n    if (value < 0.25 || value > 2.0) {\n      throw Error('Please pass a value between 0.25 and 2.0');\n    }\n    const element = this.getElement(type);\n    if (element) {\n      element.playbackRate = value;\n    }\n  }\n\n  async setEnabled(\n    enabled: boolean,\n    { id, type = HMSPlaylistType.audio }: { id: string; type: HMSPlaylistType },\n  ): Promise<void> {\n    const list = this.state[type].list;\n    const currentIndex = list.findIndex(item => item.id === id);\n    if (!id || currentIndex === -1) {\n      HMSLogger.w(this.TAG, 'Pass a valid id');\n      return;\n    }\n    const url = this.state[type].list[currentIndex].url;\n    if (enabled) {\n      await this.play(url, type);\n    } else {\n      await this.pause(url, type);\n    }\n    this.state[type].currentIndex = currentIndex;\n    this.setDuration(type);\n  }\n\n  async playNext(type: HMSPlaylistType = HMSPlaylistType.audio): Promise<void> {\n    const { list, currentIndex } = this.state[type];\n    if (currentIndex >= list.length - 1) {\n      throw ErrorFactory.PlaylistErrors.NoEntryToPlay(HMSAction.PLAYLIST, 'Reached end of playlist');\n    }\n    await this.play(list[currentIndex + 1].url, type);\n    this.state[type].currentIndex = currentIndex + 1;\n    this.setDuration(type);\n  }\n\n  async playPrevious(type: HMSPlaylistType = HMSPlaylistType.audio): Promise<void> {\n    const { list, currentIndex } = this.state[type];\n    if (currentIndex <= 0) {\n      throw ErrorFactory.PlaylistErrors.NoEntryToPlay(HMSAction.PLAYLIST, 'Reached start of playlist');\n    }\n    await this.play(list[currentIndex - 1].url, type);\n    this.state[type].currentIndex = currentIndex - 1;\n    this.setDuration(type);\n  }\n\n  async stop(type: HMSPlaylistType = HMSPlaylistType.audio): Promise<void> {\n    const manager = type === HMSPlaylistType.audio ? this.audioManager : this.videoManager;\n    manager.getElement()?.pause(); //pause local video/audio and remove tracks in next step\n    await this.removeTracks(type);\n    manager.stop();\n    this.state[type].currentIndex = -1;\n  }\n\n  cleanup() {\n    this.state = { audio: { ...INITIAL_STATE.audio }, video: { ...INITIAL_STATE.video } };\n    this.eventBus.localAudioEnabled.unsubscribe(this.handlePausePlaylist);\n    this.eventBus.localVideoEnabled.unsubscribe(this.handlePausePlaylist);\n    this.audioManager.stop();\n    this.videoManager.stop();\n  }\n\n  onProgress(fn: (progress: HMSPlaylistProgressEvent) => void) {\n    this.videoManager.on('progress', () => {\n      try {\n        fn({\n          type: HMSPlaylistType.video,\n          progress: this.getCurrentProgress(HMSPlaylistType.video),\n        });\n      } catch (error) {\n        HMSLogger.e(this.TAG, 'Error in onProgress callback');\n      }\n    });\n    this.audioManager.on('progress', () => {\n      try {\n        fn({\n          type: HMSPlaylistType.audio,\n          progress: this.getCurrentProgress(HMSPlaylistType.audio),\n        });\n      } catch (error) {\n        HMSLogger.e(this.TAG, 'Error in onProgress callback');\n      }\n    });\n  }\n\n  onNewTrackStart<T>(fn: (item: HMSPlaylistItem<T>) => void) {\n    this.on('newTrackStart', fn);\n  }\n\n  onPlaylistEnded(fn: (type: HMSPlaylistType) => void) {\n    this.on('playlistEnded', fn);\n  }\n\n  onCurrentTrackEnded<T>(fn: (item: HMSPlaylistItem<T>) => void) {\n    this.on('currentTrackEnded', fn);\n  }\n\n  private getElement(type: HMSPlaylistType = HMSPlaylistType.audio) {\n    return type === HMSPlaylistType.audio ? this.audioManager.getElement() : this.videoManager.getElement();\n  }\n\n  private async removeTracks(type: HMSPlaylistType = HMSPlaylistType.audio) {\n    const manager = type === HMSPlaylistType.audio ? this.audioManager : this.videoManager;\n    const tracks = manager.getTracks();\n    for (const trackId of tracks) {\n      await this.removeTrack(trackId);\n    }\n  }\n\n  private async play(url: string, type: HMSPlaylistType = HMSPlaylistType.audio): Promise<void> {\n    const manager = type === HMSPlaylistType.audio ? this.audioManager : this.videoManager;\n    const element = manager.getElement();\n    if (this.isItemCurrentlyPlaying(url, type)) {\n      HMSLogger.w(this.TAG, `The ${type} is currently playing`);\n      return;\n    }\n    if (element?.src.includes(url)) {\n      await element.play();\n    } else {\n      element?.pause();\n      const tracks: MediaStreamTrack[] = await manager.play(url);\n      for (const track of tracks) {\n        await this.addTrack(track, type === HMSPlaylistType.audio ? 'audioplaylist' : 'videoplaylist');\n      }\n    }\n  }\n\n  private isItemCurrentlyPlaying(url: string, type: HMSPlaylistType): boolean {\n    const element = this.getElement(type);\n    return !!(element && !element.paused && element.src.includes(url));\n  }\n\n  private setDuration(type: HMSPlaylistType = HMSPlaylistType.audio) {\n    const element = this.getElement(type);\n    const { list, currentIndex } = this.state[type];\n    if (list[currentIndex]) {\n      list[currentIndex].duration = element?.duration || 0;\n    }\n    this.emit('newTrackStart', list[currentIndex]);\n  }\n\n  private async pause(url: string, type: HMSPlaylistType = HMSPlaylistType.audio): Promise<void> {\n    const el = this.getElement(type);\n    if (el && !el.paused && el.src.includes(url)) {\n      el.pause();\n      HMSLogger.d(this.TAG, 'paused url', url);\n    } else {\n      HMSLogger.w(this.TAG, 'The passed in url is not currently playing');\n    }\n  }\n\n  private handlePausePlaylist = async ({ enabled, track }: { enabled: boolean; track: HMSLocalTrack }) => {\n    if (enabled) {\n      return;\n    }\n    let type: HMSPlaylistType | undefined = undefined;\n    if (track.source === 'audioplaylist') {\n      type = HMSPlaylistType.audio;\n    }\n    if (track.source === 'videoplaylist') {\n      type = HMSPlaylistType.video;\n    }\n    if (!type) {\n      return;\n    }\n    this.getElement(type)?.pause();\n  };\n\n  private addListeners() {\n    this.audioManager.on('ended', () => this.handleEnded(HMSPlaylistType.audio));\n    this.videoManager.on('ended', () => this.handleEnded(HMSPlaylistType.video));\n    this.eventBus.localAudioEnabled.subscribe(this.handlePausePlaylist);\n    this.eventBus.localVideoEnabled.subscribe(this.handlePausePlaylist);\n  }\n\n  /**\n   * Remove tracks if reached the end of list otherwise play next\n   * @param {HMSPlaylistType} type\n   */\n  private async handleEnded(type: HMSPlaylistType = HMSPlaylistType.audio) {\n    const { list, currentIndex, isAutoplayOn } = this.state[type];\n    if (currentIndex === list.length - 1) {\n      await this.stop(type);\n      this.emit('playlistEnded', type);\n    } else {\n      if (isAutoplayOn) {\n        this.playNext(type);\n      } else {\n        // when autoplay not allowed, pause the media element\n        await this.pause(list[currentIndex].url, type);\n      }\n    }\n    this.emit('currentTrackEnded', list[currentIndex]);\n  }\n\n  private addTrack = async (track: MediaStreamTrack, source: string) => {\n    await this.sdk.addTrack(track, source);\n    HMSLogger.d(this.TAG, 'Playlist track added', stringifyMediaStreamTrack(track));\n  };\n\n  private removeTrack = async (trackId: string) => {\n    await this.sdk.removeTrack(trackId, true);\n    HMSLogger.d(this.TAG, 'Playlist track removed', trackId);\n  };\n}\n", "export class JoinParameters {\n  constructor(\n    public authToken: string,\n    public peerId: string,\n    public peerName: string = '',\n    public data: string = '',\n    public endpoint: string = 'https://prod-init.100ms.live/init',\n    public autoSubscribeVideo: boolean = false,\n  ) {}\n}\n", "export enum TransportFailureCategory {\n  ConnectFailed,\n  SignalDisconnect,\n  JoinWSMessageFailed,\n  PublishIceConnectionFailed,\n  SubscribeIceConnectionFailed,\n}\n\nexport const Dependencies = {\n  [TransportFailureCategory.ConnectFailed]: [],\n  [TransportFailureCategory.SignalDisconnect]: [],\n  [TransportFailureCategory.JoinWSMessageFailed]: [TransportFailureCategory.SignalDisconnect],\n  [TransportFailureCategory.PublishIceConnectionFailed]: [TransportFailureCategory.SignalDisconnect],\n  [TransportFailureCategory.SubscribeIceConnectionFailed]: [TransportFailureCategory.SignalDisconnect],\n};\n", "export enum TransportState {\n  Disconnected = 'Disconnected',\n  Connecting = 'Connecting',\n  Joined = 'Joined',\n  Preview = 'Preview',\n  Failed = 'Failed',\n  Reconnecting = 'Reconnecting',\n  Leaving = 'Leaving',\n}\n", "export interface PromiseCallbacks<T, K = void> {\n  resolve: (value: T) => void;\n  reject: (reason?: any) => void;\n  metadata?: K;\n}\n\nexport class PromiseWithCallbacks<T> {\n  promise: Promise<T>;\n  resolve!: (value: T) => void;\n  reject!: (reason?: any) => void;\n\n  constructor(cb: (resolve: (value: T) => void, reject: (reason?: any) => void) => any) {\n    this.promise = new Promise<T>((resolve, reject) => {\n      this.resolve = resolve;\n      this.reject = reject;\n      cb(resolve, reject);\n    });\n  }\n}\n", "import { Dependencies as TFCDependencies, TransportFailureCategory as TFC } from './models/TransportFailureCategory';\nimport { TransportState } from './models/TransportState';\nimport { HMSException } from '../error/HMSException';\nimport { MAX_TRANSPORT_RETRIES, MAX_TRANSPORT_RETRY_DELAY } from '../utils/constants';\nimport HMSLogger from '../utils/logger';\nimport { PromiseWithCallbacks } from '../utils/promise';\n\n/**\n * Task which is executed by [RetryScheduler.schedule] until max retry count\n * is reached.\n *\n * Any exception raised while executing the task assumes that task is failed.\n * Failed tasks are retried if max retry count is not reached.\n *\n * @returns True if the task if successful, otherwise False\n *\n *\n */\ntype RetryTask = () => Promise<boolean>;\n\ninterface ScheduleTaskParams {\n  category: TFC;\n  error: HMSException;\n  task: RetryTask;\n  originalState: TransportState;\n  maxFailedRetries?: number;\n  changeState?: boolean;\n}\n\nexport class RetryScheduler {\n  private readonly TAG = '[RetryScheduler]';\n  private inProgress = new Map<TFC, PromiseWithCallbacks<number>>();\n  private retryTaskIds: number[] = [];\n\n  constructor(\n    private onStateChange: (state: TransportState, error?: HMSException) => Promise<void>,\n    private sendEvent: (error: HMSException, category: TFC) => void,\n  ) {}\n\n  async schedule({\n    category,\n    error,\n    task,\n    originalState,\n    maxFailedRetries = MAX_TRANSPORT_RETRIES,\n    changeState = true,\n  }: ScheduleTaskParams) {\n    await this.scheduleTask({ category, error, changeState, task, originalState, maxFailedRetries });\n  }\n\n  reset() {\n    this.retryTaskIds.forEach(future => clearTimeout(future));\n    this.retryTaskIds = [];\n    this.inProgress.clear();\n  }\n\n  isTaskInProgress(category: TFC) {\n    return !!this.inProgress.get(category);\n  }\n\n  // eslint-disable-next-line complexity\n  private async scheduleTask({\n    category,\n    error,\n    changeState,\n    task,\n    originalState,\n    maxFailedRetries = MAX_TRANSPORT_RETRIES,\n    failedRetryCount = 0,\n  }: ScheduleTaskParams & { failedRetryCount?: number }): Promise<void> {\n    HMSLogger.d(this.TAG, 'schedule: ', { category: TFC[category], error });\n\n    // First schedule call\n    if (failedRetryCount === 0) {\n      const inProgressTask = this.inProgress.get(category);\n      if (inProgressTask) {\n        HMSLogger.d(this.TAG, `schedule: Already a task for ${TFC[category]} scheduled, waiting for its completion`);\n        await inProgressTask.promise;\n        return;\n      }\n\n      const taskPromise = new PromiseWithCallbacks<number>((_, __) => {});\n      this.inProgress.set(category, taskPromise);\n\n      this.sendEvent(error, category);\n    }\n\n    let hasFailedDependency = false;\n    const dependencies = TFCDependencies[category];\n\n    for (const dependencyIndexString in dependencies) {\n      const dependency = dependencies[parseInt(dependencyIndexString)];\n      try {\n        const dependencyTask = this.inProgress.get(dependency);\n        if (dependencyTask) {\n          HMSLogger.d(\n            this.TAG,\n            `schedule: Suspending retry task of ${TFC[category]}, waiting for ${TFC[dependency]} to recover`,\n          );\n          await dependencyTask.promise;\n          HMSLogger.d(\n            this.TAG,\n            `schedule: Resuming retry task ${TFC[category]} as it's dependency ${TFC[dependency]} is recovered`,\n          );\n        }\n      } catch (ex) {\n        HMSLogger.d(\n          this.TAG,\n          `schedule: Stopping retry task of ${TFC[category]} as it's dependency ${TFC[dependency]} failed to recover`,\n        );\n        hasFailedDependency = true;\n        break;\n      }\n    }\n\n    if (failedRetryCount >= maxFailedRetries || hasFailedDependency) {\n      error.description += `. [${TFC[category]}] Could not recover after ${failedRetryCount} tries`;\n\n      if (hasFailedDependency) {\n        error.description += ` Could not recover all of it's required dependencies - [${(dependencies as Array<TFC>)\n          .map(dep => TFC[dep])\n          .toString()}]`;\n      }\n      error.isTerminal = true;\n\n      // @NOTE: Don't reject to throw error for dependencies, use onStateChange\n      // const taskPromise = this.inProgress.get(category);\n      this.inProgress.delete(category);\n      // taskPromise?.reject(error);\n      this.sendEvent(error, category);\n\n      this.reset();\n\n      if (changeState) {\n        this.onStateChange(TransportState.Failed, error);\n      } else {\n        throw error;\n      }\n\n      return;\n    }\n\n    if (changeState) {\n      this.onStateChange(TransportState.Reconnecting, error);\n    }\n\n    const delay = this.getDelayForRetryCount(category, failedRetryCount);\n\n    HMSLogger.i(\n      this.TAG,\n      `schedule: [${TFC[category]}] [failedRetryCount=${failedRetryCount}] Scheduling retry task in ${delay}ms`,\n    );\n\n    let taskSucceeded: boolean;\n    try {\n      taskSucceeded = await this.setTimeoutPromise(task, delay);\n    } catch (ex) {\n      taskSucceeded = false;\n      HMSLogger.w(\n        this.TAG,\n        `[${TFC[category]}] Un-caught exception ${(ex as HMSException).name} in retry-task, initiating retry`,\n        ex,\n      );\n    }\n\n    if (taskSucceeded) {\n      const taskPromise = this.inProgress.get(category);\n      this.inProgress.delete(category);\n      taskPromise?.resolve(failedRetryCount);\n\n      if (changeState && this.inProgress.size === 0) {\n        this.onStateChange(originalState);\n      }\n      HMSLogger.i(this.TAG, `schedule: [${TFC[category]}] [failedRetryCount=${failedRetryCount}] Recovered \u267B\uFE0F`);\n    } else {\n      await this.scheduleTask({\n        category,\n        error,\n        changeState,\n        task,\n        originalState,\n        maxFailedRetries,\n        failedRetryCount: failedRetryCount + 1,\n      });\n    }\n  }\n\n  private getBaseDelayForTask(category: TFC, n: number) {\n    if (category === TFC.JoinWSMessageFailed) {\n      // linear backoff(2 + jitter for every retry)\n      return 2;\n    }\n    // exponential backoff\n    return Math.pow(2, n);\n  }\n\n  private getDelayForRetryCount(category: TFC, n: number) {\n    const delay = this.getBaseDelayForTask(category, n);\n    const jitter = category === TFC.JoinWSMessageFailed ? Math.random() * 2 : Math.random();\n    return Math.round(Math.min(delay + jitter, MAX_TRANSPORT_RETRY_DELAY) * 1000);\n  }\n\n  private async setTimeoutPromise<T>(task: () => Promise<T>, delay: number): Promise<T> {\n    return new Promise((resolve, reject) => {\n      const timeoutId = window.setTimeout(async () => {\n        try {\n          const value: T = await task();\n          value && this.retryTaskIds.splice(this.retryTaskIds.indexOf(timeoutId), 1);\n          resolve(value);\n        } catch (error) {\n          reject(error);\n        }\n      }, delay);\n\n      this.retryTaskIds.push(timeoutId);\n    });\n  }\n}\n", "import { ANALYTICS_BUFFER_SIZE } from '../../utils/constants';\nimport { LocalStorage } from '../../utils/local-storage';\nimport { Queue } from '../../utils/queue';\nimport AnalyticsEvent from '../AnalyticsEvent';\n\nexport class LocalStorageEvents extends Queue<AnalyticsEvent> {\n  private localStorage = new LocalStorage<AnalyticsEvent[]>('hms-analytics');\n\n  constructor() {\n    super(ANALYTICS_BUFFER_SIZE);\n    // @TODO: Currently we don't send failed events of old sessions. So reset localstorage for every session.\n    // Once support for failed events from old sessions is added, remove clear and init queue from localstorage.\n    this.localStorage.clear();\n    this.initLocalStorageQueue();\n  }\n\n  enqueue(event: AnalyticsEvent) {\n    super.enqueue(event);\n    this.localStorage.set(this.storage);\n  }\n\n  dequeue() {\n    const removedEvent = super.dequeue();\n    this.localStorage.set(this.storage);\n    return removedEvent;\n  }\n\n  private initLocalStorageQueue() {\n    this.localStorage.get()?.forEach(event => {\n      const eventInstance = new AnalyticsEvent(event);\n      super.enqueue(eventInstance);\n    });\n  }\n}\n", "import AnalyticsEvent from './AnalyticsEvent';\nimport { HTTPAnalyticsTransport } from './HTTPAnalyticsTransport';\nimport { IAnalyticsTransportProvider } from './IAnalyticsTransportProvider';\nimport HMSLogger from '../utils/logger';\nimport { Queue } from '../utils/queue';\n\nexport abstract class AnalyticsTransport {\n  abstract transportProvider: IAnalyticsTransportProvider;\n  abstract failedEvents: Queue<AnalyticsEvent>;\n  private readonly TAG = '[AnalyticsTransport]';\n\n  sendEvent(event: AnalyticsEvent) {\n    try {\n      this.sendSingleEvent(event);\n      this.flushFailedEvents();\n    } catch (error) {\n      HMSLogger.w(this.TAG, 'sendEvent failed', error);\n    }\n  }\n\n  flushFailedEvents(currentPeerId?: string) {\n    try {\n      HMSLogger.d(this.TAG, 'Flushing failed events', this.failedEvents);\n      while (this.failedEvents.size() > 0) {\n        const event = this.failedEvents.dequeue();\n        if (event) {\n          const isEventFromCurrentPeer = event.metadata?.peer.peer_id === currentPeerId;\n          if (isEventFromCurrentPeer || !event.metadata.peer.peer_id) {\n            this.sendSingleEvent(event);\n          } else {\n            HTTPAnalyticsTransport.sendEvent(event);\n          }\n        }\n      }\n    } catch (error) {\n      HMSLogger.w(this.TAG, 'flushFailedEvents failed', error);\n    }\n  }\n\n  private sendSingleEvent(event: AnalyticsEvent) {\n    try {\n      this.transportProvider.sendEvent(event);\n      HMSLogger.d(this.TAG, 'Sent event', event.name, event);\n    } catch (error) {\n      HMSLogger.w(this.TAG, `${this.transportProvider.TAG}.sendEvent failed, adding to local storage events`, {\n        event,\n        error,\n      });\n      this.failedEvents.enqueue(event);\n      throw error;\n    }\n  }\n}\n", "import { LocalStorageEvents } from './LocalStoageEvents';\nimport { ISignal } from '../../signal/ISignal';\nimport { AnalyticsTransport } from '../AnalyticsTransport';\n\nexport class SignalAnalyticsTransport extends AnalyticsTransport {\n  failedEvents = new LocalStorageEvents();\n\n  constructor(public transportProvider: ISignal) {\n    super();\n  }\n}\n", "// Sent in trickle messages as target - biz understands only 0 and 1\nexport enum HMSConnectionRole {\n  Publish = 0,\n  Subscribe = 1,\n}\n\nexport interface HMSTrickle {\n  candidate: RTCIceCandidateInit;\n  target: HMSConnectionRole;\n}\n", "import * as sdpTransform from 'sdp-transform';\nimport { isPresent } from './validations';\nimport { TrackState } from '../notification-manager';\n\n/**\n * @DISCUSS: Should we have a wrapper over RTCSessionDescriptionInit(SDP) and have these methods in it?\n */\n\nexport function fixMsid(desc: RTCSessionDescriptionInit, tracks?: Map<string, TrackState>): RTCSessionDescriptionInit {\n  const parsedSdp = sdpTransform.parse(desc.sdp!);\n\n  if (!parsedSdp.origin?.username.startsWith('mozilla')) {\n    // This isn't firefox, so we return the original offer without doing anything\n    return desc;\n  }\n\n  const mediaTracks = tracks ? Array.from(tracks.values()) : [];\n\n  parsedSdp.media.forEach(m => {\n    const streamId = m.msid?.split(' ')[0];\n    // check for both type and streamid as both video and screenshare have same type but different stream_id\n    const trackId = mediaTracks.find(val => val.type === m.type && val.stream_id === streamId)?.track_id;\n    if (trackId) {\n      m.msid = m.msid?.replace(/\\s(.+)/, ` ${trackId}`);\n    }\n  });\n\n  return { type: desc.type, sdp: sdpTransform.write(parsedSdp) };\n}\n\n/**\n * Get the track ID from the SDP using the transceiver's mid from RTCTrackEvent\n * @TODO: This could take more processing time in a large room and when the SDP is big.\n * Consider using this for Firefox only?\n */\nexport function getSdpTrackIdForMid(\n  desc?: RTCSessionDescriptionInit | null,\n  mid?: RTCRtpTransceiver['mid'],\n): string | undefined {\n  if (!desc?.sdp || !mid) {\n    return undefined;\n  }\n  const parsedSdp = sdpTransform.parse(desc.sdp);\n  const trackSection = parsedSdp.media.find(media => isPresent(media.mid) && parseInt(media.mid!) === parseInt(mid));\n  const trackId = trackSection?.msid?.split(' ')[1];\n  return trackId;\n}\n\nexport function enableOpusDtx(desc: RTCSessionDescriptionInit): RTCSessionDescriptionInit {\n  if (desc.sdp!.includes('usedtx=1')) {\n    return desc;\n  }\n\n  return { type: desc.type, sdp: desc.sdp!.replace('useinbandfec=1', 'useinbandfec=1;usedtx=1') };\n}\n", "import HMSLogger from './logger';\nimport { ErrorFactory } from '../error/ErrorFactory';\n\nconst TAG = `[VALIDATIONS]`;\n\n/**\n * Check only for presence(not truthy) of a value.\n * Use in places where 0, false need to be considered valid.\n */\nexport function isPresent(value: any) {\n  return value !== undefined && value !== null;\n}\n\n/**\n * checks if RTCPeerConnection constructor is available\n */\nexport const validateRTCPeerConnection = () => {\n  if (!isPresent(RTCPeerConnection)) {\n    const error = ErrorFactory.GenericErrors.MissingRTCPeerConnection();\n    HMSLogger.e(TAG, error);\n    throw error;\n  }\n};\n\n/**\n * navigator.mediaDevices is undefined in insecure contexts served over HTTP protocol\n */\nexport const validateMediaDevicesExistence = () => {\n  if (!isPresent(navigator.mediaDevices)) {\n    const error = ErrorFactory.GenericErrors.MissingMediaDevices();\n    HMSLogger.e(TAG, error);\n    throw error;\n  }\n};\n", "import { HMSConnectionRole } from './model';\nimport { ErrorFactory, HMSAction } from '../error/ErrorFactory';\nimport { HMSLocalTrack, HMSLocalVideoTrack } from '../media/tracks';\nimport { TrackState } from '../notification-manager';\nimport { ISignal } from '../signal/ISignal';\nimport HMSLogger from '../utils/logger';\nimport { enableOpusDtx, fixMsid } from '../utils/session-description';\n\nconst TAG = '[HMSConnection]';\ninterface RTCIceCandidatePair {\n  local: RTCIceCandidate;\n  remote: RTCIceCandidate;\n}\n\nexport default abstract class HMSConnection {\n  readonly role: HMSConnectionRole;\n  protected readonly signal: ISignal;\n\n  abstract readonly nativeConnection: RTCPeerConnection;\n  /**\n   * We keep a list of pending IceCandidates received\n   * from the signalling server. When the peer-connection\n   * is initialized we call [addIceCandidate] for each.\n   *\n   * WARN:\n   *  - [HMSPublishConnection] keeps the complete list of candidates (for\n   *      ice-connection failed/disconnect) forever.\n   *  - [HMSSubscribeConnection] clears this list as soon as we call [addIceCandidate]\n   */\n  readonly candidates = new Array<RTCIceCandidateInit>();\n\n  selectedCandidatePair?: RTCIceCandidatePair;\n\n  protected constructor(role: HMSConnectionRole, signal: ISignal) {\n    this.role = role;\n    this.signal = signal;\n  }\n\n  public get iceConnectionState(): RTCIceConnectionState {\n    return this.nativeConnection.iceConnectionState;\n  }\n\n  public get connectionState(): RTCPeerConnectionState {\n    return this.nativeConnection.connectionState;\n  }\n\n  private get action(): HMSAction {\n    return this.role === HMSConnectionRole.Publish ? HMSAction.PUBLISH : HMSAction.SUBSCRIBE;\n  }\n\n  addTransceiver(track: MediaStreamTrack, init: RTCRtpTransceiverInit): RTCRtpTransceiver {\n    return this.nativeConnection.addTransceiver(track, init);\n  }\n\n  async createOffer(tracks?: Map<string, TrackState>, options?: RTCOfferOptions): Promise<RTCSessionDescriptionInit> {\n    try {\n      const offer = await this.nativeConnection.createOffer(options);\n      HMSLogger.d(TAG, `[role=${this.role}] createOffer offer=${JSON.stringify(offer, null, 1)}`);\n      return enableOpusDtx(fixMsid(offer, tracks));\n    } catch (error) {\n      throw ErrorFactory.WebrtcErrors.CreateOfferFailed(this.action, (error as Error).message);\n    }\n  }\n\n  async createAnswer(options: RTCOfferOptions | undefined = undefined): Promise<RTCSessionDescriptionInit> {\n    try {\n      const answer = await this.nativeConnection.createAnswer(options);\n      HMSLogger.d(TAG, `[role=${this.role}] createAnswer answer=${JSON.stringify(answer, null, 1)}`);\n      return answer;\n    } catch (error) {\n      throw ErrorFactory.WebrtcErrors.CreateAnswerFailed(this.action, (error as Error).message);\n    }\n  }\n\n  async setLocalDescription(description: RTCSessionDescriptionInit): Promise<void> {\n    try {\n      HMSLogger.d(TAG, `[role=${this.role}] setLocalDescription description=${JSON.stringify(description, null, 1)}`);\n      await this.nativeConnection.setLocalDescription(description);\n    } catch (error) {\n      throw ErrorFactory.WebrtcErrors.SetLocalDescriptionFailed(this.action, (error as Error).message);\n    }\n  }\n\n  async setRemoteDescription(description: RTCSessionDescriptionInit): Promise<void> {\n    try {\n      HMSLogger.d(TAG, `[role=${this.role}] setRemoteDescription description=${JSON.stringify(description, null, 1)}`);\n      await this.nativeConnection.setRemoteDescription(description);\n    } catch (error) {\n      throw ErrorFactory.WebrtcErrors.SetRemoteDescriptionFailed(this.action, (error as Error).message);\n    }\n  }\n\n  async addIceCandidate(candidate: RTCIceCandidateInit): Promise<void> {\n    HMSLogger.d(TAG, `[role=${this.role}] addIceCandidate candidate=${JSON.stringify(candidate, null, 1)}`);\n    await this.nativeConnection.addIceCandidate(candidate);\n  }\n\n  public get remoteDescription(): RTCSessionDescription | null {\n    return this.nativeConnection.remoteDescription;\n  }\n\n  getSenders(): Array<RTCRtpSender> {\n    return this.nativeConnection.getSenders();\n  }\n\n  logSelectedIceCandidatePairs() {\n    /**\n     * for the very first peer in the room we don't have any subscribe ice candidates\n     * because the peer hasn't subscribed to anything.\n     *\n     * For all peers joining after this peer, we have published and subscribed at the time of join itself\n     * so we're able to log both publish and subscribe ice candidates.\n     * Added try catch for the whole section as the getSenders and getReceivers is throwing errors in load test\n     */\n    try {\n      const transmitters = this.role === HMSConnectionRole.Publish ? this.getSenders() : this.getReceivers();\n\n      transmitters.forEach(transmitter => {\n        const kindOfTrack = transmitter.track?.kind;\n        if (transmitter.transport) {\n          const iceTransport = transmitter.transport.iceTransport;\n\n          const logSelectedCandidate = () => {\n            // @ts-expect-error\n            if (typeof iceTransport.getSelectedCandidatePair === 'function') {\n              // @ts-expect-error\n              this.selectedCandidatePair = iceTransport.getSelectedCandidatePair();\n              HMSLogger.d(\n                TAG,\n                `${HMSConnectionRole[this.role]} connection`,\n                `selected ${kindOfTrack || 'unknown'} candidate pair`,\n                JSON.stringify(this.selectedCandidatePair, null, 2),\n              );\n            }\n          };\n\n          // @ts-expect-error\n          if (typeof iceTransport.onselectedcandidatepairchange === 'function') {\n            // @ts-expect-error\n            iceTransport.onselectedcandidatepairchange = logSelectedCandidate;\n          }\n          logSelectedCandidate();\n        }\n      });\n    } catch (error) {\n      HMSLogger.w(\n        TAG,\n        `Error in logging selected ice candidate pair for ${HMSConnectionRole[this.role]} connection`,\n        error,\n      );\n    }\n  }\n\n  removeTrack(sender: RTCRtpSender) {\n    if (this.nativeConnection.signalingState !== 'closed') {\n      this.nativeConnection.removeTrack(sender);\n    }\n  }\n\n  async setMaxBitrateAndFramerate(track: HMSLocalTrack) {\n    const maxBitrate = track.settings.maxBitrate;\n    const maxFramerate = track instanceof HMSLocalVideoTrack && track.settings.maxFramerate;\n    const sender = this.getSenders().find(s => s?.track?.id === track.getTrackIDBeingSent());\n\n    if (sender) {\n      const params = sender.getParameters();\n      if (params.encodings.length > 0) {\n        if (maxBitrate) {\n          params.encodings[0].maxBitrate = maxBitrate * 1000;\n        }\n        if (maxFramerate) {\n          // @ts-ignore\n          params.encodings[0].maxFramerate = maxFramerate;\n        }\n      }\n      await sender.setParameters(params);\n    } else {\n      HMSLogger.w(\n        TAG,\n        `no sender found to setMaxBitrate for track - ${track.trackId}, sentTrackId - ${track.getTrackIDBeingSent()}`,\n      );\n    }\n  }\n\n  async getStats() {\n    return await this.nativeConnection.getStats();\n  }\n\n  async close() {\n    this.nativeConnection.close();\n  }\n\n  private getReceivers() {\n    return this.nativeConnection.getReceivers();\n  }\n}\n", "import { IPublishConnectionObserver } from './IPublishConnectionObserver';\nimport { HMSLocalTrack } from '../../media/tracks';\nimport { ISignal } from '../../signal/ISignal';\nimport HMSTransport from '../../transport';\nimport { API_DATA_CHANNEL } from '../../utils/constants';\nimport HMSLogger from '../../utils/logger';\nimport HMSConnection from '../HMSConnection';\nimport { HMSConnectionRole } from '../model';\n\nexport default class HMSPublishConnection extends HMSConnection {\n  private readonly TAG = '[HMSPublishConnection]';\n  private readonly observer: IPublishConnectionObserver;\n  readonly nativeConnection: RTCPeerConnection;\n  private readonly transport: HMSTransport;\n\n  constructor(\n    signal: ISignal,\n    config: RTCConfiguration,\n    observer: IPublishConnectionObserver,\n    transport: HMSTransport,\n  ) {\n    super(HMSConnectionRole.Publish, signal);\n    this.observer = observer;\n    this.transport = transport;\n\n    this.nativeConnection = new RTCPeerConnection(config);\n    this.nativeConnection.createDataChannel(API_DATA_CHANNEL, {\n      protocol: 'SCTP',\n    });\n\n    this.nativeConnection.onicecandidate = ({ candidate }) => {\n      if (candidate) {\n        signal.trickle(this.role, candidate);\n      }\n    };\n\n    this.nativeConnection.oniceconnectionstatechange = () => {\n      this.observer.onIceConnectionChange(this.nativeConnection.iceConnectionState);\n    };\n\n    // @TODO(eswar): Remove this. Use iceconnectionstate change with interval and threshold.\n    this.nativeConnection.onconnectionstatechange = () => {\n      this.observer.onConnectionStateChange(this.nativeConnection.connectionState);\n    };\n  }\n\n  initAfterJoin() {\n    this.nativeConnection.onnegotiationneeded = async () => {\n      HMSLogger.d(this.TAG, `onnegotiationneeded`);\n      await this.observer.onRenegotiationNeeded();\n    };\n  }\n\n  trackUpdate(track: HMSLocalTrack) {\n    this.transport.trackUpdate(track);\n  }\n}\n", "import EventEmitter from 'eventemitter2';\nimport { v4 as uuid } from 'uuid';\nimport ISubscribeConnectionObserver from './ISubscribeConnectionObserver';\nimport HMSRemoteStream from '../../media/streams/HMSRemoteStream';\nimport { HMSRemoteAudioTrack } from '../../media/tracks/HMSRemoteAudioTrack';\nimport { HMSRemoteVideoTrack } from '../../media/tracks/HMSRemoteVideoTrack';\nimport { ISignal } from '../../signal/ISignal';\nimport { API_DATA_CHANNEL } from '../../utils/constants';\nimport HMSLogger from '../../utils/logger';\nimport { getSdpTrackIdForMid } from '../../utils/session-description';\nimport { sleep } from '../../utils/timer-utils';\nimport { PreferAudioLayerParams, PreferLayerResponse, PreferVideoLayerParams } from '../channel-messages';\nimport HMSConnection from '../HMSConnection';\nimport HMSDataChannel from '../HMSDataChannel';\nimport { HMSConnectionRole } from '../model';\n\nexport default class HMSSubscribeConnection extends HMSConnection {\n  private readonly TAG = '[HMSSubscribeConnection]';\n  private readonly remoteStreams = new Map<string, HMSRemoteStream>();\n\n  private readonly observer: ISubscribeConnectionObserver;\n  private readonly MAX_RETRIES = 3;\n\n  readonly nativeConnection: RTCPeerConnection;\n\n  private pendingMessageQueue: string[] = [];\n\n  private apiChannel?: HMSDataChannel;\n  private eventEmitter = new EventEmitter({ maxListeners: 15 });\n\n  private initNativeConnectionCallbacks() {\n    this.nativeConnection.oniceconnectionstatechange = () => {\n      this.observer.onIceConnectionChange(this.nativeConnection.iceConnectionState);\n    };\n\n    // @TODO(eswar): Remove this. Use iceconnectionstate change with interval and threshold.\n    this.nativeConnection.onconnectionstatechange = () => {\n      this.observer.onConnectionStateChange(this.nativeConnection.connectionState);\n    };\n\n    this.nativeConnection.ondatachannel = e => {\n      if (e.channel.label !== API_DATA_CHANNEL) {\n        // TODO: this.observer.onDataChannel(e.channel);\n        return;\n      }\n\n      this.apiChannel = new HMSDataChannel(\n        e.channel,\n        {\n          onMessage: (value: string) => {\n            this.eventEmitter.emit('message', value);\n            this.observer.onApiChannelMessage(value);\n          },\n        },\n        `role=${this.role}`,\n      );\n\n      e.channel.onopen = this.handlePendingApiMessages;\n    };\n\n    this.nativeConnection.onicecandidate = e => {\n      if (e.candidate !== null) {\n        this.signal.trickle(this.role, e.candidate);\n      }\n    };\n\n    this.nativeConnection.ontrack = e => {\n      const stream = e.streams[0];\n      const streamId = stream.id;\n      if (!this.remoteStreams.has(streamId)) {\n        const remote = new HMSRemoteStream(stream, this);\n        this.remoteStreams.set(streamId, remote);\n\n        stream.onremovetrack = e => {\n          /*\n           * this match has to be with nativetrack.id instead of track.trackId as the latter refers to sdp track id for\n           * ease of correlating update messages coming from the backend. The two track ids are usually the same, but\n           * can be different for some browsers. checkout sdptrackid field in HMSTrack for more details.\n           */\n          const toRemoveTrackIdx = remote.tracks.findIndex(track => track.nativeTrack.id === e.track.id);\n          if (toRemoveTrackIdx >= 0) {\n            const toRemoveTrack = remote.tracks[toRemoveTrackIdx];\n            this.observer.onTrackRemove(toRemoveTrack);\n            remote.tracks.splice(toRemoveTrackIdx, 1);\n\n            // If the length becomes 0 we assume that stream is removed entirely\n            if (remote.tracks.length === 0) {\n              this.remoteStreams.delete(streamId);\n            }\n          }\n        };\n      }\n\n      const remote = this.remoteStreams.get(streamId)!;\n      const TrackCls = e.track.kind === 'audio' ? HMSRemoteAudioTrack : HMSRemoteVideoTrack;\n      const track = new TrackCls(remote, e.track);\n      const trackId = getSdpTrackIdForMid(this.remoteDescription, e.transceiver?.mid);\n      trackId && track.setSdpTrackId(trackId);\n      remote.tracks.push(track);\n      this.observer.onTrackAdd(track);\n    };\n  }\n\n  constructor(signal: ISignal, config: RTCConfiguration, observer: ISubscribeConnectionObserver) {\n    super(HMSConnectionRole.Subscribe, signal);\n    this.observer = observer;\n\n    this.nativeConnection = new RTCPeerConnection(config);\n    this.initNativeConnectionCallbacks();\n  }\n\n  sendOverApiDataChannel(message: string) {\n    if (this.apiChannel && this.apiChannel.readyState === 'open') {\n      this.apiChannel.send(message);\n    } else {\n      HMSLogger.w(this.TAG, `API Data channel not ${this.apiChannel ? 'open' : 'present'}, queueing`, message);\n      this.pendingMessageQueue.push(message);\n    }\n  }\n\n  async sendOverApiDataChannelWithResponse<T extends PreferAudioLayerParams | PreferVideoLayerParams>(\n    message: T,\n    requestId?: string,\n  ): Promise<PreferLayerResponse> {\n    const id = uuid();\n    const request = JSON.stringify({\n      id: requestId || id,\n      jsonrpc: '2.0',\n      ...message,\n    });\n    return this.sendMessage(request, id);\n  }\n\n  async close() {\n    await super.close();\n    this.apiChannel?.close();\n  }\n\n  private handlePendingApiMessages = () => {\n    this.eventEmitter.emit('open', true);\n    if (this.pendingMessageQueue.length > 0) {\n      HMSLogger.d(this.TAG, 'Found pending message queue, sending messages');\n      this.pendingMessageQueue.forEach(msg => this.sendOverApiDataChannel(msg));\n      this.pendingMessageQueue.length = 0;\n    }\n  };\n\n  // eslint-disable-next-line complexity\n  private sendMessage = async (request: string, requestId: string): Promise<PreferLayerResponse> => {\n    if (this.apiChannel?.readyState !== 'open') {\n      await this.eventEmitter.waitFor('open');\n    }\n    let response: PreferLayerResponse;\n    for (let i = 0; i < this.MAX_RETRIES; i++) {\n      this.apiChannel!.send(request);\n      response = await this.waitForResponse(requestId);\n      const error = response.error;\n      if (error) {\n        // Don't retry or do anything, track is already removed\n        if (error.code === 404) {\n          HMSLogger.d(this.TAG, `Track not found ${requestId}`, { request, try: i + 1, error });\n          break;\n        }\n        HMSLogger.e(this.TAG, `Failed sending ${requestId}`, { request, try: i + 1, error });\n        const shouldRetry = error.code / 100 === 5 || error.code === 429;\n        if (!shouldRetry) {\n          throw Error(`code=${error.code}, message=${error.message}`);\n        }\n        const delay = (2 + Math.random() * 2) * 1000;\n        await sleep(delay);\n      } else {\n        break;\n      }\n    }\n    return response!;\n  };\n\n  private waitForResponse = async (requestId: string): Promise<PreferLayerResponse> => {\n    const res = await this.eventEmitter.waitFor('message', function (value) {\n      return value.includes(requestId);\n    });\n    const response = JSON.parse(res[0] as string);\n    HMSLogger.d(this.TAG, `response for ${requestId} -`, JSON.stringify(response, null, 2));\n    return response;\n  };\n}\n", "import HMSLogger from '../utils/logger';\n\nexport interface DataChannelObserver {\n  onMessage(value: string): void;\n}\n\nexport default class HMSDataChannel {\n  private readonly TAG = '[HMSDataChannel]';\n  private readonly nativeChannel: RTCDataChannel;\n  private readonly observer: DataChannelObserver;\n  private readonly metadata: string;\n\n  public get id() {\n    return this.nativeChannel.id;\n  }\n\n  public get label() {\n    return this.nativeChannel.label;\n  }\n\n  public get readyState() {\n    return this.nativeChannel.readyState;\n  }\n\n  constructor(nativeChannel: RTCDataChannel, observer: DataChannelObserver, metadata = '') {\n    this.nativeChannel = nativeChannel;\n    this.observer = observer;\n    this.metadata = metadata;\n\n    nativeChannel.onmessage = e => {\n      // HMSLogger.d(this.TAG, `[${this.metadata}] onMessage: label=${this.label}, message=${e.data}`);\n      this.observer.onMessage(e.data);\n    };\n  }\n\n  send(message: string) {\n    HMSLogger.d(this.TAG, `[${this.metadata}] Sending [size=${message.length}] message=${message}`);\n    this.nativeChannel.send(message);\n  }\n\n  close() {\n    this.nativeChannel.close();\n  }\n}\n", "import { HMSWebrtcStats } from './HMSWebrtcStats';\nimport {\n  HMSPeerStats,\n  HMSTrackStats,\n  MissingInboundStats,\n  PeerConnectionType,\n  RTCRemoteInboundRtpStreamStats,\n} from '../interfaces/webrtc-stats';\nimport HMSLocalStream from '../media/streams/HMSLocalStream';\nimport { HMSLocalTrack, HMSRemoteTrack } from '../media/tracks';\nimport HMSLogger from '../utils/logger';\nimport { isPresent } from '../utils/validations';\n\nexport const getLocalTrackStats = async (\n  getStats: HMSWebrtcStats['getStats'],\n  track: HMSLocalTrack,\n  peerName?: string,\n  prevTrackStats?: Record<string, HMSTrackStats>,\n): Promise<Record<string, HMSTrackStats> | undefined> => {\n  let trackReport: RTCStatsReport | undefined;\n  const trackStats: Record<string, HMSTrackStats> = {};\n  if (!(track.stream as HMSLocalStream).hasSender(track)) {\n    return;\n  }\n  try {\n    trackReport = await getStats['publish']?.(track.getTrackBeingSent());\n    const mimeTypes: { [key: string]: string } = {}; // codecId -> mimeType\n    const outbound: Record<string, RTCOutboundRtpStreamStats> = {};\n    const inbound: Record<string, RTCInboundRtpStreamStats & MissingInboundStats> = {};\n    trackReport?.forEach(stat => {\n      switch (stat.type) {\n        case 'outbound-rtp':\n          outbound[stat.id] = stat;\n          break;\n        case 'remote-inbound-rtp':\n          inbound[stat.ssrc] = stat;\n          break;\n        case 'codec':\n          mimeTypes[stat.id] = stat.mimeType;\n          break;\n        default:\n          break;\n      }\n    });\n\n    Object.keys({ ...outbound }).forEach(stat => {\n      const codecId = outbound[stat]?.codecId;\n      const mimeType = codecId ? mimeTypes[codecId] : undefined;\n      let codec: string | undefined;\n      if (mimeType) {\n        codec = mimeType.substring(mimeType.indexOf('/') + 1);\n      }\n      const out = outbound[stat];\n      const inStats = inbound[out.ssrc];\n      trackStats[stat] = {\n        ...out,\n        bitrate: computeBitrate('bytesSent', out, prevTrackStats?.[stat]),\n        packetsLost: inStats?.packetsLost,\n        jitter: inStats?.jitter,\n        roundTripTime: inStats?.roundTripTime,\n        totalRoundTripTime: inStats?.totalRoundTripTime,\n        peerName,\n        peerID: track.peerId,\n        codec,\n      };\n    });\n  } catch (err) {\n    HMSLogger.w('[HMSWebrtcStats]', 'Error in getting local track stats', track, err, (err as Error).name);\n  }\n  return trackStats;\n};\n\nexport const getTrackStats = async (\n  getStats: HMSWebrtcStats['getStats'],\n  track: HMSRemoteTrack,\n  peerName?: string,\n  prevTrackStats?: HMSTrackStats,\n): Promise<HMSTrackStats | undefined> => {\n  let trackReport: RTCStatsReport | undefined;\n  try {\n    trackReport = await getStats['subscribe']?.(track.nativeTrack);\n  } catch (err) {\n    HMSLogger.w('[HMSWebrtcStats]', 'Error in getting remote track stats', track, err);\n  }\n  const trackStats = getRelevantStatsFromTrackReport(trackReport);\n\n  const bitrate = computeBitrate('bytesReceived', trackStats, prevTrackStats);\n\n  const packetsLostRate = computeStatRate('packetsLost', trackStats, prevTrackStats);\n\n  if (trackStats?.remote) {\n    Object.assign(trackStats.remote, {\n      packetsLostRate: computeStatRate('packetsLost', trackStats.remote, prevTrackStats?.remote),\n    });\n  }\n\n  return (\n    trackStats &&\n    Object.assign(trackStats, {\n      bitrate,\n      packetsLostRate,\n      peerId: track.peerId,\n      peerName,\n      codec: trackStats.codec,\n    })\n  );\n};\n\nconst getRelevantStatsFromTrackReport = (trackReport?: RTCStatsReport) => {\n  let streamStats: RTCInboundRtpStreamStats | RTCOutboundRtpStreamStats | undefined;\n  // Valid by Webrtc spec, not in TS\n  // let remoteStreamStats: RTCRemoteInboundRtpStreamStats | RTCRemoteOutboundRtpStreamStats;\n  let remoteStreamStats: RTCRemoteInboundRtpStreamStats | undefined;\n\n  const mimeTypes: { [key: string]: string } = {}; // codecId -> mimeType\n  trackReport?.forEach(stat => {\n    switch (stat.type) {\n      case 'inbound-rtp':\n        streamStats = stat;\n        break;\n      case 'outbound-rtp':\n        streamStats = stat;\n        break;\n      case 'remote-inbound-rtp':\n        remoteStreamStats = stat;\n        break;\n      case 'codec':\n        mimeTypes[stat.id] = stat.mimeType;\n        break;\n      default:\n        break;\n    }\n  });\n\n  const mimeType = streamStats?.codecId ? mimeTypes[streamStats.codecId] : undefined;\n  let codec: string | undefined;\n  if (mimeType) {\n    codec = mimeType.substring(mimeType.indexOf('/') + 1);\n  }\n\n  return (\n    streamStats &&\n    Object.assign(streamStats, {\n      remote: remoteStreamStats,\n      codec: codec,\n    })\n  );\n};\n\nexport const getLocalPeerStatsFromReport = (\n  type: PeerConnectionType,\n  report: RTCStatsReport,\n  prevStats?: HMSPeerStats,\n): (RTCIceCandidatePairStats & { bitrate: number }) | undefined => {\n  const activeCandidatePair = getActiveCandidatePairFromReport(report);\n  const bitrate = computeBitrate(\n    (type === 'publish' ? 'bytesSent' : 'bytesReceived') as any,\n    activeCandidatePair,\n    prevStats && prevStats[type],\n  );\n\n  return activeCandidatePair && Object.assign(activeCandidatePair, { bitrate });\n};\n\nexport const getActiveCandidatePairFromReport = (report: RTCStatsReport): RTCIceCandidatePairStats | undefined => {\n  let activeCandidatePair: RTCIceCandidatePairStats | undefined;\n  report.forEach(stat => {\n    if (stat.type === 'transport') {\n      // TS doesn't have correct types for RTCStatsReports\n      // @ts-expect-error\n      activeCandidatePair = report.get(stat.selectedCandidatePairId);\n    }\n  });\n\n  // Fallback for Firefox.\n  if (!activeCandidatePair) {\n    report.forEach(stat => {\n      if (stat.type === 'candidate-pair' && stat.selected) {\n        activeCandidatePair = stat;\n      }\n    });\n  }\n\n  return activeCandidatePair;\n};\n\nexport const getPacketsLostAndJitterFromReport = (report?: RTCStatsReport): { packetsLost: number; jitter: number } => {\n  const result = { packetsLost: 0, jitter: 0 };\n  report?.forEach(stat => {\n    if (stat.packetsLost) {\n      result.packetsLost += stat.packetsLost;\n    }\n    if (stat.jitter > result.jitter) {\n      result.jitter = stat.jitter;\n    }\n  });\n\n  return result;\n};\n\nexport const union = <T>(arr1: T[], arr2: T[]): T[] => {\n  return Array.from(new Set(arr1.concat(arr2)));\n};\n\n/**\n * Ref: https://github.dev/peermetrics/webrtc-stats/blob/b5c1fed68325543e6f563c6d3f4450a4b51e12b7/src/utils.ts#L62\n */\nexport const computeBitrate = <T extends HMSTrackStats>(\n  statName: keyof T,\n  newReport?: Partial<T>,\n  oldReport?: Partial<T>,\n): number => computeStatRate(statName, newReport, oldReport) * 8; // Bytes to bits\n\nconst computeStatRate = <T extends HMSTrackStats>(\n  statName: keyof T,\n  newReport?: Partial<T>,\n  oldReport?: Partial<T>,\n): number => {\n  const newVal = newReport && newReport[statName];\n  const oldVal = oldReport ? oldReport[statName] : null;\n  const conditions = [newReport, oldReport, isPresent(newVal), isPresent(oldVal)];\n  if (conditions.every(condition => !!condition)) {\n    // Type not null checked in `isPresent`\n    // * 1000 - ms to s\n    return (\n      computeNumberRate(\n        newVal as unknown as number,\n        oldVal as unknown as number,\n        newReport?.timestamp,\n        oldReport?.timestamp,\n      ) * 1000\n    );\n  } else {\n    return 0;\n  }\n};\n\nexport const computeNumberRate = (newVal?: number, oldVal?: number, newTimestamp?: number, oldTimestamp?: number) => {\n  if (isPresent(newVal) && isPresent(oldVal) && newTimestamp && oldTimestamp) {\n    return ((newVal as number) - (oldVal as number)) / (newTimestamp - oldTimestamp);\n  } else {\n    return 0;\n  }\n};\n", "import {\n  computeNumberRate,\n  getLocalPeerStatsFromReport,\n  getLocalTrackStats,\n  getPacketsLostAndJitterFromReport,\n  getTrackStats,\n  union,\n} from './utils';\nimport { HMSPeerStats, HMSTrackStats, PeerConnectionType } from '../interfaces/webrtc-stats';\nimport { HMSLocalTrack, HMSRemoteTrack } from '../media/tracks';\nimport { IStore } from '../sdk/store';\nimport HMSLogger from '../utils/logger';\n\nexport class HMSWebrtcStats {\n  private readonly TAG = '[HMSWebrtcStats]';\n  private localPeerID?: string;\n  private peerStats: Record<string, HMSPeerStats> = {};\n  private remoteTrackStats: Record<string, HMSTrackStats> = {};\n  private localTrackStats: Record<string, Record<string, HMSTrackStats>> = {};\n\n  /**\n   * Removed localPeerID check in other places as it will be present before\n   * this is initialized\n   */\n  constructor(\n    private getStats: Record<PeerConnectionType, RTCPeerConnection['getStats'] | undefined>,\n    private store: IStore,\n  ) {\n    this.localPeerID = this.store.getLocalPeer()?.peerId;\n  }\n\n  getLocalPeerStats(): HMSPeerStats | undefined {\n    return this.peerStats[this.localPeerID!];\n  }\n\n  getRemoteTrackStats(trackId: string): HMSTrackStats | undefined {\n    return this.remoteTrackStats[trackId];\n  }\n\n  getLocalTrackStats() {\n    return this.localTrackStats;\n  }\n\n  /**\n   * @internal\n   */\n  async updateStats() {\n    await this.updateLocalPeerStats();\n    await this.updateLocalTrackStats();\n    await this.updateRemoteTrackStats();\n  }\n\n  private async updateLocalPeerStats() {\n    const prevLocalPeerStats = this.getLocalPeerStats();\n    let publishReport: RTCStatsReport | undefined;\n    try {\n      publishReport = await this.getStats.publish?.();\n    } catch (err) {\n      HMSLogger.w(this.TAG, 'Error in getting publish stats', err);\n    }\n    const publishStats: HMSPeerStats['publish'] | undefined =\n      publishReport && getLocalPeerStatsFromReport('publish', publishReport, prevLocalPeerStats);\n\n    let subscribeReport: RTCStatsReport | undefined;\n    try {\n      subscribeReport = await this.getStats.subscribe?.();\n    } catch (err) {\n      HMSLogger.w(this.TAG, 'Error in getting subscribe stats', err);\n    }\n    const baseSubscribeStats =\n      subscribeReport && getLocalPeerStatsFromReport('subscribe', subscribeReport, prevLocalPeerStats);\n    const { packetsLost, jitter } = getPacketsLostAndJitterFromReport(subscribeReport);\n    const packetsLostRate = computeNumberRate(\n      packetsLost,\n      prevLocalPeerStats?.subscribe?.packetsLost,\n      baseSubscribeStats?.timestamp,\n      prevLocalPeerStats?.subscribe?.timestamp,\n    );\n\n    const subscribeStats: HMSPeerStats['subscribe'] =\n      baseSubscribeStats && Object.assign(baseSubscribeStats, { packetsLostRate, jitter, packetsLost });\n\n    this.peerStats[this.localPeerID!] = { publish: publishStats, subscribe: subscribeStats };\n  }\n\n  private async updateRemoteTrackStats() {\n    const tracks = this.store.getTracksMap();\n    const trackIDs = union(Object.keys(this.remoteTrackStats), Object.keys(tracks)).filter(\n      trackId => tracks[trackId] && tracks[trackId].peerId !== this.localPeerID,\n    );\n    for (const trackID of trackIDs) {\n      const track = tracks[trackID];\n      if (track) {\n        const peerName = track.peerId && this.store.getPeerById(track.peerId)?.name;\n        const prevTrackStats = this.getRemoteTrackStats(track.trackId);\n        const trackStats = await getTrackStats(this.getStats, track as HMSRemoteTrack, peerName, prevTrackStats);\n        if (trackStats) {\n          this.remoteTrackStats[trackID] = trackStats;\n        }\n      } else {\n        delete this.remoteTrackStats[trackID];\n      }\n    }\n  }\n\n  private async updateLocalTrackStats() {\n    const tracks = this.store.getLocalPeerTracks().reduce<Record<string, HMSLocalTrack>>((res, track) => {\n      res[track.getTrackIDBeingSent()] = track;\n      return res;\n    }, {});\n    const trackIDs = union(Object.keys(this.localTrackStats), Object.keys(tracks));\n    for (const trackID of trackIDs) {\n      const track = tracks[trackID] as HMSLocalTrack;\n      if (track) {\n        const peerName = this.store.getLocalPeer()?.name;\n        const trackStats = await getLocalTrackStats(this.getStats, track, peerName, this.localTrackStats[trackID]);\n        if (trackStats) {\n          this.localTrackStats[trackID] = trackStats;\n        }\n      } else {\n        delete this.localTrackStats[trackID];\n      }\n    }\n  }\n}\n", "import { HMSWebrtcStats } from './HMSWebrtcStats';\nimport { EventBus } from '../events/EventBus';\nimport { IStore } from '../sdk/store';\nimport { RTC_STATS_MONITOR_INTERVAL } from '../utils/constants';\nimport HMSLogger from '../utils/logger';\nimport { sleep } from '../utils/timer-utils';\n\nexport class HMSWebrtcInternals {\n  private readonly TAG = '[HMSWebrtcInternals]';\n  private readonly interval = RTC_STATS_MONITOR_INTERVAL;\n  private isMonitored = false;\n  private hmsStats?: HMSWebrtcStats;\n\n  constructor(\n    private readonly store: IStore,\n    private readonly eventBus: EventBus,\n    private publishConnection?: RTCPeerConnection,\n    private subscribeConnection?: RTCPeerConnection,\n  ) {}\n\n  getPublishPeerConnection() {\n    return this.publishConnection;\n  }\n\n  getSubscribePeerConnection() {\n    return this.subscribeConnection;\n  }\n\n  getCurrentStats() {\n    return this.hmsStats;\n  }\n\n  onStatsChange(statsChangeCb: (stats: HMSWebrtcStats) => void) {\n    this.eventBus.statsUpdate.subscribe(statsChangeCb);\n    return () => {\n      this.eventBus.statsUpdate.unsubscribe(statsChangeCb);\n    };\n  }\n\n  private handleStatsUpdate = async () => {\n    await this.hmsStats?.updateStats();\n    this.eventBus.statsUpdate.publish(this.hmsStats);\n  };\n\n  /**\n   *\n   * @internal\n   */\n  setPeerConnections({ publish, subscribe }: { publish?: RTCPeerConnection; subscribe?: RTCPeerConnection }) {\n    this.publishConnection = publish;\n    this.subscribeConnection = subscribe;\n\n    this.hmsStats = new HMSWebrtcStats(\n      {\n        publish: this.publishConnection?.getStats.bind(this.publishConnection),\n        subscribe: this.subscribeConnection?.getStats.bind(this.subscribeConnection),\n      },\n      this.store,\n    );\n  }\n\n  /**\n   * @internal\n   */\n  async start() {\n    if (this.isMonitored) {\n      HMSLogger.d(this.TAG, 'Already started');\n      return;\n    }\n    this.stop();\n    this.isMonitored = true;\n    HMSLogger.d(this.TAG, 'Starting Webrtc Stats Monitor');\n    this.startLoop()\n      .then(() => HMSLogger.d(this.TAG, 'Stopping Webrtc Stats Monitor'))\n      .catch(e => HMSLogger.e(this.TAG, e.message));\n  }\n\n  private stop() {\n    this.isMonitored = false;\n  }\n\n  private async startLoop() {\n    while (this.isMonitored) {\n      await this.handleStatsUpdate();\n      await sleep(this.interval);\n    }\n  }\n\n  /**\n   * @internal\n   */\n  cleanUp() {\n    this.stop();\n    this.eventBus.statsUpdate.removeAllListeners();\n  }\n}\n", "import { InitConfig } from './models';\nimport { ErrorFactory, HMSAction } from '../../error/ErrorFactory';\nimport HMSLogger from '../../utils/logger';\n\nconst TAG = '[InitService]';\nexport default class InitService {\n  private static handleError(response: Response, body: { code: number; message: string }) {\n    switch (response.status) {\n      case 404:\n        throw ErrorFactory.InitAPIErrors.EndpointUnreachable(HMSAction.INIT, body.message || response.statusText);\n      case 200:\n        break;\n      default:\n        throw ErrorFactory.InitAPIErrors.ServerErrors(\n          body.code || response.status,\n          HMSAction.INIT,\n          body.message || response?.statusText,\n        );\n    }\n  }\n\n  static async fetchInitConfig({\n    token,\n    peerId,\n    userAgent,\n    initEndpoint = 'https://prod-init.100ms.live',\n    region = '',\n  }: {\n    token: string;\n    peerId: string;\n    userAgent: string;\n    initEndpoint?: string;\n    region?: string;\n  }): Promise<InitConfig> {\n    HMSLogger.d(TAG, `fetchInitConfig: initEndpoint=${initEndpoint} token=${token} peerId=${peerId} region=${region} `);\n    const url = getUrl(initEndpoint, peerId, userAgent, region);\n    try {\n      const response = await fetch(url, {\n        headers: {\n          Authorization: `Bearer ${token}`,\n        },\n      });\n      const config = await response.json();\n      this.handleError(response, config);\n      HMSLogger.d(TAG, `config is ${JSON.stringify(config, null, 2)}`);\n      return transformInitConfig(config);\n    } catch (err) {\n      const error = err as Error;\n      if (['Failed to fetch', 'NetworkError'].some(message => error.message.includes(message))) {\n        throw ErrorFactory.InitAPIErrors.EndpointUnreachable(HMSAction.INIT, error.message);\n      }\n      throw error;\n    }\n  }\n}\n\nexport function getUrl(endpoint: string, peerId: string, userAgent: string, region?: string) {\n  try {\n    const url = new URL('/init', endpoint);\n\n    if (region && region.trim().length > 0) {\n      url.searchParams.set('region', region.trim());\n    }\n    url.searchParams.set('peer_id', peerId);\n    url.searchParams.set('user_agent_v2', userAgent);\n    return url.toString();\n  } catch (err) {\n    const error = err as Error;\n    HMSLogger.e(TAG, error.name, error.message);\n    throw error;\n  }\n}\n\nexport function transformInitConfig(config: any): InitConfig {\n  return {\n    ...config,\n    rtcConfiguration: { ...config.rtcConfiguration, iceServers: config.rtcConfiguration?.ice_servers },\n  };\n}\n", "/**\n * Thresholds for the network quality scores in kbps.\n * ex: { 1: { low: 300, high: 400 }}\n */\nexport type ScoreMap = Record<\n  number,\n  {\n    low: number;\n    high?: number;\n  }\n>;\n\n/**\n * Informantion necessary to test network quality. it provides a url to be\n * downloaded and timeout for the url download. And also the scores to be\n * assigned based on the downloaded data and time.\n */\nexport interface NetworkHealth {\n  url: string;\n  timeout: number;\n  scoreMap: ScoreMap;\n}\nexport interface InitConfig {\n  readonly endpoint: string;\n  readonly log_level: string;\n  readonly policy: string;\n  readonly rtcConfiguration: RTCConfiguration;\n  readonly pingTimeout?: number;\n  readonly config: {\n    readonly enabledFlags?: Array<InitFlags>;\n    readonly networkHealth: NetworkHealth;\n  };\n}\n\nexport enum InitFlags {\n  FLAG_SERVER_SUB_DEGRADATION = 'subscribeDegradation',\n  FLAG_SERVER_SIMULCAST = 'simulcast',\n  FLAG_NON_WEBRTC_DISABLE_OFFER = 'nonWebRTCDisableOffer',\n}\n", "import { v4 as uuid } from 'uuid';\nimport { convertSignalMethodtoErrorAction, HMSSignalMethod, JsonRpcRequest, JsonRpcResponse } from './models';\nimport AnalyticsEvent from '../../analytics/AnalyticsEvent';\nimport { HMSConnectionRole, HMSTrickle } from '../../connection/model';\nimport { ErrorFactory, HMSAction } from '../../error/ErrorFactory';\nimport { HMSException } from '../../error/HMSException';\nimport Message from '../../sdk/models/HMSMessage';\nimport {\n  DEFAULT_SIGNAL_PING_INTERVAL,\n  DEFAULT_SIGNAL_PING_TIMEOUT,\n  PONG_RESPONSE_TIMES_SIZE,\n} from '../../utils/constants';\nimport HMSLogger from '../../utils/logger';\nimport { PromiseCallbacks } from '../../utils/promise';\nimport { Queue } from '../../utils/queue';\nimport { isPageHidden } from '../../utils/support';\nimport { sleep } from '../../utils/timer-utils';\nimport {\n  AcceptRoleChangeParams,\n  BroadcastResponse,\n  GetSessionMetadataResponse,\n  HLSRequestParams,\n  HLSTimedMetadataParams,\n  MultiTrackUpdateRequestParams,\n  RemovePeerRequest,\n  RequestForBulkRoleChangeParams,\n  RequestForRoleChangeParams,\n  SessionMetadataUpdateParams,\n  StartRTMPOrRecordingRequestParams,\n  Track,\n  TrackUpdateRequestParams,\n  UpdatePeerRequestParams,\n} from '../interfaces';\nimport { ISignal } from '../ISignal';\nimport { ISignalEventsObserver } from '../ISignalEventsObserver';\n\nexport default class JsonRpcSignal implements ISignal {\n  readonly TAG = '[SIGNAL]: ';\n  readonly observer: ISignalEventsObserver;\n  readonly pongResponseTimes = new Queue<number>(PONG_RESPONSE_TIMES_SIZE);\n\n  /**\n   * Sometimes before [join] is completed, there could be a lot of trickles\n   * Sending [HMSTrickle]` before [join] web socket message leads to\n   * error: [500] no rtc transport exists for this Peer\n   *\n   * We keep a list of pending trickles and send them immediately after [join]\n   * is done.\n   */\n  private isJoinCompleted = false;\n  private pendingTrickle: Array<HMSTrickle> = [];\n\n  private socket: WebSocket | null = null;\n\n  private callbacks = new Map<string, PromiseCallbacks<string, { method: HMSSignalMethod }>>();\n\n  private _isConnected = false;\n  private id = 0;\n\n  private onCloseHandler: (event: CloseEvent) => void = () => {};\n\n  public get isConnected(): boolean {\n    return this._isConnected;\n  }\n\n  public setIsConnected(newValue: boolean, reason = '') {\n    HMSLogger.d(this.TAG, `isConnected set id: ${this.id}, oldValue: ${this._isConnected}, newValue: ${newValue}`);\n    if (this._isConnected === newValue) {\n      return;\n    }\n\n    if (this._isConnected && !newValue) {\n      // went offline\n      this._isConnected = newValue;\n      this.rejectPendingCalls(reason);\n      this.observer.onOffline(reason);\n    } else if (!this._isConnected && newValue) {\n      // went online\n      this._isConnected = newValue;\n      this.observer.onOnline();\n    }\n  }\n\n  constructor(observer: ISignalEventsObserver) {\n    this.observer = observer;\n    window.addEventListener('offline', this.offlineListener);\n    window.addEventListener('online', this.onlineListener);\n\n    this.onMessageHandler = this.onMessageHandler.bind(this);\n  }\n\n  getPongResponseTimes() {\n    return this.pongResponseTimes.toList();\n  }\n\n  private async internalCall<T>(method: string, params: any): Promise<T> {\n    const id = uuid();\n    const message = { method, params, id, jsonrpc: '2.0' } as JsonRpcRequest;\n\n    this.socket?.send(JSON.stringify(message));\n\n    try {\n      const response = await new Promise<any>((resolve, reject) => {\n        this.callbacks.set(id, { resolve, reject, metadata: { method: method as HMSSignalMethod } });\n      });\n\n      return response;\n    } catch (ex) {\n      if (ex instanceof HMSException) {\n        throw ex;\n      }\n\n      const error = ex as JsonRpcResponse['error'];\n      throw ErrorFactory.WebsocketMethodErrors.ServerErrors(\n        Number(error.code),\n        convertSignalMethodtoErrorAction(method as HMSSignalMethod),\n        error.message,\n      );\n    }\n  }\n\n  private notify(method: string, params: any) {\n    const message = { method, params };\n\n    if (this.socket?.readyState === WebSocket.OPEN) {\n      this.socket?.send(JSON.stringify(message));\n    }\n  }\n\n  open(uri: string): Promise<void> {\n    return new Promise((resolve, reject) => {\n      let promiseSettled = false;\n      // cleanup\n      if (this.socket) {\n        this.socket.close();\n        this.socket.removeEventListener('close', this.onCloseHandler);\n        this.socket.removeEventListener('message', this.onMessageHandler);\n      }\n\n      this.socket = new WebSocket(uri); // @DISCUSS: Inject WebSocket as a dependency so that it can be easier to mock and test\n\n      const errorListener = (error: Event) => {\n        /**\n         * there was an error received from websocket leading to disconnection, this can happen either if server\n         * disconnects the websocket for some reason, there is a network disconnect or a firewall/antivirus on user's\n         * device is breaking the websocket connecting(which can happen even after a successful connect).\n         */\n        HMSLogger.e(this.TAG, 'Error from websocket', error);\n        promiseSettled = true;\n        reject(\n          ErrorFactory.WebSocketConnectionErrors.FailedToConnect(\n            HMSAction.JOIN,\n            `Error opening websocket connection - ${error}`,\n          ),\n        );\n      };\n\n      this.onCloseHandler = (event: CloseEvent) => {\n        HMSLogger.e(`Websocket closed code=${event.code}`);\n        if (promiseSettled) {\n          this.setIsConnected(false, `code: ${event.code}${event.code !== 1000 ? ', unexpected websocket close' : ''}`);\n        } else {\n          promiseSettled = true;\n          reject(\n            ErrorFactory.WebSocketConnectionErrors.AbnormalClose(\n              HMSAction.JOIN,\n              `Error opening websocket connection - websocket closed unexpectedly with code=${event.code}`,\n            ),\n          );\n        }\n      };\n\n      this.socket.addEventListener('error', errorListener);\n\n      const openHandler = () => {\n        promiseSettled = true;\n        resolve();\n        this.setIsConnected(true);\n        this.id++;\n        this.socket?.removeEventListener('open', openHandler);\n        this.socket?.removeEventListener('error', errorListener);\n        this.pingPongLoop(this.id);\n      };\n\n      this.socket.addEventListener('open', openHandler);\n      this.socket.addEventListener('close', this.onCloseHandler);\n      this.socket.addEventListener('message', this.onMessageHandler);\n    });\n  }\n\n  async close(): Promise<void> {\n    window.removeEventListener('offline', this.offlineListener);\n    window.removeEventListener('online', this.onlineListener);\n\n    // For `1000` Refer: https://tools.ietf.org/html/rfc6455#section-7.4.1\n    if (this.socket) {\n      this.socket.close(1000, 'Normal Close');\n      this.setIsConnected(false, 'code: 1000, normal websocket close');\n      this.socket.removeEventListener('close', this.onCloseHandler);\n      this.socket.removeEventListener('message', this.onMessageHandler);\n    } else {\n      this.setIsConnected(false, 'websocket not connected yet');\n    }\n  }\n\n  async join(\n    name: string,\n    data: string,\n    disableVidAutoSub: boolean,\n    serverSubDegrade: boolean,\n    simulcast: boolean,\n    offer?: RTCSessionDescriptionInit,\n  ): Promise<RTCSessionDescriptionInit> {\n    if (!this.isConnected) {\n      throw ErrorFactory.WebSocketConnectionErrors.WebSocketConnectionLost(\n        HMSAction.JOIN,\n        'Failed to send join over WS connection',\n      );\n    }\n    const params = { name, disableVidAutoSub, data, offer, server_sub_degrade: serverSubDegrade, simulcast };\n    const response: RTCSessionDescriptionInit = await this.internalCall(HMSSignalMethod.JOIN, params);\n\n    this.isJoinCompleted = true;\n    this.pendingTrickle.forEach(({ target, candidate }) => this.trickle(target, candidate));\n    this.pendingTrickle.length = 0;\n\n    HMSLogger.d(this.TAG, `join: response=${JSON.stringify(response, null, 1)}`);\n    return response;\n  }\n\n  trickle(target: HMSConnectionRole, candidate: RTCIceCandidateInit) {\n    if (this.isJoinCompleted) {\n      this.notify(HMSSignalMethod.TRICKLE, { target, candidate });\n    } else {\n      this.pendingTrickle.push({ target, candidate });\n    }\n  }\n\n  async offer(desc: RTCSessionDescriptionInit, tracks: Map<string, any>): Promise<RTCSessionDescriptionInit> {\n    const response = await this.call(HMSSignalMethod.OFFER, {\n      desc,\n      tracks: Object.fromEntries(tracks),\n    });\n    return response as RTCSessionDescriptionInit;\n  }\n\n  answer(desc: RTCSessionDescriptionInit) {\n    this.notify(HMSSignalMethod.ANSWER, { desc });\n  }\n\n  trackUpdate(tracks: Map<string, Track>) {\n    this.notify(HMSSignalMethod.TRACK_UPDATE, { version: '1.0', tracks: Object.fromEntries(tracks) });\n  }\n\n  async broadcast(message: Message) {\n    return await this.call<BroadcastResponse>(HMSSignalMethod.BROADCAST, {\n      version: '1.0',\n      ...message.toSignalParams(),\n    });\n  }\n\n  leave() {\n    this.notify(HMSSignalMethod.LEAVE, { version: '1.0' });\n  }\n\n  async endRoom(lock: boolean, reason: string) {\n    await this.call(HMSSignalMethod.END_ROOM, { lock, reason });\n  }\n\n  sendEvent(event: AnalyticsEvent) {\n    if (!this.isConnected) {\n      throw Error(`${this.TAG} not connected. Could not send event ${event}`);\n    }\n    this.notify(HMSSignalMethod.ANALYTICS, event.toSignalParams());\n  }\n\n  ping(timeout: number): Promise<number> {\n    const pingTime = Date.now();\n    const timer: Promise<number> = new Promise(resolve => {\n      setTimeout(() => {\n        resolve(Date.now() - pingTime);\n      }, timeout + 1);\n    });\n    const pongTimeDiff = this.internalCall(HMSSignalMethod.PING, { timestamp: pingTime })\n      .then(() => Date.now() - pingTime)\n      .catch(() => Date.now() - pingTime);\n\n    return Promise.race([timer, pongTimeDiff]);\n  }\n\n  async requestRoleChange(params: RequestForRoleChangeParams) {\n    await this.call(HMSSignalMethod.ROLE_CHANGE_REQUEST, params);\n  }\n\n  async requestBulkRoleChange(params: RequestForBulkRoleChangeParams) {\n    await this.call(HMSSignalMethod.ROLE_CHANGE_REQUEST, params);\n  }\n\n  async acceptRoleChangeRequest(params: AcceptRoleChangeParams) {\n    await this.call(HMSSignalMethod.ROLE_CHANGE, params);\n  }\n\n  async requestTrackStateChange(params: TrackUpdateRequestParams) {\n    await this.call(HMSSignalMethod.TRACK_UPDATE_REQUEST, params);\n  }\n\n  async requestMultiTrackStateChange(params: MultiTrackUpdateRequestParams) {\n    await this.call(HMSSignalMethod.CHANGE_TRACK_MUTE_STATE_REQUEST, params);\n  }\n\n  async removePeer(params: RemovePeerRequest) {\n    await this.call(HMSSignalMethod.PEER_LEAVE_REQUEST, params);\n  }\n\n  async startRTMPOrRecording(params: StartRTMPOrRecordingRequestParams) {\n    await this.call(HMSSignalMethod.START_RTMP_OR_RECORDING_REQUEST, { version: '1.0', ...params });\n  }\n\n  async stopRTMPAndRecording() {\n    await this.call(HMSSignalMethod.STOP_RTMP_AND_RECORDING_REQUEST, { version: '1.0' });\n  }\n\n  async startHLSStreaming(params: HLSRequestParams): Promise<void> {\n    await this.call(HMSSignalMethod.START_HLS_STREAMING, { version: '1.0', ...params });\n  }\n\n  async stopHLSStreaming(params?: HLSRequestParams): Promise<void> {\n    await this.call(HMSSignalMethod.STOP_HLS_STREAMING, { version: '1.0', ...params });\n  }\n\n  async sendHLSTimedMetadata(params?: HLSTimedMetadataParams): Promise<void> {\n    await this.call(HMSSignalMethod.HLS_TIMED_METADATA, { version: '1.0', ...params });\n  }\n\n  async updatePeer(params: UpdatePeerRequestParams) {\n    await this.call(HMSSignalMethod.UPDATE_PEER_METADATA, { version: '1.0', ...params });\n  }\n\n  async setSessionMetadata(params: SessionMetadataUpdateParams) {\n    await this.call(HMSSignalMethod.SET_METADATA, { version: '1.0', ...params });\n  }\n\n  getSessionMetadata() {\n    return this.call<GetSessionMetadataResponse>(HMSSignalMethod.GET_METADATA, { version: '1.0' });\n  }\n\n  private onMessageHandler(event: MessageEvent) {\n    const text: string = event.data;\n    const response = JSON.parse(text);\n\n    if (response.id) {\n      this.handleResponseWithId(response);\n    } else if (response.method) {\n      this.handleResponseWithMethod(response);\n    } else {\n      throw Error(`WebSocket message has no 'method' or 'id' field, message=${response}`);\n    }\n  }\n\n  private handleResponseWithId(response: any) {\n    /** This is a response to [call] */\n    const typedResponse = response as JsonRpcResponse;\n    const id: string = typedResponse.id;\n    if (this.callbacks.has(id)) {\n      const cb = this.callbacks.get(id)!;\n      this.callbacks.delete(id);\n      if (typedResponse.result) {\n        cb.resolve(typedResponse.result);\n      } else {\n        cb.reject(typedResponse.error);\n      }\n    } else {\n      this.observer.onNotification(typedResponse);\n    }\n  }\n\n  private handleResponseWithMethod(response: any) {\n    switch (response.method) {\n      case HMSSignalMethod.OFFER:\n        this.observer.onOffer(response.params);\n        break;\n      case HMSSignalMethod.TRICKLE:\n        this.observer.onTrickle(response.params);\n        break;\n      case HMSSignalMethod.SERVER_ERROR:\n        this.observer.onServerError(\n          ErrorFactory.WebsocketMethodErrors.ServerErrors(\n            Number(response.params.code),\n            HMSAction.NONE,\n            response.params.message,\n          ),\n        );\n        break;\n      case HMSSignalMethod.SERVER_WARNING:\n        HMSLogger.w(this.TAG, response.params);\n        break;\n      default:\n        this.observer.onNotification(response);\n        break;\n    }\n  }\n\n  private rejectPendingCalls(reason = '') {\n    this.callbacks.forEach((callback, id) => {\n      if (callback.metadata?.method !== HMSSignalMethod.PING) {\n        HMSLogger.e(this.TAG, `rejecting pending callback ${callback.metadata?.method}, id=${id}`);\n        callback.reject(\n          ErrorFactory.WebSocketConnectionErrors.WebSocketConnectionLost(\n            callback.metadata?.method\n              ? convertSignalMethodtoErrorAction(callback.metadata?.method)\n              : HMSAction.RECONNECT_SIGNAL,\n            reason,\n          ),\n        );\n        this.callbacks.delete(id);\n      }\n    });\n  }\n\n  private async pingPongLoop(id: number) {\n    const pingTimeout = window.HMS?.PING_TIMEOUT || DEFAULT_SIGNAL_PING_TIMEOUT;\n    if (this.isConnected) {\n      const pongTimeDiff = await this.ping(pingTimeout);\n      this.pongResponseTimes.enqueue(pongTimeDiff);\n      if (pongTimeDiff > pingTimeout) {\n        HMSLogger.d(this.TAG, `Pong timeout ${id}, pageHidden=${isPageHidden()}`);\n        if (this.id === id) {\n          this.setIsConnected(false, 'ping pong failure');\n        }\n      } else {\n        setTimeout(() => this.pingPongLoop(id), window.HMS?.PING_INTERVAL || DEFAULT_SIGNAL_PING_INTERVAL);\n      }\n    }\n  }\n\n  private async call<T>(method: HMSSignalMethod, params: Record<string, any>): Promise<T> {\n    const MAX_RETRIES = 3;\n    let error: HMSException = ErrorFactory.WebsocketMethodErrors.ServerErrors(500, method, `Default ${method} error`);\n\n    for (let i = 0; i < MAX_RETRIES; i++) {\n      try {\n        HMSLogger.d(this.TAG, `Try number ${i + 1} sending ${method}`, params);\n        return await this.internalCall(method, params);\n      } catch (err) {\n        error = err as HMSException;\n        HMSLogger.e(this.TAG, `Failed sending ${method}`, { method, try: i + 1, params, error });\n        const shouldRetry = parseInt(`${error.code / 100}`) === 5 || error.code === 429;\n        if (!shouldRetry) {\n          break;\n        }\n\n        const delay = (2 + Math.random() * 2) * 1000;\n        await sleep(delay);\n      }\n    }\n    HMSLogger.e(`Sending ${method} over WS failed after ${MAX_RETRIES} retries`, { method, params, error });\n    throw error;\n  }\n\n  private offlineListener = () => {\n    HMSLogger.d(this.TAG, 'Window network offline');\n    this.setIsConnected(false, 'Window network offline');\n  };\n\n  private onlineListener = () => {\n    HMSLogger.d(this.TAG, 'Window network online');\n    this.observer.onNetworkOnline();\n  };\n}\n", "import { HMSAction } from '../../error/ErrorFactory';\n\nexport interface JsonRpcRequest {\n  id: string;\n  method: string;\n  params: Map<string, any>;\n}\n\nexport interface JsonRpcResponse {\n  id: string;\n  result: any;\n  error: {\n    code: number;\n    message: string;\n  };\n}\n\nexport enum HMSSignalMethod {\n  JOIN = 'join',\n  OFFER = 'offer',\n  ANSWER = 'answer',\n  TRICKLE = 'trickle',\n  TRACK_UPDATE = 'track-update',\n  BROADCAST = 'broadcast',\n  ANALYTICS = 'analytics',\n  SERVER_ERROR = 'on-error',\n  SERVER_WARNING = 'on-warning',\n  SDK_NOTIFICATION = 'sdk-notification',\n  LEAVE = 'leave',\n  END_ROOM = 'end-room',\n  PING = 'ping',\n  ROLE_CHANGE_REQUEST = 'role-change-request',\n  ROLE_CHANGE = 'role-change',\n  TRACK_UPDATE_REQUEST = 'track-update-request',\n  PEER_LEAVE_REQUEST = 'peer-leave-request',\n  CHANGE_TRACK_MUTE_STATE_REQUEST = 'change-track-mute-state-request',\n  START_RTMP_OR_RECORDING_REQUEST = 'rtmp-start',\n  STOP_RTMP_AND_RECORDING_REQUEST = 'rtmp-stop',\n  UPDATE_PEER_METADATA = 'peer-update',\n  START_HLS_STREAMING = 'hls-start',\n  STOP_HLS_STREAMING = 'hls-stop',\n  HLS_TIMED_METADATA = 'hls-timed-metadata',\n  SET_METADATA = 'set-metadata',\n  GET_METADATA = 'get-metadata',\n}\n\nexport function convertSignalMethodtoErrorAction(method: HMSSignalMethod): HMSAction {\n  switch (method) {\n    case HMSSignalMethod.JOIN:\n      return HMSAction.JOIN;\n    case HMSSignalMethod.OFFER:\n      return HMSAction.PUBLISH;\n    case HMSSignalMethod.ANSWER:\n      return HMSAction.SUBSCRIBE;\n    case HMSSignalMethod.TRACK_UPDATE:\n      return HMSAction.TRACK;\n    default:\n      return HMSAction.NONE;\n  }\n}\n", "// @ts-nocheck\nimport { isBrowser } from './support';\n\nexport const getNetworkInfo = () => {\n  if (!isBrowser || typeof navigator.connection === 'undefined') {\n    return;\n  }\n\n  const connection = navigator.connection;\n  const networkInfo = {\n    downlink: connection.downlink,\n    downlinkMax: connection.downlinkMax,\n    effectiveType: connection.effectiveType,\n    rtt: connection.rtt,\n    saveData: connection.saveData,\n    type: connection.type,\n  };\n  return networkInfo;\n};\n", "import { JoinParameters } from './models/JoinParameters';\nimport { TransportFailureCategory } from './models/TransportFailureCategory';\nimport { TransportState } from './models/TransportState';\nimport ITransport from './ITransport';\nimport ITransportObserver from './ITransportObserver';\nimport { RetryScheduler } from './RetryScheduler';\nimport { AdditionalAnalyticsProperties } from '../analytics/AdditionalAnalyticsProperties';\nimport AnalyticsEvent from '../analytics/AnalyticsEvent';\nimport AnalyticsEventFactory from '../analytics/AnalyticsEventFactory';\nimport { AnalyticsEventsService } from '../analytics/AnalyticsEventsService';\nimport { AnalyticsTimer, TimedEvent } from '../analytics/AnalyticsTimer';\nimport { HTTPAnalyticsTransport } from '../analytics/HTTPAnalyticsTransport';\nimport { SignalAnalyticsTransport } from '../analytics/signal-transport/SignalAnalyticsTransport';\nimport { HMSConnectionRole, HMSTrickle } from '../connection/model';\nimport { IPublishConnectionObserver } from '../connection/publish/IPublishConnectionObserver';\nimport HMSPublishConnection from '../connection/publish/publishConnection';\nimport ISubscribeConnectionObserver from '../connection/subscribe/ISubscribeConnectionObserver';\nimport HMSSubscribeConnection from '../connection/subscribe/subscribeConnection';\nimport { DeviceManager } from '../device-manager';\nimport { ErrorCodes } from '../error/ErrorCodes';\nimport { ErrorFactory, HMSAction } from '../error/ErrorFactory';\nimport { HMSException } from '../error/HMSException';\nimport { EventBus } from '../events/EventBus';\nimport { HLSConfig, HLSTimedMetadata, HMSPeer, HMSRole, HMSRoleChangeRequest } from '../interfaces';\nimport { RTMPRecordingConfig } from '../interfaces/rtmp-recording-config';\nimport HMSLocalStream from '../media/streams/HMSLocalStream';\nimport { HMSLocalTrack, HMSLocalVideoTrack, HMSTrack } from '../media/tracks';\nimport { TrackState } from '../notification-manager';\nimport { HMSWebrtcInternals } from '../rtc-stats/HMSWebrtcInternals';\nimport Message from '../sdk/models/HMSMessage';\nimport { IStore } from '../sdk/store';\nimport InitService from '../signal/init';\nimport { InitConfig, InitFlags } from '../signal/init/models';\nimport {\n  HLSRequestParams,\n  HLSTimedMetadataParams,\n  HLSVariant,\n  MultiTrackUpdateRequestParams,\n  StartRTMPOrRecordingRequestParams,\n  TrackUpdateRequestParams,\n} from '../signal/interfaces';\nimport { ISignal } from '../signal/ISignal';\nimport { ISignalEventsObserver } from '../signal/ISignalEventsObserver';\nimport JsonRpcSignal from '../signal/jsonrpc';\nimport {\n  ICE_DISCONNECTION_TIMEOUT,\n  MAX_TRANSPORT_RETRIES,\n  RENEGOTIATION_CALLBACK_ID,\n  SUBSCRIBE_ICE_CONNECTION_CALLBACK_ID,\n  SUBSCRIBE_TIMEOUT,\n} from '../utils/constants';\nimport HMSLogger from '../utils/logger';\nimport { getNetworkInfo } from '../utils/network-info';\nimport { PromiseCallbacks } from '../utils/promise';\n\nconst TAG = '[HMSTransport]:';\n\n// @DISCUSS: action and extra are not used at all.\ninterface CallbackTriple {\n  promise: PromiseCallbacks<boolean>;\n  action: HMSAction;\n  extra: any;\n}\n\ninterface NegotiateJoinParams {\n  name: string;\n  data: string;\n  autoSubscribeVideo: boolean;\n}\n\nexport default class HMSTransport implements ITransport {\n  private state: TransportState = TransportState.Disconnected;\n  private trackStates: Map<string, TrackState> = new Map();\n  private publishConnection: HMSPublishConnection | null = null;\n  private subscribeConnection: HMSSubscribeConnection | null = null;\n  private initConfig?: InitConfig;\n  private endpoint!: string;\n  private joinParameters?: JoinParameters;\n  private retryScheduler: RetryScheduler;\n  private webrtcInternals?: HMSWebrtcInternals;\n  private maxSubscribeBitrate = 0;\n  private joinRetryCount = 0;\n\n  constructor(\n    private observer: ITransportObserver,\n    private deviceManager: DeviceManager,\n    private store: IStore,\n    private eventBus: EventBus,\n    private analyticsEventsService: AnalyticsEventsService,\n    private analyticsTimer: AnalyticsTimer,\n  ) {\n    this.webrtcInternals = new HMSWebrtcInternals(\n      this.store,\n      this.eventBus,\n      this.publishConnection?.nativeConnection,\n      this.subscribeConnection?.nativeConnection,\n    );\n\n    const onStateChange = async (state: TransportState, error?: HMSException) => {\n      if (state !== this.state) {\n        this.state = state;\n        await this.observer.onStateChange(this.state, error);\n      }\n    };\n    this.retryScheduler = new RetryScheduler(onStateChange, this.sendErrorAnalyticsEvent.bind(this));\n\n    this.eventBus.statsUpdate.subscribe(stats => {\n      const currentSubscribeBitrate = stats.getLocalPeerStats()?.subscribe?.bitrate || 0;\n      this.maxSubscribeBitrate = Math.max(this.maxSubscribeBitrate, currentSubscribeBitrate);\n    });\n  }\n\n  /**\n   * Map of callbacks used to wait for an event to fire.\n   * Used here for:\n   *  1. publish/unpublish waits for [IPublishConnectionObserver.onRenegotiationNeeded] to complete\n   */\n  private readonly callbacks = new Map<string, CallbackTriple>();\n\n  private signalObserver: ISignalEventsObserver = {\n    onOffer: async (jsep: RTCSessionDescriptionInit) => {\n      try {\n        if (!this.subscribeConnection) {\n          return;\n        }\n        await this.subscribeConnection.setRemoteDescription(jsep);\n        HMSLogger.d(\n          TAG,\n          `[SUBSCRIBE] Adding ${this.subscribeConnection.candidates.length} ice-candidates`,\n          this.subscribeConnection.candidates,\n        );\n        for (const candidate of this.subscribeConnection.candidates) {\n          await this.subscribeConnection.addIceCandidate(candidate);\n        }\n        this.subscribeConnection.candidates.length = 0;\n        const answer = await this.subscribeConnection.createAnswer();\n        await this.subscribeConnection.setLocalDescription(answer);\n        this.signal.answer(answer);\n        HMSLogger.d(TAG, '[role=SUBSCRIBE] onOffer renegotiation DONE \u2705');\n      } catch (err) {\n        HMSLogger.d(TAG, '[role=SUBSCRIBE] onOffer renegotiation FAILED \u274C', err);\n        this.state = TransportState.Failed;\n        let ex: HMSException;\n        if (err instanceof HMSException) {\n          ex = err;\n        } else {\n          ex = ErrorFactory.GenericErrors.Unknown(HMSAction.PUBLISH, (err as Error).message);\n        }\n        this.observer.onFailure(ex);\n        this.eventBus.analytics.publish(AnalyticsEventFactory.subscribeFail(ex));\n      }\n    },\n\n    onTrickle: async (trickle: HMSTrickle) => {\n      const connection =\n        trickle.target === HMSConnectionRole.Publish ? this.publishConnection : this.subscribeConnection;\n      if (!connection?.remoteDescription) {\n        // ICE candidates can't be added without any remote session description\n        connection?.candidates.push(trickle.candidate);\n      } else {\n        await connection.addIceCandidate(trickle.candidate);\n      }\n    },\n\n    onNotification: (message: any) => this.observer.onNotification(message),\n\n    onServerError: async (error: HMSException) => {\n      await this.observer.onStateChange(TransportState.Failed, error);\n    },\n\n    onFailure: (error: HMSException) => {\n      // @DISCUSS: Should we remove this? Pong failure would have already scheduled signal retry.\n      if (this.joinParameters) {\n        this.retryScheduler.schedule({\n          category: TransportFailureCategory.SignalDisconnect,\n          error,\n          task: this.retrySignalDisconnectTask,\n          originalState: this.state,\n        });\n      }\n    },\n\n    onOffline: async (reason: string) => {\n      HMSLogger.d(TAG, 'socket offline', TransportState[this.state]);\n      try {\n        if (this.state !== TransportState.Leaving && this.joinParameters) {\n          this.retryScheduler.schedule({\n            category: TransportFailureCategory.SignalDisconnect,\n            error: ErrorFactory.WebSocketConnectionErrors.WebSocketConnectionLost(HMSAction.RECONNECT_SIGNAL, reason),\n            task: this.retrySignalDisconnectTask,\n            originalState: this.state,\n          });\n        }\n      } catch (e) {\n        console.error(e);\n      }\n    },\n\n    // this is called when socket connection is successful\n    onOnline: () => {\n      HMSLogger.d(TAG, 'socket online', TransportState[this.state]);\n      this.analyticsSignalTransport.flushFailedEvents(this.store.getLocalPeer()?.peerId);\n    },\n    // this is called when window.online event is triggered\n    onNetworkOnline: () => {\n      this.analyticsEventsService.flushFailedClientEvents();\n    },\n  };\n\n  private signal: ISignal = new JsonRpcSignal(this.signalObserver);\n  private analyticsSignalTransport = new SignalAnalyticsTransport(this.signal);\n\n  private publishConnectionObserver: IPublishConnectionObserver = {\n    onRenegotiationNeeded: async () => {\n      await this.performPublishRenegotiation();\n    },\n\n    onIceConnectionChange: async (newState: RTCIceConnectionState) => {\n      const log = newState === 'disconnected' ? HMSLogger.w.bind(HMSLogger) : HMSLogger.d.bind(HMSLogger);\n      log(TAG, `Publish ice connection state change: ${newState}`);\n\n      // @TODO: Uncomment this and remove connectionstatechange\n      if (newState === 'failed') {\n        // await this.handleIceConnectionFailure(HMSConnectionRole.Publish);\n      }\n    },\n\n    // @TODO(eswar): Remove this. Use iceconnectionstate change with interval and threshold.\n    onConnectionStateChange: async (newState: RTCPeerConnectionState) => {\n      const log = newState === 'disconnected' ? HMSLogger.w.bind(HMSLogger) : HMSLogger.d.bind(HMSLogger);\n      log(TAG, `Publish connection state change: ${newState}`);\n\n      if (newState === 'connected') {\n        this.publishConnection?.logSelectedIceCandidatePairs();\n      }\n\n      if (newState === 'disconnected') {\n        // if state stays disconnected for 5 seconds, retry\n        setTimeout(() => {\n          if (this.publishConnection?.connectionState === 'disconnected') {\n            this.handleIceConnectionFailure(\n              HMSConnectionRole.Publish,\n              ErrorFactory.WebrtcErrors.ICEDisconnected(\n                HMSAction.PUBLISH,\n                `local candidate - ${this.publishConnection?.selectedCandidatePair?.local.candidate}; remote candidate - ${this.publishConnection?.selectedCandidatePair?.remote.candidate}`,\n              ),\n            );\n          }\n        }, ICE_DISCONNECTION_TIMEOUT);\n      }\n\n      if (newState === 'failed') {\n        await this.handleIceConnectionFailure(\n          HMSConnectionRole.Publish,\n          ErrorFactory.WebrtcErrors.ICEFailure(\n            HMSAction.PUBLISH,\n            `local candidate - ${this.publishConnection?.selectedCandidatePair?.local.candidate}; remote candidate - ${this.publishConnection?.selectedCandidatePair?.remote.candidate}`,\n          ),\n        );\n      }\n    },\n  };\n\n  private subscribeConnectionObserver: ISubscribeConnectionObserver = {\n    onApiChannelMessage: (message: string) => {\n      this.observer.onNotification(JSON.parse(message));\n    },\n\n    onTrackAdd: (track: HMSTrack) => {\n      HMSLogger.d(TAG, '[Subscribe] onTrackAdd', `${track}`);\n      this.observer.onTrackAdd(track);\n    },\n\n    onTrackRemove: (track: HMSTrack) => {\n      HMSLogger.d(TAG, '[Subscribe] onTrackRemove', `${track}`);\n      this.observer.onTrackRemove(track);\n    },\n\n    onIceConnectionChange: async (newState: RTCIceConnectionState) => {\n      const log = newState === 'disconnected' ? HMSLogger.w.bind(HMSLogger) : HMSLogger.d.bind(HMSLogger);\n      log(TAG, `Subscribe ice connection state change: ${newState}`);\n\n      if (newState === 'failed') {\n        // await this.handleIceConnectionFailure(HMSConnectionRole.Subscribe);\n      }\n\n      if (newState === 'connected') {\n        const callback = this.callbacks.get(SUBSCRIBE_ICE_CONNECTION_CALLBACK_ID);\n        this.callbacks.delete(SUBSCRIBE_ICE_CONNECTION_CALLBACK_ID);\n\n        if (callback) {\n          callback.promise.resolve(true);\n        }\n      }\n    },\n\n    // @TODO(eswar): Remove this. Use iceconnectionstate change with interval and threshold.\n    onConnectionStateChange: async (newState: RTCPeerConnectionState) => {\n      const log = newState === 'disconnected' ? HMSLogger.w.bind(HMSLogger) : HMSLogger.d.bind(HMSLogger);\n      log(TAG, `Subscribe connection state change: ${newState}`);\n\n      if (newState === 'failed') {\n        await this.handleIceConnectionFailure(\n          HMSConnectionRole.Subscribe,\n          ErrorFactory.WebrtcErrors.ICEFailure(\n            HMSAction.SUBSCRIBE,\n            `local candidate - ${this.subscribeConnection?.selectedCandidatePair?.local.candidate}; remote candidate - ${this.subscribeConnection?.selectedCandidatePair?.remote.candidate}`,\n          ),\n        );\n      }\n\n      if (newState === 'disconnected') {\n        setTimeout(() => {\n          if (this.subscribeConnection?.connectionState === 'disconnected') {\n            this.handleIceConnectionFailure(\n              HMSConnectionRole.Subscribe,\n              ErrorFactory.WebrtcErrors.ICEDisconnected(\n                HMSAction.SUBSCRIBE,\n                `local candidate - ${this.subscribeConnection?.selectedCandidatePair?.local.candidate}; remote candidate - ${this.subscribeConnection?.selectedCandidatePair?.remote.candidate}`,\n              ),\n            );\n          }\n        }, ICE_DISCONNECTION_TIMEOUT);\n      }\n\n      if (newState === 'connected') {\n        this.handleSubscribeConnectionConnected();\n      }\n    },\n  };\n\n  getWebrtcInternals() {\n    return this.webrtcInternals;\n  }\n\n  isFlagEnabled(flag: InitFlags) {\n    const config = this.initConfig?.config;\n    const flags = config?.enabledFlags || [];\n    return flags.includes(flag);\n  }\n\n  async preview(\n    token: string,\n    endpoint: string,\n    peerId: string,\n    customData: { name: string; metaData: string },\n    autoSubscribeVideo = false,\n  ): Promise<InitConfig | void> {\n    const initConfig = await this.connect(token, endpoint, peerId, customData, autoSubscribeVideo);\n    this.state = TransportState.Preview;\n    this.observer.onStateChange(this.state);\n    return initConfig;\n  }\n\n  async join(\n    authToken: string,\n    peerId: string,\n    customData: { name: string; metaData: string },\n    initEndpoint: string,\n    autoSubscribeVideo = false,\n  ): Promise<void> {\n    HMSLogger.d(TAG, 'join: started \u23F0');\n    try {\n      if (!this.signal.isConnected || !this.initConfig) {\n        await this.connect(authToken, initEndpoint, peerId, customData, autoSubscribeVideo);\n      }\n\n      this.validateNotDisconnected('connect');\n\n      if (this.initConfig) {\n        await this.waitForLocalRoleAvailability();\n        await this.createConnectionsAndNegotiateJoin(customData, autoSubscribeVideo);\n        await this.initRtcStatsMonitor();\n\n        HMSLogger.d(TAG, '\u2705 join: Negotiated over PUBLISH connection');\n      }\n    } catch (error) {\n      HMSLogger.e(TAG, `join: failed \u274C [token=${authToken}]`, error);\n      this.state = TransportState.Failed;\n      const ex = error as HMSException;\n      // set isTerminal to true if not already when error code is 500(internal biz server error)\n      ex.isTerminal = ex.isTerminal || ex.code === 500;\n      await this.observer.onStateChange(this.state, ex);\n      throw ex;\n    }\n\n    HMSLogger.i(TAG, '\u2705 join: successful');\n    this.state = TransportState.Joined;\n    this.observer.onStateChange(this.state);\n  }\n\n  async connect(\n    token: string,\n    endpoint: string,\n    peerId: string,\n    customData: { name: string; metaData: string },\n    autoSubscribeVideo = false,\n  ): Promise<InitConfig | void> {\n    this.setTransportStateForConnect();\n    this.joinParameters = new JoinParameters(\n      token,\n      peerId,\n      customData.name,\n      customData.metaData,\n      endpoint,\n      autoSubscribeVideo,\n    );\n    try {\n      const response = await this.internalConnect(token, endpoint, peerId);\n      return response;\n    } catch (error) {\n      const shouldRetry =\n        error instanceof HMSException &&\n        ([\n          ErrorCodes.WebSocketConnectionErrors.WEBSOCKET_CONNECTION_LOST,\n          ErrorCodes.WebSocketConnectionErrors.FAILED_TO_CONNECT,\n          ErrorCodes.WebSocketConnectionErrors.ABNORMAL_CLOSE,\n          ErrorCodes.InitAPIErrors.ENDPOINT_UNREACHABLE,\n        ].includes(error.code) ||\n          error.code.toString().startsWith('5') ||\n          error.code.toString().startsWith('429'));\n\n      if (shouldRetry) {\n        const task = async () => {\n          await this.internalConnect(token, endpoint, peerId);\n          return Boolean(this.initConfig && this.initConfig.endpoint);\n        };\n\n        await this.retryScheduler.schedule({\n          category: TransportFailureCategory.ConnectFailed,\n          error,\n          task,\n          originalState: this.state,\n          maxFailedRetries: MAX_TRANSPORT_RETRIES,\n          changeState: false,\n        });\n      } else {\n        throw error;\n      }\n    }\n  }\n\n  async leave(notifyServer: boolean): Promise<void> {\n    this.retryScheduler.reset();\n    this.joinParameters = undefined;\n    HMSLogger.d(TAG, 'leaving in transport');\n    try {\n      this.state = TransportState.Leaving;\n      this.webrtcInternals?.cleanUp();\n      await this.publishConnection?.close();\n      await this.subscribeConnection?.close();\n      if (notifyServer) {\n        try {\n          this.signal.leave();\n          HMSLogger.d(TAG, 'signal leave done');\n        } catch (err) {\n          HMSLogger.w(TAG, 'failed to send leave on websocket to server', err);\n        }\n      }\n      this.analyticsEventsService.flushFailedClientEvents();\n      this.analyticsEventsService.reset();\n      await this.signal.close();\n    } catch (err) {\n      this.eventBus.analytics.publish(AnalyticsEventFactory.disconnect(err as Error));\n      HMSLogger.e(TAG, 'leave: FAILED \u274C', err);\n    } finally {\n      this.state = TransportState.Disconnected;\n      this.observer.onStateChange(this.state);\n    }\n  }\n\n  handleLocalRoleUpdate = async ({ oldRole, newRole }: { oldRole: HMSRole; newRole: HMSRole }) => {\n    const changedFromNonWebRTCToWebRTC = !this.doesRoleNeedWebRTC(oldRole) && this.doesRoleNeedWebRTC(newRole);\n    if (!changedFromNonWebRTCToWebRTC) {\n      return;\n    }\n\n    HMSLogger.i(\n      TAG,\n      'Local peer role updated to webrtc role, creating PeerConnections and performing inital publish negotiation \u23F3',\n    );\n    this.createPeerConnections();\n    await this.negotiateOnFirstPublish();\n  };\n\n  async publish(tracks: Array<HMSLocalTrack>): Promise<void> {\n    for (const track of tracks) {\n      try {\n        await this.publishTrack(track);\n      } catch (error) {\n        this.eventBus.analytics.publish(\n          AnalyticsEventFactory.publish({\n            devices: this.deviceManager.getDevices(),\n            error: error as Error,\n          }),\n        );\n      }\n    }\n  }\n\n  async unpublish(tracks: Array<HMSLocalTrack>): Promise<void> {\n    for (const track of tracks) {\n      await this.unpublishTrack(track);\n    }\n  }\n\n  async sendMessage(message: Message) {\n    return await this.signal.broadcast(message);\n  }\n\n  /**\n   * TODO: check if track.publishedTrackId be used instead of the hack to match with track with same type and\n   * source. The hack won't work if there are multiple tracks with same source and type.\n   */\n  trackUpdate(track: HMSLocalTrack) {\n    const currentTrackStates = Array.from(this.trackStates.values());\n    const originalTrackState = currentTrackStates.find(\n      trackState => track.type === trackState.type && track.source === trackState.source,\n    );\n    if (originalTrackState) {\n      const newTrackState = new TrackState({\n        ...originalTrackState,\n        mute: !track.enabled,\n      });\n      this.trackStates.set(originalTrackState.track_id, newTrackState);\n      HMSLogger.d(TAG, 'Track Update', this.trackStates, track);\n      this.signal.trackUpdate(new Map([[originalTrackState.track_id, newTrackState]]));\n    }\n  }\n\n  async changeRole(forPeer: HMSPeer, toRole: string, force = false) {\n    await this.signal.requestRoleChange({\n      requested_for: forPeer.peerId,\n      role: toRole,\n      force,\n    });\n  }\n\n  async changeRoleOfPeer(forPeer: HMSPeer, toRole: string, force: boolean) {\n    await this.signal.requestRoleChange({\n      requested_for: forPeer.peerId,\n      role: toRole,\n      force,\n    });\n  }\n\n  async changeRoleOfPeersWithRoles(roles: HMSRole[], toRole: string) {\n    await this.signal.requestBulkRoleChange({\n      roles: roles.map((role: HMSRole) => role.name),\n      role: toRole,\n      force: true,\n    });\n  }\n\n  async acceptRoleChange(request: HMSRoleChangeRequest) {\n    await this.signal.acceptRoleChangeRequest({\n      requested_by: request.requestedBy?.peerId,\n      role: request.role.name,\n      token: request.token,\n    });\n  }\n\n  async endRoom(lock: boolean, reason: string) {\n    await this.signal.endRoom(lock, reason);\n  }\n\n  async removePeer(peerId: string, reason: string) {\n    await this.signal.removePeer({ requested_for: peerId, reason });\n  }\n\n  async startRTMPOrRecording(params: RTMPRecordingConfig) {\n    const signalParams: StartRTMPOrRecordingRequestParams = {\n      meeting_url: params.meetingURL,\n      record: params.record,\n    };\n\n    if (params.rtmpURLs?.length) {\n      signalParams.rtmp_urls = params.rtmpURLs;\n    }\n\n    if (params.resolution) {\n      signalParams.resolution = params.resolution;\n    }\n\n    await this.signal.startRTMPOrRecording(signalParams);\n  }\n\n  async stopRTMPOrRecording() {\n    await this.signal.stopRTMPAndRecording();\n  }\n\n  async startHLSStreaming(params?: HLSConfig) {\n    const hlsParams: HLSRequestParams = {};\n    if (params && params.variants && params.variants.length > 0) {\n      hlsParams.variants = params.variants.map(variant => {\n        const hlsVariant: HLSVariant = { meeting_url: variant.meetingURL };\n        if (variant.metadata) {\n          hlsVariant.metadata = variant.metadata;\n        }\n        return hlsVariant;\n      });\n    }\n    if (params?.recording) {\n      hlsParams.hls_recording = {\n        single_file_per_layer: params.recording.singleFilePerLayer,\n        hls_vod: params.recording.hlsVod,\n      };\n    }\n    await this.signal.startHLSStreaming(hlsParams);\n  }\n\n  async stopHLSStreaming(params?: HLSConfig) {\n    if (params) {\n      const hlsParams: HLSRequestParams = {\n        variants: params?.variants?.map(variant => {\n          const hlsVariant: HLSVariant = { meeting_url: variant.meetingURL };\n          if (variant.metadata) {\n            hlsVariant.metadata = variant.metadata;\n          }\n          return hlsVariant;\n        }),\n      };\n      await this.signal.stopHLSStreaming(hlsParams);\n    }\n    await this.signal.stopHLSStreaming();\n  }\n\n  async sendHLSTimedMetadata(metadataList: HLSTimedMetadata[]) {\n    if (metadataList.length > 0) {\n      const hlsMtParams: HLSTimedMetadataParams = {\n        metadata_objs: metadataList,\n      };\n\n      await this.signal.sendHLSTimedMetadata(hlsMtParams);\n    }\n  }\n  async changeName(name: string) {\n    const peer = this.store.getLocalPeer();\n    if (peer && peer.name !== name) {\n      await this.signal.updatePeer({\n        name: name,\n      });\n    }\n  }\n\n  async changeMetadata(metadata: string) {\n    await this.signal.updatePeer({\n      data: metadata,\n    });\n  }\n\n  getSessionMetadata() {\n    return this.signal.getSessionMetadata();\n  }\n\n  async setSessionMetadata(metadata: any) {\n    await this.signal.setSessionMetadata({ data: metadata });\n  }\n\n  async changeTrackState(trackUpdateRequest: TrackUpdateRequestParams) {\n    await this.signal.requestTrackStateChange(trackUpdateRequest);\n  }\n\n  async changeMultiTrackState(trackUpdateRequest: MultiTrackUpdateRequestParams) {\n    await this.signal.requestMultiTrackStateChange(trackUpdateRequest);\n  }\n\n  private async publishTrack(track: HMSLocalTrack): Promise<void> {\n    track.publishedTrackId = track.getTrackIDBeingSent();\n    HMSLogger.d(\n      TAG,\n      `\u23F3 publishTrack: trackId=${track.trackId}, toPublishTrackId=${track.publishedTrackId}`,\n      `${track}`,\n    );\n    this.trackStates.set(track.publishedTrackId, new TrackState(track));\n    const p = new Promise<boolean>((resolve, reject) => {\n      this.callbacks.set(RENEGOTIATION_CALLBACK_ID, {\n        promise: { resolve, reject },\n        action: HMSAction.PUBLISH,\n        extra: {},\n      });\n    });\n    const stream = track.stream as HMSLocalStream;\n    stream.setConnection(this.publishConnection!);\n    const simulcastLayers = this.store.getSimulcastLayers(track.source!);\n    stream.addTransceiver(track, simulcastLayers);\n    HMSLogger.time(`publish-${track.trackId}-${track.type}`);\n    await p;\n    HMSLogger.timeEnd(`publish-${track.trackId}-${track.type}`);\n    // add track to store after publish\n    this.store.addTrack(track);\n\n    await stream\n      .setMaxBitrateAndFramerate(track)\n      .then(() => {\n        HMSLogger.d(\n          TAG,\n          `Setting maxBitrate=${track.settings.maxBitrate} kpbs${\n            track instanceof HMSLocalVideoTrack ? ` and maxFramerate=${track.settings.maxFramerate}` : ''\n          } for ${track.source} ${track.type} ${track.trackId}`,\n        );\n      })\n      .catch(error => HMSLogger.w(TAG, 'Failed setting maxBitrate and maxFramerate', error));\n\n    track.isPublished = true;\n\n    HMSLogger.d(TAG, `\u2705 publishTrack: trackId=${track.trackId}`, `${track}`, this.callbacks);\n  }\n\n  private async unpublishTrack(track: HMSLocalTrack): Promise<void> {\n    HMSLogger.d(TAG, `\u23F3 unpublishTrack: trackId=${track.trackId}`, `${track}`);\n    if (track.publishedTrackId && this.trackStates.has(track.publishedTrackId)) {\n      this.trackStates.delete(track.publishedTrackId);\n    } else {\n      // TODO: hotfix to unpublish replaced video track id, solve it properly\n      // it won't work when there are multiple regular video tracks, hmslocalvideotrack can store\n      // the original initial track id for a proper fix\n      const currentTrackStates = Array.from(this.trackStates.values());\n      const originalTrackState = currentTrackStates.find(\n        trackState => track.type === trackState.type && track.source === trackState.source,\n      );\n      if (originalTrackState) {\n        this.trackStates.delete(originalTrackState.track_id);\n      }\n    }\n    const p = new Promise<boolean>((resolve, reject) => {\n      this.callbacks.set(RENEGOTIATION_CALLBACK_ID, {\n        promise: { resolve, reject },\n        action: HMSAction.UNPUBLISH,\n        extra: {},\n      });\n    });\n    const stream = track.stream as HMSLocalStream;\n    stream.removeSender(track);\n    await p;\n    await track.cleanup();\n    // remove track from store on unpublish\n    this.store.removeTrack(track.trackId);\n    HMSLogger.d(TAG, `\u2705 unpublishTrack: trackId=${track.trackId}`, this.callbacks);\n  }\n\n  private waitForLocalRoleAvailability() {\n    if (this.store.hasRoleDetailsArrived()) {\n      return;\n    } else {\n      return new Promise<void>(resolve => {\n        this.eventBus.policyChange.subscribeOnce(() => resolve());\n      });\n    }\n  }\n\n  private async createConnectionsAndNegotiateJoin(\n    customData: { name: string; metaData: string },\n    autoSubscribeVideo = false,\n  ) {\n    const isWebRTC = this.doesLocalPeerNeedWebRTC();\n    if (isWebRTC) {\n      this.createPeerConnections();\n    }\n\n    this.analyticsTimer.start(TimedEvent.JOIN_RESPONSE);\n    await this.negotiateJoinWithRetry({\n      name: customData.name,\n      data: customData.metaData,\n      autoSubscribeVideo,\n      isWebRTC,\n    });\n    this.analyticsTimer.end(TimedEvent.JOIN_RESPONSE);\n  }\n\n  private createPeerConnections() {\n    if (this.initConfig) {\n      if (!this.publishConnection) {\n        this.publishConnection = new HMSPublishConnection(\n          this.signal,\n          this.initConfig.rtcConfiguration,\n          this.publishConnectionObserver,\n          this,\n        );\n      }\n\n      if (!this.subscribeConnection) {\n        this.subscribeConnection = new HMSSubscribeConnection(\n          this.signal,\n          this.initConfig.rtcConfiguration,\n          this.subscribeConnectionObserver,\n        );\n      }\n    }\n  }\n\n  private async negotiateJoinWithRetry({\n    name,\n    data,\n    autoSubscribeVideo,\n    isWebRTC = true,\n  }: NegotiateJoinParams & { isWebRTC: boolean }) {\n    try {\n      await this.negotiateJoin({ name, data, autoSubscribeVideo, isWebRTC });\n    } catch (error) {\n      HMSLogger.e(TAG, 'Join negotiation failed \u274C', error);\n      const hmsError =\n        error instanceof HMSException\n          ? error\n          : ErrorFactory.WebsocketMethodErrors.ServerErrors(\n              500,\n              HMSAction.JOIN,\n              `Websocket join error - ${(error as Error).message}`,\n            );\n      const shouldRetry =\n        parseInt(`${hmsError.code / 100}`) === 5 ||\n        [ErrorCodes.WebSocketConnectionErrors.WEBSOCKET_CONNECTION_LOST, 429].includes(hmsError.code);\n\n      if (shouldRetry) {\n        this.joinRetryCount = 0;\n        hmsError.isTerminal = false;\n        const task = async () => {\n          this.joinRetryCount++;\n          return await this.negotiateJoin({ name, data, autoSubscribeVideo, isWebRTC });\n        };\n\n        await this.retryScheduler.schedule({\n          category: TransportFailureCategory.JoinWSMessageFailed,\n          error: hmsError,\n          task,\n          originalState: TransportState.Joined,\n          maxFailedRetries: 3,\n          changeState: false,\n        });\n      } else {\n        throw error;\n      }\n    }\n  }\n\n  private async negotiateJoin({\n    name,\n    data,\n    autoSubscribeVideo,\n    isWebRTC = true,\n  }: NegotiateJoinParams & { isWebRTC: boolean }): Promise<boolean> {\n    if (isWebRTC) {\n      return await this.negotiateJoinWebRTC({ name, data, autoSubscribeVideo });\n    } else {\n      return await this.negotiateJoinNonWebRTC({ name, data, autoSubscribeVideo });\n    }\n  }\n\n  private async negotiateJoinWebRTC({ name, data, autoSubscribeVideo }: NegotiateJoinParams): Promise<boolean> {\n    HMSLogger.d(TAG, '\u23F3 join: Negotiating over PUBLISH connection');\n    if (!this.publishConnection) {\n      HMSLogger.e(TAG, 'Publish peer connection not found, cannot negotiate');\n      return false;\n    }\n    const offer = await this.publishConnection.createOffer();\n    await this.publishConnection.setLocalDescription(offer);\n    const serverSubDegrade = this.isFlagEnabled(InitFlags.FLAG_SERVER_SUB_DEGRADATION);\n    const simulcast = this.isFlagEnabled(InitFlags.FLAG_SERVER_SIMULCAST);\n    const answer = await this.signal.join(name, data, !autoSubscribeVideo, serverSubDegrade, simulcast, offer);\n    await this.publishConnection.setRemoteDescription(answer);\n    for (const candidate of this.publishConnection.candidates) {\n      await this.publishConnection.addIceCandidate(candidate);\n    }\n\n    this.publishConnection.initAfterJoin();\n    return !!answer;\n  }\n\n  private async negotiateJoinNonWebRTC({ name, data, autoSubscribeVideo }: NegotiateJoinParams): Promise<boolean> {\n    HMSLogger.d(TAG, '\u23F3 join: Negotiating Non-WebRTC');\n    const serverSubDegrade = this.isFlagEnabled(InitFlags.FLAG_SERVER_SUB_DEGRADATION);\n    const simulcast = this.isFlagEnabled(InitFlags.FLAG_SERVER_SIMULCAST);\n    const response = await this.signal.join(name, data, !autoSubscribeVideo, serverSubDegrade, simulcast);\n    return !!response;\n  }\n\n  /**\n   * Negotiate on first publish after changing role from non-webrtc peer to webrtc peer by sending offer\n   */\n  private async negotiateOnFirstPublish() {\n    HMSLogger.d(TAG, '\u23F3 Negotiating offer over PUBLISH connection');\n    if (!this.publishConnection) {\n      HMSLogger.e(TAG, 'Publish peer connection not found, cannot negotiate');\n      return false;\n    }\n    const offer = await this.publishConnection.createOffer(this.trackStates);\n    await this.publishConnection.setLocalDescription(offer);\n    const answer = await this.signal.offer(offer, this.trackStates);\n    await this.publishConnection.setRemoteDescription(answer);\n    for (const candidate of this.publishConnection.candidates) {\n      await this.publishConnection.addIceCandidate(candidate);\n    }\n\n    this.publishConnection.initAfterJoin();\n    return !!answer;\n  }\n\n  private async performPublishRenegotiation(constraints?: RTCOfferOptions) {\n    HMSLogger.d(TAG, `\u23F3 [role=PUBLISH] onRenegotiationNeeded START`, this.trackStates);\n    const callback = this.callbacks.get(RENEGOTIATION_CALLBACK_ID);\n    if (!callback) {\n      return;\n    }\n\n    if (!this.publishConnection) {\n      HMSLogger.e(TAG, 'Publish peer connection not found, cannot renegotiate');\n      return;\n    }\n\n    try {\n      const offer = await this.publishConnection.createOffer(this.trackStates, constraints);\n      await this.publishConnection.setLocalDescription(offer);\n      HMSLogger.time(`renegotiation-offer-exchange`);\n      const answer = await this.signal.offer(offer, this.trackStates);\n      this.callbacks.delete(RENEGOTIATION_CALLBACK_ID);\n      HMSLogger.timeEnd(`renegotiation-offer-exchange`);\n      await this.publishConnection.setRemoteDescription(answer);\n      callback.promise.resolve(true);\n      HMSLogger.d(TAG, `[role=PUBLISH] onRenegotiationNeeded DONE \u2705`);\n    } catch (err) {\n      let ex: HMSException;\n      if (err instanceof HMSException) {\n        ex = err;\n      } else {\n        ex = ErrorFactory.GenericErrors.Unknown(HMSAction.PUBLISH, (err as Error).message);\n      }\n\n      callback!.promise.reject(ex);\n      HMSLogger.d(TAG, `[role=PUBLISH] onRenegotiationNeeded FAILED \u274C`);\n    }\n  }\n\n  private async handleIceConnectionFailure(role: HMSConnectionRole, error: HMSException) {\n    // ice retry is already in progress(from disconnect state)\n    if (\n      this.retryScheduler.isTaskInProgress(\n        HMSConnectionRole.Publish\n          ? TransportFailureCategory.PublishIceConnectionFailed\n          : TransportFailureCategory.SubscribeIceConnectionFailed,\n      )\n    ) {\n      return;\n    }\n\n    if (role === HMSConnectionRole.Publish) {\n      this.retryScheduler.schedule({\n        category: TransportFailureCategory.PublishIceConnectionFailed,\n        error,\n        task: this.retryPublishIceFailedTask,\n        originalState: TransportState.Joined,\n      });\n    } else {\n      this.retryScheduler.schedule({\n        category: TransportFailureCategory.SubscribeIceConnectionFailed,\n        error,\n        task: this.retrySubscribeIceFailedTask,\n        originalState: TransportState.Joined,\n        maxFailedRetries: 1,\n      });\n    }\n  }\n\n  private async internalConnect(token: string, initEndpoint: string, peerId: string) {\n    HMSLogger.d(TAG, 'connect: started \u23F0');\n    const connectRequestedAt = new Date();\n    try {\n      this.analyticsTimer.start(TimedEvent.INIT);\n      this.initConfig = await InitService.fetchInitConfig({\n        token,\n        peerId,\n        userAgent: this.store.getUserAgent(),\n        initEndpoint,\n      });\n      this.analyticsTimer.end(TimedEvent.INIT);\n      HTTPAnalyticsTransport.setWebsocketEndpoint(this.initConfig.endpoint);\n      // if leave was called while init was going on, don't open websocket\n      this.validateNotDisconnected('post init');\n      await this.openSignal(token, peerId);\n      this.store.setSimulcastEnabled(this.isFlagEnabled(InitFlags.FLAG_SERVER_SIMULCAST));\n      HMSLogger.d(TAG, 'Adding Analytics Transport: JsonRpcSignal');\n      this.analyticsEventsService.setTransport(this.analyticsSignalTransport);\n      this.analyticsEventsService.flush();\n      return this.initConfig;\n    } catch (error) {\n      if (this.state !== TransportState.Reconnecting) {\n        this.eventBus.analytics.publish(\n          AnalyticsEventFactory.connect(\n            error as Error,\n            this.getAdditionalAnalyticsProperties(),\n            connectRequestedAt,\n            new Date(),\n            initEndpoint,\n          ),\n        );\n      }\n      HMSLogger.d(TAG, '\u274C internal connect: failed', error);\n      throw error;\n    }\n  }\n\n  // leave could be called between any two async tasks, which would make\n  // the state disconnected instead of connecting, throw error for those cases.\n  private validateNotDisconnected(stage: string) {\n    if (this.state === TransportState.Disconnected) {\n      HMSLogger.w(TAG, 'aborting join as transport state is disconnected');\n      throw ErrorFactory.GenericErrors.ValidationFailed(`leave called before join could complete - stage=${stage}`);\n    }\n  }\n\n  private async openSignal(token: string, peerId: string) {\n    if (!this.initConfig) {\n      throw ErrorFactory.InitAPIErrors.InitConfigNotAvailable(HMSAction.INIT, 'Init Config not found');\n    }\n\n    HMSLogger.d(TAG, '\u23F3 internal connect: connecting to ws endpoint', this.initConfig.endpoint);\n    const url = new URL(this.initConfig.endpoint);\n    url.searchParams.set('peer', peerId);\n    url.searchParams.set('token', token);\n    url.searchParams.set('user_agent_v2', this.store.getUserAgent());\n    this.endpoint = url.toString();\n    this.analyticsTimer.start(TimedEvent.WEBSOCKET_CONNECT);\n    await this.signal.open(this.endpoint);\n    this.analyticsTimer.end(TimedEvent.WEBSOCKET_CONNECT);\n    this.analyticsTimer.start(TimedEvent.ON_POLICY_CHANGE);\n    this.analyticsTimer.start(TimedEvent.ROOM_STATE);\n    HMSLogger.d(TAG, '\u2705 internal connect: connected to ws endpoint');\n  }\n\n  private async initRtcStatsMonitor() {\n    this.webrtcInternals?.setPeerConnections({\n      publish: this.publishConnection?.nativeConnection,\n      subscribe: this.subscribeConnection?.nativeConnection,\n    });\n  }\n\n  /**\n   * Role does not need WebRTC(peer connections to communicate to SFU) if it cannot publish or subscribe to anything\n   * @returns boolean denoting if a peer cannot publish(video, audio or screen) and cannot subscribe to any role\n   */\n  private doesRoleNeedWebRTC(role: HMSRole) {\n    if (!this.isFlagEnabled(InitFlags.FLAG_NON_WEBRTC_DISABLE_OFFER)) {\n      return true;\n    }\n\n    const isPublishing = Boolean(role.publishParams.allowed && role.publishParams.allowed?.length > 0);\n    const isSubscribing = Boolean(\n      role.subscribeParams.subscribeToRoles && role.subscribeParams.subscribeToRoles?.length > 0,\n    );\n\n    return isPublishing || isSubscribing;\n  }\n\n  private doesLocalPeerNeedWebRTC() {\n    const localRole = this.store.getLocalPeer()?.role;\n    if (!localRole) {\n      return true;\n    }\n\n    return this.doesRoleNeedWebRTC(localRole);\n  }\n\n  private retryPublishIceFailedTask = async () => {\n    /**\n     * Proceed with the retry even if the connection state is connected as the offer could have failed\n     * which will cause missing tiles if it is not sent again.\n     * Do iceRestart only if not connected\n     */\n    if (this.publishConnection) {\n      const p = new Promise<boolean>((resolve, reject) => {\n        this.callbacks.set(RENEGOTIATION_CALLBACK_ID, {\n          promise: { resolve, reject },\n          action: HMSAction.RESTART_ICE,\n          extra: {},\n        });\n      });\n      await this.performPublishRenegotiation({ iceRestart: this.publishConnection.connectionState !== 'connected' });\n      await p;\n    }\n\n    return true;\n  };\n\n  private retrySubscribeIceFailedTask = async () => {\n    if (this.subscribeConnection && this.subscribeConnection.connectionState !== 'connected') {\n      const p = new Promise<boolean>((resolve, reject) => {\n        // Use subscribe constant string\n        this.callbacks.set(SUBSCRIBE_ICE_CONNECTION_CALLBACK_ID, {\n          promise: { resolve, reject },\n          action: HMSAction.RESTART_ICE,\n          extra: {},\n        });\n      });\n\n      const timeout = new Promise(resolve => {\n        setTimeout(resolve, SUBSCRIBE_TIMEOUT, false);\n      });\n\n      return Promise.race([p, timeout]) as Promise<boolean>;\n    }\n\n    return true;\n  };\n\n  private retrySignalDisconnectTask = async () => {\n    HMSLogger.d(TAG, 'retrySignalDisconnectTask', { signalConnected: this.signal.isConnected });\n    // Check if ws is disconnected - otherwise if only publishIce fails\n    // and ws connect is success then we don't need to reconnect to WebSocket\n    if (!this.signal.isConnected) {\n      try {\n        await this.internalConnect(\n          this.joinParameters!.authToken,\n          this.joinParameters!.endpoint,\n          this.joinParameters!.peerId,\n        );\n      } catch (ex) {}\n    }\n\n    // Only retry publish failed task after joining the call - not needed in preview signal reconnect\n    const ok = this.store.getRoom().joinedAt\n      ? this.signal.isConnected && (await this.retryPublishIceFailedTask())\n      : this.signal.isConnected;\n    // Send track update to sync local track state changes during reconnection\n    this.signal.trackUpdate(this.trackStates);\n\n    return ok;\n  };\n\n  private handleSubscribeConnectionConnected() {\n    this.subscribeConnection?.logSelectedIceCandidatePairs();\n    const callback = this.callbacks.get(SUBSCRIBE_ICE_CONNECTION_CALLBACK_ID);\n    this.callbacks.delete(SUBSCRIBE_ICE_CONNECTION_CALLBACK_ID);\n\n    if (callback) {\n      callback.promise.resolve(true);\n    }\n  }\n\n  private setTransportStateForConnect() {\n    if (this.state === TransportState.Failed) {\n      this.state = TransportState.Disconnected;\n    }\n\n    if (this.state !== TransportState.Disconnected && this.state !== TransportState.Reconnecting) {\n      throw ErrorFactory.WebsocketMethodErrors.AlreadyJoined(\n        HMSAction.JOIN,\n        `Cannot join a meeting in ${this.state} state`,\n      );\n    }\n\n    if (this.state === TransportState.Disconnected) {\n      this.state = TransportState.Connecting;\n      this.observer.onStateChange(this.state);\n    }\n  }\n\n  private sendErrorAnalyticsEvent(error: HMSException, category: TransportFailureCategory) {\n    const additionalProps = this.getAdditionalAnalyticsProperties();\n    let event: AnalyticsEvent;\n    switch (category) {\n      case TransportFailureCategory.ConnectFailed:\n        event = AnalyticsEventFactory.connect(error, additionalProps);\n        break;\n      case TransportFailureCategory.SignalDisconnect:\n        event = AnalyticsEventFactory.disconnect(error, additionalProps);\n        break;\n      case TransportFailureCategory.JoinWSMessageFailed:\n        event = AnalyticsEventFactory.join({\n          error,\n          time: this.analyticsTimer.getTimeTaken(TimedEvent.JOIN),\n          init_response_time: this.analyticsTimer.getTimeTaken(TimedEvent.INIT),\n          ws_connect_time: this.analyticsTimer.getTimeTaken(TimedEvent.WEBSOCKET_CONNECT),\n          on_policy_change_time: this.analyticsTimer.getTimeTaken(TimedEvent.ON_POLICY_CHANGE),\n          local_audio_track_time: this.analyticsTimer.getTimeTaken(TimedEvent.LOCAL_AUDIO_TRACK),\n          local_video_track_time: this.analyticsTimer.getTimeTaken(TimedEvent.LOCAL_VIDEO_TRACK),\n          retries_join: this.joinRetryCount,\n        });\n        break;\n      case TransportFailureCategory.PublishIceConnectionFailed:\n        event = AnalyticsEventFactory.publish({ error });\n        break;\n      case TransportFailureCategory.SubscribeIceConnectionFailed:\n        event = AnalyticsEventFactory.subscribeFail(error);\n        break;\n    }\n    this.eventBus.analytics.publish(event!);\n  }\n\n  getAdditionalAnalyticsProperties(): AdditionalAnalyticsProperties {\n    const network_info = getNetworkInfo();\n    const document_hidden = typeof document !== 'undefined' && document.hidden;\n    const num_degraded_tracks = this.store.getRemoteVideoTracks().filter(track => track.degraded).length;\n    const publishBitrate = this.getWebrtcInternals()?.getCurrentStats()?.getLocalPeerStats()?.publish?.bitrate;\n    const subscribeBitrate = this.getWebrtcInternals()?.getCurrentStats()?.getLocalPeerStats()?.subscribe?.bitrate;\n\n    return {\n      network_info,\n      document_hidden,\n      num_degraded_tracks,\n      bitrate: {\n        publish: publishBitrate,\n        subscribe: subscribeBitrate,\n      },\n      max_sub_bitrate: this.maxSubscribeBitrate,\n      recent_pong_response_times: this.signal.getPongResponseTimes(),\n      transport_state: this.state,\n    };\n  }\n}\n", "import { ErrorFactory, HMSAction } from '../error/ErrorFactory';\n\nexport interface AuthToken {\n  roomId: string;\n  userId: string;\n  role: string;\n}\n\nexport default function decodeJWT(token?: string): AuthToken {\n  if (!token || token.length === 0) {\n    throw ErrorFactory.InitAPIErrors.InvalidTokenFormat(\n      HMSAction.INIT,\n      'Token cannot be an empty string or undefined or null',\n    );\n  }\n\n  const parts = token.split('.');\n  if (parts.length !== 3) {\n    throw ErrorFactory.InitAPIErrors.InvalidTokenFormat(\n      HMSAction.INIT,\n      `Expected 3 '.' separate fields - header, payload and signature respectively`,\n    );\n  }\n\n  const payloadStr = atob(parts[1]);\n  try {\n    const payload = JSON.parse(payloadStr);\n    return {\n      roomId: payload.room_id,\n      userId: payload.user_id,\n      role: payload.role,\n    } as AuthToken;\n  } catch (err) {\n    throw ErrorFactory.InitAPIErrors.InvalidTokenFormat(\n      HMSAction.INIT,\n      `couldn't parse to json - ${(err as Error).message}`,\n    );\n  }\n}\n", "import Message from './models/HMSMessage';\nimport HMSRoom from './models/HMSRoom';\nimport { HMSLocalPeer, HMSPeer, HMSRemotePeer } from './models/peer';\nimport { LocalTrackManager } from './LocalTrackManager';\nimport { NetworkTestManager } from './NetworkTestManager';\nimport RoleChangeManager from './RoleChangeManager';\nimport { IStore, Store } from './store';\nimport AnalyticsEvent from '../analytics/AnalyticsEvent';\nimport AnalyticsEventFactory from '../analytics/AnalyticsEventFactory';\nimport { HMSAnalyticsLevel } from '../analytics/AnalyticsEventLevel';\nimport { AnalyticsEventsService } from '../analytics/AnalyticsEventsService';\nimport { AnalyticsTimer, TimedEvent } from '../analytics/AnalyticsTimer';\nimport { AudioSinkManager } from '../audio-sink-manager';\nimport { AudioOutputManager, DeviceManager } from '../device-manager';\nimport { DeviceStorageManager } from '../device-manager/DeviceStorage';\nimport { ErrorCodes } from '../error/ErrorCodes';\nimport { ErrorFactory, HMSAction } from '../error/ErrorFactory';\nimport { HMSException } from '../error/HMSException';\nimport { EventBus } from '../events/EventBus';\nimport {\n  HMSChangeMultiTrackStateParams,\n  HMSConfig,\n  HMSConnectionQualityListener,\n  HMSDeviceChangeEvent,\n  HMSFrameworkInfo,\n  HMSMessageInput,\n  HMSPlaylistType,\n  HMSPreviewConfig,\n  HMSRole,\n  HMSRoleChangeRequest,\n  HMSScreenShareConfig,\n} from '../interfaces';\nimport { DeviceChangeListener } from '../interfaces/devices';\nimport { IErrorListener } from '../interfaces/error-listener';\nimport { HLSConfig, HLSTimedMetadata } from '../interfaces/hls-config';\nimport HMSInterface from '../interfaces/hms';\nimport { HMSLeaveRoomRequest } from '../interfaces/leave-room-request';\nimport { HMSPreviewListener } from '../interfaces/preview-listener';\nimport { RTMPRecordingConfig } from '../interfaces/rtmp-recording-config';\nimport InitialSettings from '../interfaces/settings';\nimport { HMSAudioListener, HMSTrackUpdate, HMSUpdateListener } from '../interfaces/update-listener';\nimport HMSLocalStream from '../media/streams/HMSLocalStream';\nimport {\n  HMSLocalAudioTrack,\n  HMSLocalTrack,\n  HMSLocalVideoTrack,\n  HMSRemoteTrack,\n  HMSTrackSource,\n  HMSTrackType,\n} from '../media/tracks';\nimport { HMSNotificationMethod, NotificationManager, PeerLeaveRequestNotification } from '../notification-manager';\nimport { PlaylistManager } from '../playlist-manager';\nimport { InitConfig } from '../signal/init/models';\nimport HMSTransport from '../transport';\nimport ITransportObserver from '../transport/ITransportObserver';\nimport { TransportState } from '../transport/models/TransportState';\nimport decodeJWT from '../utils/jwt';\nimport HMSLogger, { HMSLogLevel } from '../utils/logger';\nimport { HMSAudioContextHandler } from '../utils/media';\nimport { isNode } from '../utils/support';\nimport { validateMediaDevicesExistence, validateRTCPeerConnection } from '../utils/validations';\n\n// @DISCUSS: Adding it here as a hotfix\nconst defaultSettings = {\n  isAudioMuted: false,\n  isVideoMuted: false,\n  audioInputDeviceId: 'default',\n  audioOutputDeviceId: 'default',\n  videoDeviceId: 'default',\n};\n\nconst INITIAL_STATE = {\n  published: false,\n  isInitialised: false,\n  isReconnecting: false,\n  isPreviewInProgress: false,\n  isJoinInProgress: false,\n  deviceManagersInitialised: false,\n};\n\nexport class HMSSdk implements HMSInterface {\n  private transport!: HMSTransport;\n  private readonly TAG = '[HMSSdk]:';\n  private listener?: HMSUpdateListener;\n  private errorListener?: IErrorListener;\n  private deviceChangeListener?: DeviceChangeListener;\n  private audioListener?: HMSAudioListener;\n  private store!: IStore;\n  private notificationManager!: NotificationManager;\n  private deviceManager!: DeviceManager;\n  private audioSinkManager!: AudioSinkManager;\n  private playlistManager!: PlaylistManager;\n  private audioOutput!: AudioOutputManager;\n  private transportState: TransportState = TransportState.Disconnected;\n  private roleChangeManager?: RoleChangeManager;\n  private localTrackManager!: LocalTrackManager;\n  private analyticsEventsService!: AnalyticsEventsService;\n  private analyticsTimer = new AnalyticsTimer();\n  private eventBus!: EventBus;\n  private networkTestManager!: NetworkTestManager;\n  private sdkState = { ...INITIAL_STATE };\n  private frameworkInfo?: HMSFrameworkInfo;\n\n  private initStoreAndManagers() {\n    if (this.sdkState.isInitialised) {\n      /**\n       * Set listener after both join and preview, since they can have different listeners\n       */\n      this.notificationManager.setListener(this.listener);\n      this.audioSinkManager.setListener(this.listener);\n      return;\n    }\n\n    this.sdkState.isInitialised = true;\n    this.store = new Store();\n    this.eventBus = new EventBus();\n    this.networkTestManager = new NetworkTestManager(this.eventBus, this.listener);\n    this.playlistManager = new PlaylistManager(this, this.eventBus);\n    this.notificationManager = new NotificationManager(this.store, this.eventBus, this.listener, this.audioListener);\n    this.deviceManager = new DeviceManager(this.store, this.eventBus);\n    this.audioSinkManager = new AudioSinkManager(this.store, this.deviceManager, this.eventBus);\n    this.audioOutput = new AudioOutputManager(this.deviceManager, this.audioSinkManager);\n    this.audioSinkManager.setListener(this.listener);\n    this.eventBus.autoplayError.subscribe(this.handleAutoplayError);\n    this.localTrackManager = new LocalTrackManager(\n      this.store,\n      this.observer,\n      this.deviceManager,\n      this.eventBus,\n      this.analyticsTimer,\n    );\n    this.analyticsEventsService = new AnalyticsEventsService(this.store);\n    this.transport = new HMSTransport(\n      this.observer,\n      this.deviceManager,\n      this.store,\n      this.eventBus,\n      this.analyticsEventsService,\n      this.analyticsTimer,\n    );\n\n    /**\n     * Note: Subscribe to events here right after creating stores and managers\n     * to not miss events that are published before the handlers are subscribed.\n     */\n    this.eventBus.analytics.subscribe(this.sendAnalyticsEvent);\n    this.eventBus.deviceChange.subscribe(this.handleDeviceChange);\n    this.eventBus.audioPluginFailed.subscribe(this.handleAudioPluginError);\n  }\n\n  private validateJoined(name: string) {\n    if (!this.localPeer) {\n      throw ErrorFactory.GenericErrors.NotConnected(HMSAction.VALIDATION, `Not connected - ${name}`);\n    }\n  }\n\n  async refreshDevices() {\n    this.validateJoined('refreshDevices');\n    await this.deviceManager.init(true);\n  }\n\n  getWebrtcInternals() {\n    return this.transport?.getWebrtcInternals();\n  }\n\n  getPlaylistManager(): PlaylistManager {\n    return this.playlistManager;\n  }\n\n  getRecordingState() {\n    return this.store.getRoom()?.recording;\n  }\n\n  getRTMPState() {\n    return this.store.getRoom()?.rtmp;\n  }\n\n  getHLSState() {\n    return this.store.getRoom()?.hls;\n  }\n\n  private handleAutoplayError = (error: HMSException) => {\n    this.errorListener?.onError?.(error);\n  };\n\n  private get localPeer(): HMSLocalPeer | undefined {\n    return this.store?.getLocalPeer();\n  }\n\n  private observer: ITransportObserver = {\n    onNotification: (message: any) => {\n      if (message.method === HMSNotificationMethod.PEER_LEAVE_REQUEST) {\n        this.handlePeerLeaveRequest(message.params as PeerLeaveRequestNotification);\n        return;\n      }\n\n      switch (message.method) {\n        case HMSNotificationMethod.POLICY_CHANGE:\n          this.analyticsTimer.end(TimedEvent.ON_POLICY_CHANGE);\n          break;\n        case HMSNotificationMethod.PEER_LIST:\n          this.analyticsTimer.end(TimedEvent.PEER_LIST);\n          break;\n        case HMSNotificationMethod.ROOM_STATE:\n          this.analyticsTimer.end(TimedEvent.ROOM_STATE);\n          break;\n        default:\n      }\n\n      this.notificationManager.handleNotification(message, this.sdkState.isReconnecting);\n    },\n\n    onTrackAdd: (track: HMSRemoteTrack) => {\n      this.notificationManager.handleTrackAdd(track);\n    },\n\n    onTrackRemove: (track: HMSRemoteTrack) => {\n      this.notificationManager.handleTrackRemove(track);\n    },\n\n    onFailure: (exception: HMSException) => {\n      this.errorListener?.onError(exception);\n    },\n\n    onStateChange: async (state: TransportState, error?: HMSException) => {\n      const handleFailedState = async (error?: HMSException) => {\n        await this.internalLeave(true, error);\n        /**\n         * no need to call onError here when preview/join is in progress\n         * since preview/join will call onError when they receive leave event from the above call\n         */\n        if (!this.sdkState.isPreviewInProgress && !this.sdkState.isJoinInProgress) {\n          this.errorListener?.onError?.(error!);\n        }\n        this.sdkState.isReconnecting = false;\n      };\n\n      switch (state) {\n        case TransportState.Preview:\n        case TransportState.Joined:\n          if (this.transportState === TransportState.Reconnecting) {\n            this.listener?.onReconnected();\n          }\n          break;\n        case TransportState.Failed:\n          await handleFailedState(error);\n          break;\n        case TransportState.Reconnecting:\n          this.sdkState.isReconnecting = true;\n          this.listener?.onReconnecting(error!);\n          break;\n      }\n\n      this.transportState = state;\n      HMSLogger.d(this.TAG, 'Transport State Change', this.transportState);\n    },\n  };\n\n  private handlePeerLeaveRequest = (message: PeerLeaveRequestNotification) => {\n    const peer = message.requested_by ? this.store.getPeerById(message.requested_by) : undefined;\n    const request: HMSLeaveRoomRequest = {\n      roomEnded: message.room_end,\n      reason: message.reason,\n      requestedBy: peer,\n    };\n    this.listener?.onRemovedFromRoom(request);\n    this.internalLeave(false);\n  };\n\n  async preview(config: HMSPreviewConfig, listener: HMSPreviewListener) {\n    validateMediaDevicesExistence();\n    validateRTCPeerConnection();\n\n    if (this.sdkState.isPreviewInProgress) {\n      return Promise.reject(\n        ErrorFactory.GenericErrors.PreviewAlreadyInProgress(HMSAction.PREVIEW, 'Preview already called'),\n      );\n    }\n\n    this.analyticsTimer.start(TimedEvent.PREVIEW);\n    this.setUpPreview(config, listener);\n\n    // Request permissions and populate devices before waiting for policy\n    if (config.alwaysRequestPermissions) {\n      this.localTrackManager.requestPermissions().then(async () => {\n        await this.initDeviceManagers();\n      });\n    }\n\n    let initSuccessful = false;\n    let networkTestFinished = false;\n    const timerId = setTimeout(() => {\n      // If init or network is not done by 3s send -1\n      if (!initSuccessful || !networkTestFinished) {\n        this.listener?.onNetworkQuality?.(-1);\n      }\n    }, 3000);\n    return new Promise<void>((resolve, reject) => {\n      const policyHandler = async () => {\n        if (this.localPeer) {\n          const newRole = config.asRole && this.store.getPolicyForRole(config.asRole);\n          this.localPeer.asRole = newRole || this.localPeer.role;\n        }\n        const tracks = await this.localTrackManager.getTracksToPublish(config.settings || defaultSettings);\n        tracks.forEach(track => this.setLocalPeerTrack(track));\n        this.localPeer?.audioTrack && this.initPreviewTrackAudioLevelMonitor();\n        await this.initDeviceManagers();\n        this.sdkState.isPreviewInProgress = false;\n        this.analyticsTimer.end(TimedEvent.PREVIEW);\n        listener.onPreview(this.store.getRoom(), tracks);\n        this.sendPreviewAnalyticsEvent();\n        resolve();\n      };\n\n      const errorHandler = (ex?: HMSException) => {\n        this.analyticsTimer.end(TimedEvent.PREVIEW);\n        ex && this.errorListener?.onError(ex);\n        this.sendPreviewAnalyticsEvent(ex);\n        this.sdkState.isPreviewInProgress = false;\n        reject(ex as HMSException);\n      };\n\n      this.eventBus.policyChange.subscribeOnce(policyHandler);\n      this.eventBus.leave.subscribeOnce(errorHandler);\n\n      this.transport\n        .preview(\n          config.authToken,\n          config.initEndpoint!,\n          this.localPeer!.peerId,\n          { name: config.userName, metaData: config.metaData || '' },\n          config.autoVideoSubscribe,\n        )\n        .then((initConfig: InitConfig | void) => {\n          initSuccessful = true;\n          clearTimeout(timerId);\n          if (initConfig && config.captureNetworkQualityInPreview) {\n            this.networkTestManager.start(initConfig.config?.networkHealth).then(() => {\n              networkTestFinished = true;\n            });\n          }\n        })\n        .catch(errorHandler);\n    });\n  }\n\n  private handleDeviceChange = (event: HMSDeviceChangeEvent) => {\n    HMSLogger.d(this.TAG, 'Device Change event', event);\n    this.deviceChangeListener?.onDeviceChange?.(event);\n    if (event.error && event.type) {\n      const track = event.type.includes('audio') ? this.localPeer?.audioTrack : this.localPeer?.videoTrack;\n      this.errorListener?.onError(event.error);\n      if (\n        [\n          ErrorCodes.TracksErrors.CANT_ACCESS_CAPTURE_DEVICE,\n          ErrorCodes.TracksErrors.DEVICE_IN_USE,\n          ErrorCodes.TracksErrors.DEVICE_NOT_AVAILABLE,\n        ].includes(event.error.code) &&\n        track\n      ) {\n        track.setEnabled(false);\n        this.listener?.onTrackUpdate(HMSTrackUpdate.TRACK_MUTED, track, this.localPeer!);\n      }\n    }\n  };\n\n  private handleAudioPluginError = (error: HMSException) => {\n    HMSLogger.e(this.TAG, 'Audio Plugin Error event', error);\n    this.errorListener?.onError(error);\n  };\n\n  async join(config: HMSConfig, listener: HMSUpdateListener) {\n    validateMediaDevicesExistence();\n    validateRTCPeerConnection();\n\n    if (this.sdkState.isPreviewInProgress) {\n      throw ErrorFactory.GenericErrors.NotReady(HMSAction.JOIN, \"Preview is in progress, can't join\");\n    }\n\n    this.analyticsTimer.start(TimedEvent.JOIN);\n    this.sdkState.isJoinInProgress = true;\n\n    const isPreviewCalled = this.transportState === TransportState.Preview;\n    const { roomId, userId, role } = decodeJWT(config.authToken);\n    const previewRole = this.localPeer?.asRole?.name || this.localPeer?.role?.name;\n    this.networkTestManager?.stop();\n    this.listener = listener;\n    this.commonSetup(config, roomId, listener);\n    this.removeDevicesFromConfig(config);\n    this.store.setConfig(config);\n    /** set after config since we need config to get env for user agent */\n    this.store.createAndSetUserAgent(this.frameworkInfo);\n    HMSAudioContextHandler.resumeContext();\n\n    if (!this.localPeer) {\n      this.createAndAddLocalPeerToStore(config, role, userId);\n    } else {\n      this.localPeer.name = config.userName;\n      this.localPeer.role = this.store.getPolicyForRole(role);\n      this.localPeer.customerUserId = userId;\n      this.localPeer.metadata = config.metaData;\n      delete this.localPeer.asRole;\n    }\n\n    this.roleChangeManager = new RoleChangeManager(\n      this.store,\n      this.transport,\n      this.getAndPublishTracks.bind(this),\n      this.removeTrack.bind(this),\n      this.listener,\n    );\n    this.eventBus.localRoleUpdate.subscribe(this.handleLocalRoleUpdate);\n\n    HMSLogger.d(this.TAG, 'SDK Store', this.store);\n    HMSLogger.d(this.TAG, `\u23F3 Joining room ${roomId}`);\n\n    HMSLogger.time(`join-room-${roomId}`);\n\n    try {\n      await this.transport.join(\n        config.authToken,\n        this.localPeer!.peerId,\n        { name: config.userName, metaData: config.metaData! },\n        config.initEndpoint!,\n        config.autoVideoSubscribe,\n      );\n      HMSLogger.d(this.TAG, `\u2705 Joined room ${roomId}`);\n      this.analyticsTimer.start(TimedEvent.PEER_LIST);\n      await this.notifyJoin();\n      this.sdkState.isJoinInProgress = false;\n      this.sendJoinAnalyticsEvent(isPreviewCalled);\n      await this.publish(config.settings || defaultSettings, previewRole);\n    } catch (error) {\n      this.analyticsTimer.end(TimedEvent.JOIN);\n      this.sdkState.isJoinInProgress = false;\n      this.listener?.onError(error as HMSException);\n      this.sendJoinAnalyticsEvent(isPreviewCalled, error as HMSException);\n      HMSLogger.e(this.TAG, 'Unable to join room', error);\n      throw error;\n    }\n    HMSLogger.timeEnd(`join-room-${roomId}`);\n  }\n\n  private stringifyMetadata(config: HMSConfig) {\n    if (config.metaData && typeof config.metaData !== 'string') {\n      config.metaData = JSON.stringify(config.metaData);\n    } else if (!config.metaData) {\n      config.metaData = '';\n    }\n  }\n\n  private cleanUp() {\n    this.cleanDeviceManagers();\n    this.eventBus.analytics.unsubscribe(this.sendAnalyticsEvent);\n    this.analyticsTimer.cleanUp();\n    DeviceStorageManager.cleanup();\n    this.playlistManager.cleanup();\n    HMSLogger.cleanUp();\n    this.sdkState = { ...INITIAL_STATE };\n    /**\n     * when leave is called after preview itself without join.\n     * Store won't have the tracks in this case\n     */\n    if (this.localPeer) {\n      this.localPeer.audioTrack?.cleanup();\n      this.localPeer.audioTrack = undefined;\n      this.localPeer.videoTrack?.cleanup();\n      this.localPeer.videoTrack = undefined;\n    }\n    this.store.cleanUp();\n    this.listener = undefined;\n    if (this.roleChangeManager) {\n      this.eventBus.localRoleUpdate.unsubscribe(this.handleLocalRoleUpdate);\n    }\n  }\n\n  leave(notifyServer?: boolean) {\n    return this.internalLeave(notifyServer);\n  }\n\n  private async internalLeave(notifyServer = true, error?: HMSException) {\n    const room = this.store.getRoom();\n    if (room) {\n      const roomId = room.id;\n      this.networkTestManager?.stop();\n      this.eventBus.leave.publish(error);\n      HMSLogger.d(this.TAG, `\u23F3 Leaving room ${roomId}`);\n      // browsers often put limitation on amount of time a function set on window onBeforeUnload can take in case of\n      // tab refresh or close. Therefore prioritise the leave action over anything else, if tab is closed/refreshed\n      // we would want leave to succeed to stop stucked peer for others. The followup cleanup however is important\n      // for cases where uses stays on the page post leave.\n      await this.transport?.leave(notifyServer);\n      this.cleanUp();\n      HMSLogger.d(this.TAG, `\u2705 Left room ${roomId}`);\n    }\n  }\n\n  getLocalPeer() {\n    return this.store.getLocalPeer();\n  }\n\n  getPeers() {\n    const peers = this.store.getPeers();\n    if (peers.length < 50) {\n      // the log is too big and frequent for large rooms\n      HMSLogger.d(this.TAG, `Got peers(${peers.length})`, peers.toString());\n    }\n    return peers;\n  }\n\n  getAudioOutput() {\n    return this.audioOutput;\n  }\n\n  sendMessage(type: string, message: string) {\n    this.sendMessageInternal({ message, type });\n  }\n\n  async sendBroadcastMessage(message: string, type?: string) {\n    return await this.sendMessageInternal({ message, type });\n  }\n\n  async sendGroupMessage(message: string, roles: HMSRole[], type?: string) {\n    const knownRoles = this.store.getKnownRoles();\n    const recipientRoles =\n      roles.filter(role => {\n        return knownRoles[role.name];\n      }) || [];\n    if (recipientRoles.length === 0) {\n      throw ErrorFactory.GenericErrors.ValidationFailed('No valid role is present', roles);\n    }\n    return await this.sendMessageInternal({ message, recipientRoles: roles, type });\n  }\n\n  async sendDirectMessage(message: string, peer: HMSPeer, type?: string) {\n    const recipientPeer = this.store.getPeerById(peer.peerId);\n    if (!recipientPeer) {\n      throw ErrorFactory.GenericErrors.ValidationFailed('Invalid peer - peer not present in the room', peer);\n    }\n    if (this.localPeer?.peerId === peer.peerId) {\n      throw ErrorFactory.GenericErrors.ValidationFailed('Cannot send message to self');\n    }\n    return await this.sendMessageInternal({ message, recipientPeer: peer, type });\n  }\n\n  private async sendMessageInternal({ recipientRoles, recipientPeer, type = 'chat', message }: HMSMessageInput) {\n    if (message.replace(/\\u200b/g, ' ').trim() === '') {\n      HMSLogger.w(this.TAG, 'sendMessage', 'Ignoring empty message send');\n      throw ErrorFactory.GenericErrors.ValidationFailed('Empty message not allowed');\n    }\n    const hmsMessage = new Message({\n      sender: this.localPeer!,\n      type,\n      message,\n      recipientPeer,\n      recipientRoles,\n      time: new Date(),\n    });\n    HMSLogger.d(this.TAG, 'Sending Message: ', hmsMessage);\n    const response = await this.transport.sendMessage(hmsMessage);\n    hmsMessage.time = new Date(response.timestamp);\n    return hmsMessage;\n  }\n\n  async startScreenShare(onStop: () => void, config?: HMSScreenShareConfig) {\n    const publishParams = this.store.getPublishParams();\n    if (!publishParams) {\n      return;\n    }\n\n    const { allowed } = publishParams;\n    const canPublishScreen = allowed && allowed.includes('screen');\n\n    if (!canPublishScreen) {\n      HMSLogger.e(this.TAG, `Role ${this.localPeer?.role} cannot share screen`);\n      return;\n    }\n\n    if (this.localPeer?.auxiliaryTracks?.find(track => track.source === 'screen')) {\n      throw Error('Cannot share multiple screens');\n    }\n\n    const tracks = await this.getScreenshareTracks(onStop, config);\n    if (!this.localPeer) {\n      HMSLogger.d(this.TAG, 'Screenshared when not connected');\n      tracks.forEach(track => {\n        track.cleanup();\n      });\n      return;\n    }\n    await this.transport.publish(tracks);\n    tracks.forEach(track => {\n      track.peerId = this.localPeer?.peerId;\n      this.localPeer?.auxiliaryTracks.push(track);\n      this.listener?.onTrackUpdate(HMSTrackUpdate.TRACK_ADDED, track, this.localPeer!);\n    });\n  }\n\n  private async stopEndedScreenshare(onStop: () => void) {\n    HMSLogger.d(this.TAG, `\u2705 Screenshare ended natively`);\n    await this.stopScreenShare();\n    onStop();\n  }\n\n  async stopScreenShare() {\n    HMSLogger.d(this.TAG, `\u2705 Screenshare ended from app`);\n    const screenTracks = this.localPeer?.auxiliaryTracks.filter(t => t.source === 'screen');\n    if (screenTracks) {\n      for (const track of screenTracks) {\n        await this.removeTrack(track.trackId);\n      }\n    }\n  }\n\n  async addTrack(track: MediaStreamTrack, source: HMSTrackSource = 'regular'): Promise<void> {\n    if (!track) {\n      HMSLogger.w(this.TAG, 'Please pass a valid MediaStreamTrack');\n      return;\n    }\n    if (!this.localPeer) {\n      throw ErrorFactory.GenericErrors.NotConnected(HMSAction.VALIDATION, 'No local peer present, cannot addTrack');\n    }\n    const isTrackPresent = this.localPeer.auxiliaryTracks.find(t => t.trackId === track.id);\n    if (isTrackPresent) {\n      return;\n    }\n\n    const type = track.kind;\n    const nativeStream = new MediaStream([track]);\n    const stream = new HMSLocalStream(nativeStream);\n\n    const TrackKlass = type === 'audio' ? HMSLocalAudioTrack : HMSLocalVideoTrack;\n    const hmsTrack = new TrackKlass(stream, track, source, this.eventBus);\n    this.setPlaylistSettings({\n      track,\n      hmsTrack,\n      source,\n    });\n\n    await this.transport?.publish([hmsTrack]);\n    hmsTrack.peerId = this.localPeer?.peerId;\n    this.localPeer?.auxiliaryTracks.push(hmsTrack);\n    this.listener?.onTrackUpdate(HMSTrackUpdate.TRACK_ADDED, hmsTrack, this.localPeer!);\n  }\n\n  async removeTrack(trackId: string, internal = false) {\n    if (!this.localPeer) {\n      throw ErrorFactory.GenericErrors.NotConnected(HMSAction.VALIDATION, 'No local peer present, cannot removeTrack');\n    }\n    const trackIndex = this.localPeer.auxiliaryTracks.findIndex(t => t.trackId === trackId);\n    if (trackIndex > -1) {\n      const track = this.localPeer.auxiliaryTracks[trackIndex];\n      if (track.isPublished) {\n        await this.transport!.unpublish([track]);\n      } else {\n        await track.cleanup();\n      }\n      // Stop local playback when playlist track is removed\n      if (!internal) {\n        this.stopPlaylist(track);\n      }\n      this.localPeer.auxiliaryTracks.splice(trackIndex, 1);\n      this.listener?.onTrackUpdate(HMSTrackUpdate.TRACK_REMOVED, track, this.localPeer);\n    } else {\n      HMSLogger.w(this.TAG, `No track found for ${trackId}`);\n    }\n  }\n\n  setAnalyticsLevel(level: HMSAnalyticsLevel) {\n    this.analyticsEventsService.level = level;\n  }\n\n  setLogLevel(level: HMSLogLevel) {\n    HMSLogger.level = level;\n  }\n\n  addAudioListener(audioListener: HMSAudioListener) {\n    this.audioListener = audioListener;\n    this.notificationManager.setAudioListener(audioListener);\n  }\n\n  addConnectionQualityListener(qualityListener: HMSConnectionQualityListener) {\n    this.notificationManager.setConnectionQualityListener(qualityListener);\n  }\n\n  async changeRole(forPeer: HMSPeer, toRole: string, force = false) {\n    if (!forPeer.role || forPeer.role.name === toRole) {\n      return;\n    }\n\n    await this.transport?.changeRoleOfPeer(forPeer, toRole, force);\n  }\n\n  async changeRoleOfPeer(forPeer: HMSPeer, toRole: string, force = false) {\n    if (!forPeer.role || forPeer.role.name === toRole) {\n      return;\n    }\n\n    await this.transport?.changeRoleOfPeer(forPeer, toRole, force);\n  }\n\n  async changeRoleOfPeersWithRoles(roles: HMSRole[], toRole: string) {\n    if (roles.length <= 0 || !toRole) {\n      return;\n    }\n\n    await this.transport?.changeRoleOfPeersWithRoles(roles, toRole);\n  }\n\n  async acceptChangeRole(request: HMSRoleChangeRequest) {\n    await this.transport?.acceptRoleChange(request);\n  }\n\n  async endRoom(lock: boolean, reason: string) {\n    if (!this.localPeer) {\n      throw ErrorFactory.GenericErrors.NotConnected(HMSAction.VALIDATION, 'No local peer present, cannot end room');\n    }\n    await this.transport?.endRoom(lock, reason);\n    await this.leave();\n  }\n\n  async removePeer(peer: HMSRemotePeer, reason: string) {\n    if (!this.localPeer) {\n      throw ErrorFactory.GenericErrors.NotConnected(HMSAction.VALIDATION, 'No local peer present, cannot remove peer');\n    }\n\n    if (!this.store.getPeerById(peer.peerId)) {\n      throw ErrorFactory.GenericErrors.ValidationFailed('Invalid peer, given peer not present in room', peer);\n    }\n    await this.transport?.removePeer(peer.peerId, reason);\n  }\n\n  async startRTMPOrRecording(params: RTMPRecordingConfig) {\n    if (!this.localPeer) {\n      throw ErrorFactory.GenericErrors.NotConnected(\n        HMSAction.VALIDATION,\n        'No local peer present, cannot start streaming or recording',\n      );\n    }\n    await this.transport?.startRTMPOrRecording(params);\n  }\n\n  async stopRTMPAndRecording() {\n    if (!this.localPeer) {\n      throw ErrorFactory.GenericErrors.NotConnected(\n        HMSAction.VALIDATION,\n        'No local peer present, cannot stop streaming or recording',\n      );\n    }\n    await this.transport?.stopRTMPOrRecording();\n  }\n\n  async startHLSStreaming(params?: HLSConfig) {\n    if (!this.localPeer) {\n      throw ErrorFactory.GenericErrors.NotConnected(\n        HMSAction.VALIDATION,\n        'No local peer present, cannot start HLS streaming',\n      );\n    }\n    await this.transport?.startHLSStreaming(params);\n  }\n\n  async stopHLSStreaming(params?: HLSConfig) {\n    if (!this.localPeer) {\n      throw ErrorFactory.GenericErrors.NotConnected(\n        HMSAction.VALIDATION,\n        'No local peer present, cannot stop HLS streaming',\n      );\n    }\n    await this.transport?.stopHLSStreaming(params);\n  }\n\n  async sendHLSTimedMetadata(metadataList: HLSTimedMetadata[]) {\n    this.validateJoined('sendHLSTimedMetadata');\n    await this.transport?.sendHLSTimedMetadata(metadataList);\n  }\n\n  async changeName(name: string) {\n    this.validateJoined('changeName');\n    await this.transport?.changeName(name);\n    this.notificationManager.updateLocalPeer({ name });\n  }\n\n  async changeMetadata(metadata: string) {\n    this.validateJoined('changeMetadata');\n    await this.transport?.changeMetadata(metadata);\n    this.notificationManager.updateLocalPeer({ metadata });\n  }\n\n  async setSessionMetadata(metadata: any) {\n    await this.transport.setSessionMetadata(metadata);\n  }\n\n  async getSessionMetadata() {\n    const response = await this.transport.getSessionMetadata();\n    return response.data;\n  }\n\n  getRoles(): HMSRole[] {\n    return Object.values(this.store.getKnownRoles());\n  }\n\n  async changeTrackState(forRemoteTrack: HMSRemoteTrack, enabled: boolean) {\n    if (forRemoteTrack.type === HMSTrackType.VIDEO && forRemoteTrack.source !== 'regular') {\n      HMSLogger.w(this.TAG, `Muting non-regular video tracks is currently not supported`);\n      return;\n    }\n\n    if (forRemoteTrack.enabled === enabled) {\n      HMSLogger.w(this.TAG, `Aborting change track state, track already has enabled - ${enabled}`, forRemoteTrack);\n      return;\n    }\n\n    if (!this.store.getTrackById(forRemoteTrack.trackId)) {\n      throw ErrorFactory.GenericErrors.ValidationFailed('No track found for change track state', forRemoteTrack);\n    }\n\n    const peer = this.store.getPeerByTrackId(forRemoteTrack.trackId);\n\n    if (!peer) {\n      throw ErrorFactory.GenericErrors.ValidationFailed('No peer found for change track state', forRemoteTrack);\n    }\n\n    await this.transport?.changeTrackState({\n      requested_for: peer.peerId,\n      track_id: forRemoteTrack.trackId,\n      stream_id: forRemoteTrack.stream.id,\n      mute: !enabled,\n    });\n  }\n\n  async changeMultiTrackState(params: HMSChangeMultiTrackStateParams) {\n    if (typeof params.enabled !== 'boolean') {\n      throw ErrorFactory.GenericErrors.ValidationFailed('Pass a boolean for enabled');\n    }\n    const { enabled, roles, type, source } = params;\n    await this.transport?.changeMultiTrackState({\n      value: !enabled,\n      type,\n      source,\n      roles: roles?.map(role => role?.name),\n    });\n  }\n\n  setFrameworkInfo(frameworkInfo: HMSFrameworkInfo) {\n    this.frameworkInfo = frameworkInfo;\n  }\n\n  private async publish(initialSettings: InitialSettings, oldRole?: string) {\n    if ([this.store.getPublishParams(), !this.sdkState.published, !isNode].every(value => !!value)) {\n      // if preview asRole(oldRole) is used, use roleChangeManager to diff policy and publish, else do normal publish\n      const publishAction =\n        oldRole && oldRole !== this.localPeer?.role?.name\n          ? () =>\n              this.roleChangeManager?.diffRolesAndPublishTracks({\n                oldRole: this.store.getPolicyForRole(oldRole),\n                newRole: this.localPeer!.role!,\n              })\n          : () => this.getAndPublishTracks(initialSettings);\n\n      await publishAction?.()?.catch(error => {\n        HMSLogger.e(this.TAG, 'Error in publish', error);\n        this.listener?.onError(error);\n      });\n    }\n  }\n\n  private async getAndPublishTracks(initialSettings: InitialSettings) {\n    const tracks = await this.localTrackManager.getTracksToPublish(initialSettings);\n    await this.setAndPublishTracks(tracks);\n    this.localPeer?.audioTrack?.initAudioLevelMonitor();\n    this.sdkState.published = true;\n  }\n\n  private handleLocalRoleUpdate = async ({ oldRole, newRole }: { oldRole: HMSRole; newRole: HMSRole }) => {\n    await this.transport.handleLocalRoleUpdate({ oldRole, newRole });\n    await this.roleChangeManager?.handleLocalPeerRoleUpdate({ oldRole, newRole });\n  };\n\n  private async setAndPublishTracks(tracks: HMSLocalTrack[]) {\n    for (const track of tracks) {\n      await this.transport.publish([track]);\n      this.setLocalPeerTrack(track);\n      this.listener?.onTrackUpdate(HMSTrackUpdate.TRACK_ADDED, track, this.localPeer!);\n    }\n    await this.initDeviceManagers();\n  }\n\n  private setLocalPeerTrack(track: HMSLocalTrack) {\n    track.peerId = this.localPeer?.peerId;\n    switch (track.type) {\n      case HMSTrackType.AUDIO:\n        this.localPeer!.audioTrack = track as HMSLocalAudioTrack;\n        break;\n\n      case HMSTrackType.VIDEO:\n        this.localPeer!.videoTrack = track as HMSLocalVideoTrack;\n        break;\n    }\n  }\n\n  private async initDeviceManagers() {\n    // No need to initialise and add listeners if already initialised in preview\n    if (this.sdkState.deviceManagersInitialised) {\n      return;\n    }\n    this.sdkState.deviceManagersInitialised = true;\n    await this.deviceManager.init();\n    if (!(await this.deviceManager.updateOutputDevice(this.store.getConfig()?.settings?.audioOutputDeviceId))) {\n      await this.deviceManager.updateOutputDevice(DeviceStorageManager.getSelection()?.audioOutput?.deviceId);\n    }\n    this.audioSinkManager.init(this.store.getConfig()?.audioSinkElementId);\n  }\n\n  private cleanDeviceManagers() {\n    this.eventBus.deviceChange.unsubscribe(this.handleDeviceChange);\n    this.eventBus.audioPluginFailed.unsubscribe(this.handleAudioPluginError);\n    this.eventBus.autoplayError.unsubscribe(this.handleAutoplayError);\n    this.deviceManager.cleanUp();\n    this.audioSinkManager.cleanUp();\n  }\n\n  private initPreviewTrackAudioLevelMonitor() {\n    const localAudioTrack = this.localPeer?.audioTrack;\n    localAudioTrack?.initAudioLevelMonitor();\n    this.eventBus.trackAudioLevelUpdate.subscribe(audioLevelUpdate => {\n      const hmsSpeakers =\n        audioLevelUpdate && audioLevelUpdate.track.trackId === localAudioTrack?.trackId\n          ? [{ audioLevel: audioLevelUpdate.audioLevel, peer: this.localPeer!, track: localAudioTrack! }]\n          : [];\n      this.store.updateSpeakers(hmsSpeakers);\n      this.audioListener?.onAudioLevelUpdate(hmsSpeakers);\n    });\n    this.eventBus.localAudioSilence.subscribe(this.sendAudioPresenceFailed);\n  }\n\n  private notifyJoin() {\n    const localPeer = this.store.getLocalPeer();\n    const room = this.store.getRoom();\n    room.joinedAt = new Date();\n    if (localPeer) {\n      localPeer.joinedAt = room.joinedAt;\n    }\n\n    if (localPeer?.role) {\n      this.analyticsTimer.end(TimedEvent.JOIN);\n      this.listener?.onJoin(room);\n      return;\n    }\n\n    return new Promise<void>((resolve, reject) => {\n      this.eventBus.policyChange.subscribeOnce(() => {\n        this.analyticsTimer.end(TimedEvent.JOIN);\n        this.listener?.onJoin(room);\n        resolve();\n      });\n\n      this.eventBus.leave.subscribeOnce(ex => {\n        reject(ex);\n      });\n    });\n  }\n\n  /**\n   * Init store and other managers, setup listeners, create local peer, room\n   * @param {HMSConfig} config\n   * @param {HMSPreviewListener} listener\n   */\n  private setUpPreview(config: HMSPreviewConfig, listener: HMSPreviewListener) {\n    this.listener = listener as unknown as HMSUpdateListener;\n    this.sdkState.isPreviewInProgress = true;\n    const { roomId, userId, role } = decodeJWT(config.authToken);\n    this.commonSetup(config, roomId, listener);\n    this.store.setConfig(config);\n    /** set after config since we need config to get env for user agent */\n    this.store.createAndSetUserAgent(this.frameworkInfo);\n    this.createAndAddLocalPeerToStore(config, role, userId, config.asRole);\n    HMSLogger.d(this.TAG, 'SDK Store', this.store);\n  }\n\n  /**\n   * Set bitrate and dimensions for playlist track\n   */\n  private async setPlaylistSettings({\n    track,\n    hmsTrack,\n    source,\n  }: {\n    track: MediaStreamTrack;\n    hmsTrack: HMSLocalAudioTrack | HMSLocalVideoTrack;\n    source: string;\n  }) {\n    if (source === 'videoplaylist') {\n      const settings: { maxBitrate?: number; width?: number; height?: number } = {};\n      if (track.kind === 'audio') {\n        settings.maxBitrate = 64;\n      } else {\n        settings.maxBitrate = 1000;\n        const { width, height } = track.getSettings();\n        settings.width = width;\n        settings.height = height;\n      }\n      // TODO: rt update from policy once policy is updated\n      await hmsTrack.setSettings(settings);\n    } else if (source === 'audioplaylist') {\n      // TODO: rt update from policy once policy is updated\n      await hmsTrack.setSettings({ maxBitrate: 64 });\n    }\n  }\n\n  /**\n   * @param {HMSConfig} config\n   * @param {string} role\n   * @param {string} userId\n   */\n  private createAndAddLocalPeerToStore(config: HMSConfig, role: string, userId: string, asRole?: string) {\n    const policy = this.store.getPolicyForRole(role);\n    const asRolePolicy = asRole ? this.store.getPolicyForRole(asRole) : undefined;\n    const localPeer = new HMSLocalPeer({\n      name: config.userName || '',\n      customerUserId: userId,\n      metadata: config.metaData || '',\n      role: policy,\n      // default value is the original role if user didn't pass asRole in config\n      asRole: asRolePolicy || policy,\n    });\n\n    this.store.addPeer(localPeer);\n  }\n\n  /**\n   * init managers and set listeners - common for join and preview\n   * @param {HMSConfig} config\n   * @param {string} roomId\n   * @param {HMSPreviewListener | HMSUpdateListener} listener\n   */\n  private commonSetup(config: HMSConfig, roomId: string, listener: HMSPreviewListener | HMSUpdateListener) {\n    this.stringifyMetadata(config);\n    if (!config.initEndpoint) {\n      config.initEndpoint = 'https://prod-init.100ms.live';\n    }\n    this.errorListener = listener;\n    this.deviceChangeListener = listener;\n    this.initStoreAndManagers();\n\n    this.store.setErrorListener(this.errorListener);\n    if (!this.store.getRoom()) {\n      this.store.setRoom(new HMSRoom(roomId, this.store));\n    }\n  }\n\n  /**\n   * Remove deviceId's passed in config for join if preview was already called\n   * @param {HMSConfig} config\n   */\n  private removeDevicesFromConfig(config: HMSConfig) {\n    const storedConfig = this.store.getConfig();\n    if (storedConfig && config.settings) {\n      // preview was called\n      delete config.settings.audioOutputDeviceId;\n      delete config.settings.videoDeviceId;\n      delete config.settings.audioInputDeviceId;\n    }\n  }\n\n  /**\n   * Get screenshare based on policy and audioOnly flag\n   * @param {function} onStop\n   * @param config\n   * @returns\n   */\n  private async getScreenshareTracks(onStop: () => void, config?: HMSScreenShareConfig) {\n    const [videoTrack, audioTrack] = await this.localTrackManager.getLocalScreen(config);\n\n    const handleEnded = () => {\n      this.stopEndedScreenshare(onStop);\n    };\n\n    const tracks = [];\n    if (config?.audioOnly) {\n      videoTrack.nativeTrack.stop();\n      if (!audioTrack) {\n        throw ErrorFactory.TracksErrors.NothingToReturn(\n          HMSAction.TRACK,\n          'Select share audio when sharing screen',\n          'No audio found',\n        );\n      }\n      tracks.push(audioTrack);\n      audioTrack.nativeTrack.onended = handleEnded;\n    } else {\n      tracks.push(videoTrack);\n      videoTrack.nativeTrack.onended = handleEnded;\n      // audio track is not always available\n      if (audioTrack) {\n        tracks.push(audioTrack);\n      }\n    }\n    return tracks;\n  }\n\n  private sendAudioPresenceFailed = () => {\n    const error = ErrorFactory.TracksErrors.NoAudioDetected(HMSAction.PREVIEW);\n    HMSLogger.w(this.TAG, 'Audio Presence Failure', this.transportState, error);\n    // this.sendAnalyticsEvent(\n    //   AnalyticsEventFactory.audioDetectionFail(error, this.deviceManager.getCurrentSelection().audioInput),\n    // );\n    // this.listener?.onError(error);\n  };\n\n  private sendJoinAnalyticsEvent = (is_preview_called = false, error?: HMSException) => {\n    this.eventBus.analytics.publish(\n      AnalyticsEventFactory.join({\n        error,\n        ...this.analyticsTimer.getTimes(),\n        time: this.analyticsTimer.getTimeTaken(TimedEvent.JOIN),\n        is_preview_called,\n      }),\n    );\n  };\n\n  private sendPreviewAnalyticsEvent = (error?: HMSException) => {\n    this.eventBus.analytics.publish(\n      AnalyticsEventFactory.preview({\n        error,\n        ...this.analyticsTimer.getTimes(TimedEvent.ROOM_STATE),\n        time: this.analyticsTimer.getTimeTaken(TimedEvent.PREVIEW),\n      }),\n    );\n  };\n\n  private sendAnalyticsEvent = (event: AnalyticsEvent) => {\n    this.analyticsEventsService.queue(event).flush();\n  };\n\n  private stopPlaylist(track: HMSLocalTrack) {\n    if (track.source === 'audioplaylist') {\n      this.playlistManager.stop(HMSPlaylistType.audio);\n    } else if (track.source === 'videoplaylist') {\n      this.playlistManager.stop(HMSPlaylistType.video);\n    }\n  }\n}\n", "import { getLocalStream } from './media';\nimport { getAudioTrack, getVideoTrack } from './track';\nimport { HMSAction } from '../error/ErrorFactory';\nimport { HMSException } from '../error/HMSException';\nimport { HMSAudioTrackSettingsBuilder } from '../media/settings/HMSAudioTrackSettings';\nimport { HMSVideoTrackSettingsBuilder } from '../media/settings/HMSVideoTrackSettings';\n\n// Errors out when there's any device error, returns false when there are no device errors.\nexport async function validateDeviceAV() {\n  const videoTrackSettings = new HMSVideoTrackSettingsBuilder().build();\n  const audioTrackSettings = new HMSAudioTrackSettingsBuilder().build();\n  /**\n   * Check audio failure.\n   * If audio failure - check AV failure.\n   * If AV failure - throw AV failure.\n   * If AV passed - throw audio failure.\n   *\n   * If audio passed - check video failure.\n   * If video failure - throw video failure.\n   * If video passed - no error - return false.\n   */\n  try {\n    const track = await getAudioTrack(audioTrackSettings);\n    track.stop();\n  } catch (audioError) {\n    if (isHMSDeviceError(audioError)) {\n      const stream = await getLocalStream({ audio: false, video: true });\n      stream.getTracks().forEach(track => track.stop());\n      throw audioError;\n    }\n  }\n\n  const track = await getVideoTrack(videoTrackSettings);\n  track.stop();\n  return false;\n}\n\nfunction isHMSDeviceError(error: any) {\n  return error instanceof HMSException && error.action === HMSAction.TRACK;\n}\n"],
  "mappings": "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",
  "names": []
}
