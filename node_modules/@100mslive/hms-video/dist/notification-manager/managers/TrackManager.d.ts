import { EventBus } from '../../events/EventBus';
import { HMSUpdateListener } from '../../interfaces';
import { HMSRemoteTrack } from '../../media/tracks';
import { IStore } from '../../sdk/store';
import { OnTrackLayerUpdateNotification, TrackStateNotification } from '../HMSNotifications';
/**
 * Handles:
 * - Incoming track meta-data from BIZ(signal) to match a track to a peer.
 * - Incoming MediaStreamTracks(wrapped in HMSTracks) from RTCMediaChannel.
 * - Mute/unmute track meta-data updates from BIZ.
 *
 * Since track meta-data and RTC tracks come in asynchronously,
 * we store the track meta-data(TrackState) in SDK Store and tracks temporarily here in tracksToProcess.
 *
 * Once we have both TrackState and track,
 * we add it to peer, send listener.onTrackUpdate and remove it from tracksToProcess.
 *
 * Gotchas:
 * - TRACK_UPDATE comes before TRACK_ADD -> update state, process pending tracks when TRACK_ADD arrives.
 */
export declare class TrackManager {
    private store;
    private eventBus;
    listener?: HMSUpdateListener | undefined;
    private readonly TAG;
    private tracksToProcess;
    constructor(store: IStore, eventBus: EventBus, listener?: HMSUpdateListener | undefined);
    handleTrackMetadataAdd(params: TrackStateNotification): void;
    /**
     * Sets the tracks to peer and returns the peer
     */
    handleTrackAdd: (track: HMSRemoteTrack) => void;
    /**
     * Sets the track of corresponding peer to null and returns the peer
     */
    handleTrackRemove: (track: HMSRemoteTrack) => void;
    handleTrackLayerUpdate: (params: OnTrackLayerUpdateNotification) => void;
    handleTrackUpdate: (params: TrackStateNotification) => void;
    processPendingTracks(): void;
    private setLayer;
    private removePeerTracks;
    private addAudioTrack;
    private addVideoTrack;
    private processTrackUpdate;
}
